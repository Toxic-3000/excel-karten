<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spieleliste</title>
<style>
:root{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  --bg:#f6f7f9; --card:#fff; --text:#111; --muted:#6b7280;
  --line:#e9e9e9; --accent:#2536a4; --danger:#b00020; --dangerBg:#ffe7ea;
  --chipBg:#eef2ff; --shadow: 0 10px 24px rgba(0,0,0,.12);
}
body{margin:0;background:var(--bg);color:var(--text)}
header{
  position:sticky;top:0;z-index:20;background:#fff;border-bottom:1px solid #e7e7e7;
}
.headerShell{position:relative}

#fullHeader{
  padding:12px 14px;
  display:grid; gap:10px;
  overflow:hidden;
  max-height:420px;
  opacity:1;
  transform:translateY(0);
  pointer-events:auto;
  will-change: opacity, transform, max-height, padding;
  transition: opacity .14s ease, transform .14s ease, max-height .18s ease, padding .18s ease;
}
header.compact #fullHeader{
  max-height:0;
  padding-top:0;
  padding-bottom:0;
  opacity:0;
  transform:translateY(-6px);
  pointer-events:none;
}

.brand{display:flex;align-items:baseline;gap:10px}
.brand h1{font-size:20px;margin:0}

.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
input,select,button{
  padding:10px 12px;border:1px solid #ddd;border-radius:14px;background:#fff;font-size:14px
}
input,select{flex:1;min-width:150px}
button{cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
.counter{font-size:12px;color:#555}
.hint{font-size:13px;color:var(--muted)}
.primary{border:1px solid #d7ddff;background:var(--chipBg);color:var(--accent);font-weight:900}
.smallHelp{font-size:12px;color:var(--muted);line-height:1.35}

#compactBar{
  padding:10px 14px;
  display:flex; gap:10px; align-items:center;
  border-top:1px solid #f1f1f1;
  background:#fff;

  opacity:0; transform:translateY(6px);
  pointer-events:none;
  will-change: opacity, transform;
  transition: opacity .14s ease, transform .14s ease;
}
header.compact #compactBar{opacity:1; transform:translateY(0); pointer-events:auto;}
#compactSearch{flex:1; min-width:0}
#openSheetBtn{width:52px; flex:0 0 auto; display:inline-flex; align-items:center; justify-content:center; font-weight:900}
#openSheetBtn span{font-size:18px; line-height:1}

main{padding:14px}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(310px,1fr));gap:12px}
.card{
  background:var(--card); border:1px solid var(--line); border-radius:16px;
  padding:12px; box-shadow:0 1px 2px rgba(0,0,0,.04);
  display:grid; gap:10px;
}
.titleRow{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:start}
.title{font-weight:850;font-size:16px;line-height:1.15}
.title.delisted{text-decoration:line-through;color:var(--danger)}
.badges{display:flex;flex-direction:column;gap:8px;align-items:flex-end;min-width:120px}
.badge{
  width:fit-content;font-size:12px;font-weight:800;padding:4px 8px;border-radius:999px;
  background:var(--chipBg);color:var(--accent);white-space:nowrap
}
.badge.delisted{background:var(--dangerBg);color:var(--danger)}
.badge.platin{background:#eef2ff;color:#1f2a8a}
.badge.completed{background:#eaf7ef;color:#166534;border:1px solid #cbead6}
.metaRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.idBadge{font-size:12px;font-weight:900;letter-spacing:.02em;padding:4px 10px;border-radius:999px;background:var(--accent);color:#fff}
.chip{font-size:12px;color:#374151;background:#f3f4f6;border:1px solid #ececec;padding:4px 8px;border-radius:999px;white-space:nowrap}

.keyFacts{display:grid;gap:8px;border-top:1px solid var(--line);padding-top:10px}
.kvLine{display:grid;grid-template-columns:140px 1fr;gap:10px;align-items:start}
.k{color:var(--muted);font-size:12px}
.v{font-size:13px;word-break:break-word}
.detailsWrap{border-top:1px solid var(--line);padding-top:10px}
details{border:0}
summary{cursor:pointer;color:var(--accent);font-size:13px;user-select:none}
summary::-webkit-details-marker{display:none}
.summaryBtn{display:inline-flex;align-items:center;gap:8px}
.summaryBtn::after{content:"â–¾";font-size:12px;transform:translateY(-1px)}
details[open] .summaryBtn::after{content:"â–´"}
.section{border-top:1px solid var(--line);padding-top:10px;margin-top:10px;display:grid;gap:8px}
.sectionTitle{font-size:11px;letter-spacing:.08em;color:var(--muted);text-transform:uppercase}
.subdetails summary{color:#374151;font-size:13px}
.subdetails .summaryBtn{color:#374151}
.subdetails .summaryBtn::after{color:#6b7280}
.subdetails .content{margin-top:8px}
.subdetails .contentText{line-height:1.35;white-space:pre-line}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}

.trophyList{display:grid;gap:8px}
.trophyRow{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:start}
.platformChip{font-size:11px;font-weight:900;padding:2px 8px;border-radius:999px;background:#f3f4f6;border:1px solid #ececec;color:#374151;height:fit-content}
.trophyRight{display:grid;gap:6px}
.trophyText{font-size:13px;color:#111;line-height:1.2}
.progressWrap{display:grid;gap:4px}
.progressBar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
.progressFill{height:100%;background:var(--accent);width:0%}
.progressLabel{font-size:12px;color:var(--muted)}
.statusPill{
  display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border-radius:999px;
  background:#f3f4f6; border:1px solid #ececec;
  font-size:12px; font-weight:900; color:#111;
  width:fit-content;
}
.statusPill.ok{background:#eaf7ef;border-color:#cbead6;color:#166534}
.statusPill.mid{background:#fff7ed;border-color:#fed7aa;color:#9a3412}
.statusPill.dim{background:#f3f4f6;border-color:#ececec;color:#4b5563}

#fabTop{
  position:fixed;right:14px;bottom:16px;z-index:50;
  display:none;border-radius:999px;padding:12px 14px;border:1px solid #ddd;background:#fff;
  box-shadow:var(--shadow);font-weight:900;
}
#fabTop.show{display:inline-flex}

#sheetOverlay{position:fixed;inset:0;z-index:60;background:rgba(0,0,0,.35);display:none}
#sheetOverlay.show{display:block}
#bottomSheet{
  position:fixed;left:0;right:0;bottom:0;z-index:70;background:#fff;border-radius:18px 18px 0 0;
  box-shadow:var(--shadow);transform:translateY(110%);transition:transform .2s ease;
  max-height:78vh;display:grid;grid-template-rows:auto 1fr auto;
}
#bottomSheet.show{transform:translateY(0)}
.handle{width:46px;height:5px;border-radius:999px;background:#e5e7eb;margin:8px auto 0 auto}
.sheetHead{padding:10px 14px;border-bottom:1px solid #eee;display:flex;align-items:center;justify-content:space-between;gap:10px}
.sheetTitle{font-weight:950}
.sheetClose{border:1px solid #ddd;border-radius:12px;padding:8px 10px;background:#fff}
.sheetBody{padding:12px 14px;overflow:auto;display:grid;gap:14px}
.groupTitle{font-size:11px;letter-spacing:.08em;color:var(--muted);text-transform:uppercase}
.sortRow{display:grid;gap:8px}
.sortChoice{
  display:flex;align-items:center;justify-content:space-between;gap:10px;
  padding:10px 10px;border:1px solid #eee;border-radius:14px;background:#fafafa
}
.sortChoice.active{border-color:#d7ddff;background:#f4f6ff}
.sortName{font-weight:850}
.sortMeta{color:var(--muted);font-size:12px}
.dirBtns{display:flex;gap:8px}
.dirBtn{border:1px solid #ddd;border-radius:12px;padding:8px 10px;background:#fff;font-weight:900}
.dirBtn.on{background:var(--chipBg);border-color:#d7ddff;color:var(--accent)}
.togGrid{display:flex;gap:8px;flex-wrap:wrap}
.tog{border:1px solid #eee;background:#fafafa;border-radius:999px;padding:8px 10px;font-size:13px;font-weight:850;cursor:pointer;user-select:none}
.tog.on{background:var(--chipBg);border-color:#d7ddff;color:var(--accent)}
.sheetFoot{padding:10px 14px;border-top:1px solid #eee;display:flex;gap:10px;justify-content:space-between;align-items:center}
.ghost{border:1px solid #ddd;background:#fff}

#sentinel{height:1px}
</style>
</head>
<body>

<header id="hdr">
  <div class="headerShell">
    <div id="fullHeader">
      <div class="brand">
        <h1>Spieleliste</h1>
      </div>

      <div class="row">
        <input id="file" type="file" accept=".xlsx,.xls,.csv,text/csv" />
        <select id="sheetSelect" disabled><option>Sheet auswÃ¤hlenâ€¦</option></select>
      </div>

      <div class="row">
        <input id="search" type="search" placeholder="Sucheâ€¦ (z.B. id:643 dev:capcom completed:1 platform:ps5)" disabled />
        <button id="openSheetBtn2" class="primary" disabled title="Sort & Filter Ã¶ffnen"><span style="font-size:18px;font-weight:900">â˜°</span></button>
      </div>

      <div class="row" style="justify-content:space-between">
        <div class="hint" id="sortLabel">Sort: â€”</div>
        <div class="counter" id="count"></div>
      </div>

      <div class="smallHelp">
        â“˜ Query: <code>id:</code> <code>dev:</code> <code>platform:</code> <code>fav:</code> <code>platin:</code> <code>completed:</code> <code>delisted:</code> <code>psplus:</code> <code>buy:</code> <code>disc:</code>
      </div>
    </div>

    <div id="compactBar">
      <input id="compactSearch" type="search" placeholder="Sucheâ€¦" />
      <button id="openSheetBtn" class="primary" title="Sort & Filter"><span>â˜°</span></button>
    </div>
  </div>
</header>

<main>
  <div id="status" class="hint" style="margin-bottom:10px">Datei wÃ¤hlen â†’ Sheet wÃ¤hlen â†’ suchen</div>
  <div id="grid" class="grid"></div>
  <div id="sentinel"></div>
</main>

<button id="fabTop" aria-label="Nach oben">â†‘ Top</button>

<div id="sheetOverlay"></div>
<div id="bottomSheet" aria-hidden="true">
  <div class="handle"></div>
  <div class="sheetHead">
    <div>
      <div class="sheetTitle">Sortieren & Filtern</div>
      <div class="smallHelp" id="sheetMiniInfo">â€”</div>
    </div>
    <button class="sheetClose" id="sheetClose">SchlieÃŸen</button>
  </div>

  <div class="sheetBody">
    <div class="sortRow">
      <div class="groupTitle">Sortieren nach</div>
      <div id="sortList"></div>
    </div>

    <div>
      <div class="groupTitle">Filter</div>
      <div class="togGrid" id="filterTogs"></div>
    </div>

    <div>
      <div class="groupTitle">System</div>
      <div class="togGrid" id="platformTogs"></div>
    </div>

    <div class="smallHelp">
      Beispiele: <code>completed:1</code> Â· <code>platin:1</code> Â· <code>fav:1</code> Â· <code>platform:ps5</code> Â· <code>psplus:1</code> Â· <code>buy:1</code> Â· <code>disc:1</code>
    </div>
  </div>

  <div class="sheetFoot">
    <button id="clearFiltersBtn" class="ghost">Filter lÃ¶schen</button>
    <button id="applySheetBtn" class="primary">Ãœbernehmen</button>
  </div>
</div>

<script src="xlsx.full.min.js"></script>
<script>
const PAGE_SIZE = 40;
const PLACEHOLDER = "â€”";
const STORAGE_KEY = "spieleliste_view_state_v6";

const COL_ALIASES = {
  id: ["ID"],
  title: ["Spieletitel","Spiel","Titel","Name"],
  system: ["System","Plattform","Platform"],
  source: ["Quelle","Source"],
  genre: ["Genre"],
  dev: ["Entwickler","Developer","Studio"],
  main: ["Spielzeit (Main)","Spielzeit Main","Main Story (Std.)","Main Story"],
  meta: ["Metascore","Pressemeinung (Ã˜)"],
  user: ["Userwertung","Userwertung (Ã˜)"],
  life: ["% Lebenszeit (Humorstatistik)","Humorstatistik â€“ % Lebenszeit","Humorstatistik - % Lebenszeit","% Lebenszeit"],
  fav: ["Favorit","Favorite"],
  platinum: ["Platin","Platinum"],
  trophies: ["TrophÃ¤en Fortschritt","TrophÃ¤en-Fortschritt","TrophÃ¤enfortschritt","Trophies Progress"],
  availability: ["VerfÃ¼gbarkeit","Verfuegbarkeit","Availability"],
  store: ["Store Link","Store-Link","StoreLink","Store"],
  desc: ["Kurzbeschreibung","Beschreibung","Description"],
  special: ["Besonderheiten","Highlights"],
  easter: ["Eastereggs","Easter Eggs"],
  hours: ["Gesamtstunden (Humorstatistik)","Humorstatistik â€“ Gesamtstunden","Humorstatistik - Gesamtstunden"],
  years: ["Jahre (Humorstatistik)","Humorstatistik â€“ Jahre","Humorstatistik - Jahre","Jahre"],
  completedFlag: ["100%","100 %","100% Completed","100 % Completed","Completed (100%)","Komplett (100%)","100% Status"],
};
let COL = {};

const PLATFORM_LIST = ["PS5","PS4","PS3","PS2","PS1","PSVita","Vita","PC","Switch","Xbox","Series","One"];
const PLATFORM_CANON = { "psvita":"vita", "vita":"vita", "ps5":"ps5", "ps4":"ps4", "ps3":"ps3" };

const els = {
  hdr: document.getElementById("hdr"),
  file: document.getElementById("file"),
  sheet: document.getElementById("sheetSelect"),
  search: document.getElementById("search"),
  compactSearch: document.getElementById("compactSearch"),
  openSheetBtn: document.getElementById("openSheetBtn"),
  openSheetBtn2: document.getElementById("openSheetBtn2"),
  sortLabel: document.getElementById("sortLabel"),
  status: document.getElementById("status"),
  count: document.getElementById("count"),
  grid: document.getElementById("grid"),
  sentinel: document.getElementById("sentinel"),
  fabTop: document.getElementById("fabTop"),

  overlay: document.getElementById("sheetOverlay"),
  sheetBox: document.getElementById("bottomSheet"),
  sheetClose: document.getElementById("sheetClose"),
  sortList: document.getElementById("sortList"),
  filterTogs: document.getElementById("filterTogs"),
  platformTogs: document.getElementById("platformTogs"),
  clearFiltersBtn: document.getElementById("clearFiltersBtn"),
  applySheetBtn: document.getElementById("applySheetBtn"),
  sheetMiniInfo: document.getElementById("sheetMiniInfo"),
};

const s = v => (v == null ? "" : String(v).trim());

let workbook = null;
let allRows = [];
let matches = [];
let shown = 0;
let columns = [];
let linkMap = new Map();
let headerRowIndex = 1;
let io = null;
let isLoading = false;

const SORT_KEYS = [
  { key:"__id",   label:"ID",            meta:"numerisch" },
  { key:"__title",label:"Spieletitel",   meta:"Text" },              // changed
  { key:"__system",label:"System",       meta:"Text" },
  { key:"__source",label:"Quelle",       meta:"Text" },
  { key:"__genre",label:"Genre",         meta:"Text" },
  { key:"__dev",  label:"Entwickler",    meta:"Text" },
  { key:"__main", label:"Spielzeit (Main)", meta:"numerisch" },
  { key:"__meta", label:"Metascore",     meta:"numerisch" },
  { key:"__user", label:"Userwertung",   meta:"numerisch" },
  { key:"__life", label:"Lebenszeit %",  meta:"numerisch" },
];

const viewState = {
  fileMode: "",
  sheetName: "",
  search: "",
  sortKey: "__id",
  sortDir: "asc",
  filters: {
    fav:false, platin:false, completed:false, delisted:false,
    ps5:false, ps4:false, ps3:false, vita:false,
    psplus:false, buy:false, disc:false
  },
};

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const st = JSON.parse(raw);
    if (st && typeof st === "object"){
      Object.assign(viewState, st);
      if (st.filters) Object.assign(viewState.filters, st.filters);
    }
  }catch(e){}
}
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(viewState)); }catch(e){} }
loadState();

function normHeader(x){
  return String(x ?? "").replace(/\u00A0/g, " ").replace(/\s+/g, " ").trim().toLowerCase();
}
function resolveColumns(cols){
  const byNorm = new Map(cols.map(c => [normHeader(c), c]));
  const resolved = {};
  for (const [key, aliases] of Object.entries(COL_ALIASES)) {
    let found = "";
    for (const a of aliases) {
      const hit = byNorm.get(normHeader(a));
      if (hit) { found = hit; break; }
    }
    resolved[key] = found;
  }
  return resolved;
}
function val(row, colName){
  if (!colName) return "";
  const v = row[colName];
  return v == null ? "" : String(v).trim();
}

function extractPlatformsFromText(text){
  const t = String(text ?? "");
  const found = [];
  const re = /\b(PS5|PS4|PS3|PS2|PS1|PSVita|Vita|PC|Switch|Xbox|Series|One)\b/g;
  let m;
  while ((m = re.exec(t)) !== null) found.push(m[1]);
  return [...new Set(found)];
}
function platformsFromSystem(row){
  return extractPlatformsFromText(val(row, COL.system));
}
function rowHasPlatform(row, key){
  let plats = platformsFromSystem(row).map(p => p.toLowerCase());
  if (!plats.length){
    const fallback = [...extractPlatformsFromText(val(row, COL.trophies)), ...extractPlatformsFromText(val(row, COL.platinum))].map(p=>p.toLowerCase());
    plats = fallback;
  }
  return plats.some(p => (PLATFORM_CANON[p] || p) === key);
}

/* Source filters (PS Plus / buy / disc) */
function sourceText(row){
  return val(row, COL.source).toLowerCase();
}
function isPSPlus(row){
  const t = sourceText(row);
  return t.includes("ps plus") || t.includes("ps+") || t.includes("plus");
}
function isBuy(row){
  const t = sourceText(row);
  return t.includes("gekauft") || t.includes("kauf") || t.includes("buy") || t.includes("purchased");
}
function isDisc(row){
  const t = sourceText(row);
  return t.includes("disc") || t.includes("disk") || t.includes("retail") || t.includes("blu-ray") || t.includes("bluray");
}

function buildLinks(ws){
  linkMap.clear();
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  headerRowIndex = headerR + 1;

  const headerByCol = new Map();
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    headerByCol.set(c, cell && cell.v != null ? String(cell.v).trim() : "");
  }
  for (let rr = headerR + 1; rr <= r.e.r; rr++){
    const row1 = rr + 1;
    for (let c = r.s.c; c <= r.e.c; c++){
      const cell = ws[XLSX.utils.encode_cell({ r: rr, c })];
      if (cell && cell.l && cell.l.Target){
        const colName = headerByCol.get(c);
        if (colName) linkMap.set(`${row1}:${colName}`, String(cell.l.Target));
      }
    }
  }
}
function applyDelistedFromStyles(ws){
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);
  const titleCol = COL.title;
  if (!titleCol) return;

  const headerR = r.s.r;
  let titleC = null;
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    const h = cell && cell.v != null ? String(cell.v).trim() : "";
    if (h === titleCol) { titleC = c; break; }
  }
  if (titleC == null) return;

  for (let i = 0; i < allRows.length; i++){
    const rr = headerR + 1 + i;
    const cell = ws[XLSX.utils.encode_cell({ r: rr, c: titleC })];
    const strike = !!(cell && cell.s && cell.s.font && (cell.s.font.strike || cell.s.font.strikethrough));
    if (strike) allRows[i].__delisted = true;
  }
}
function isDelistedRow(row){
  if (row.__delisted) return true;
  const v = val(row, COL.availability).toLowerCase();
  return v === "delisted" || v === "removed" || v.includes("store entfernt");
}
function getValueWithLink(row, colName, rowIndex1Based){
  const text = val(row, colName);
  const href = linkMap.get(`${rowIndex1Based}:${colName}`);
  if (href) return { text: text || "Store Link", href };
  return text;
}

function parseAllFractions(text){
  const t = String(text ?? "");
  const out = [];
  const re = /(\d+)\s*(?:of|von|\/)\s*(\d+)/ig;
  let m;
  while ((m = re.exec(t)) !== null){
    const a = parseInt(m[1],10);
    const b = parseInt(m[2],10);
    if (Number.isFinite(a) && Number.isFinite(b) && b > 0) out.push({a,b});
  }
  return out;
}
function isCompleted(row){
  const flag = val(row, COL.completedFlag).toLowerCase();
  if (flag && flag.includes("completed")) return true;
  const prog = val(row, COL.trophies);
  const frs = parseAllFractions(prog);
  if (frs.some(f => f.a === f.b && f.b > 0)) return true;
  return false;
}

function parseFloatLoose(text){
  const t = String(text ?? "").trim();
  if (!t) return NaN;
  const m = t.match(/-?\d+(?:[.,]\d+)?/);
  if (!m) return NaN;
  return parseFloat(m[0].replace(",", "."));
}
function scoreNum(text){ return parseFloatLoose(text); }

function formatFavorite(row){
  const f = val(row, COL.fav).toLowerCase();
  if (!f) return "";
  return (f === "x" || f === "1" || f === "true" || f === "yes" || f === "y" || f.includes("â­")) ? "â­ Favorit" : "";
}
function isPlatinum(row){
  const p = val(row, COL.platinum).toLowerCase();
  if (!p) return false;
  return p.includes("platinum") || p === "x" || p === "ja" || p === "yes" || p === "true";
}

/* Pretty status */
function bestFraction(row){
  const frs = parseAllFractions(val(row, COL.trophies));
  if (!frs.length) return null;
  // best = highest pct, tie -> higher b
  frs.sort((a,b)=> (b.a/b.b)-(a.a/a.b) || b.b-a.b);
  return frs[0];
}
function statusPillNode(row){
  const fr = bestFraction(row);

  const pill = document.createElement("span");
  pill.className = "statusPill";

  if (isCompleted(row)){
    pill.classList.add("ok");
    pill.textContent = "âœ… 100% completed";
    return pill;
  }
  if (isPlatinum(row)){
    pill.classList.add("ok");
    pill.textContent = "ðŸ’Ž Platin";
    return pill;
  }
  if (fr){
    const pct = Math.round((fr.a/fr.b)*100);
    pill.classList.add("mid");
    pill.textContent = `â³ In Arbeit Â· ${pct}% (${fr.a}/${fr.b})`;
    return pill;
  }
  pill.classList.add("dim");
  pill.textContent = "ðŸ’¤ Kein Fortschritt";
  return pill;
}
function completedStatusText(row){
  if (isCompleted(row)) return "100 % completed";
  const flag = val(row, COL.completedFlag);
  if (flag) return flag;
  return PLACEHOLDER;
}

function parseQuery(q){
  const raw = (q || "").trim();
  const tokens = raw.length ? raw.split(/\s+/) : [];
  const filters = { text: [], id:"", dev:"", platform:"", fav:null, platin:null, completed:null, delisted:null, psplus:null, buy:null, disc:null };

  const truthy = v => ["1","true","yes","ja","x"].includes(String(v).toLowerCase());
  const falsy  = v => ["0","false","no","nein"].includes(String(v).toLowerCase());

  for (const t of tokens){
    const m = t.match(/^(\w+)\:(.+)$/);
    if (!m){ filters.text.push(t); continue; }
    const key = m[1].toLowerCase();
    const vv = m[2];

    if (key === "id") filters.id = vv;
    else if (key === "dev") filters.dev = vv;
    else if (key === "platform" || key === "plat") filters.platform = vv.toLowerCase();
    else if (key === "fav") filters.fav = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "platin") filters.platin = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "completed") filters.completed = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "delisted") filters.delisted = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "psplus") filters.psplus = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "buy") filters.buy = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "disc") filters.disc = truthy(vv) ? true : (falsy(vv) ? false : null);
    else filters.text.push(t);
  }
  return filters;
}
function queryMatchesRow(qf, row){
  const txt = qf.text.join(" ").toLowerCase();
  if (txt){
    const hay = Object.values(row).map(v => s(v).toLowerCase()).join(" ");
    if (!hay.includes(txt)) return false;
  }
  if (qf.id && !val(row, COL.id).toLowerCase().includes(qf.id.toLowerCase())) return false;
  if (qf.dev && !val(row, COL.dev).toLowerCase().includes(qf.dev.toLowerCase())) return false;
  if (qf.platform){
    const canon = PLATFORM_CANON[qf.platform] || qf.platform;
    if (!rowHasPlatform(row, canon)) return false;
  }
  if (qf.fav !== null){ if ((!!formatFavorite(row)) !== qf.fav) return false; }
  if (qf.platin !== null){ if (isPlatinum(row) !== qf.platin) return false; }
  if (qf.completed !== null){ if (isCompleted(row) !== qf.completed) return false; }
  if (qf.delisted !== null){ if (isDelistedRow(row) !== qf.delisted) return false; }
  if (qf.psplus !== null){ if (isPSPlus(row) !== qf.psplus) return false; }
  if (qf.buy !== null){ if (isBuy(row) !== qf.buy) return false; }
  if (qf.disc !== null){ if (isDisc(row) !== qf.disc) return false; }
  return true;
}
function rowPassesFilters(row){
  const f = viewState.filters;
  if (f.fav && !formatFavorite(row)) return false;
  if (f.platin && !isPlatinum(row)) return false;
  if (f.completed && !isCompleted(row)) return false;
  if (f.delisted && !isDelistedRow(row)) return false;

  if (f.psplus && !isPSPlus(row)) return false;
  if (f.buy && !isBuy(row)) return false;
  if (f.disc && !isDisc(row)) return false;

  const platformFilters = ["ps5","ps4","ps3","vita"].filter(k => f[k]);
  if (platformFilters.length){
    const ok = platformFilters.some(k => rowHasPlatform(row, k));
    if (!ok) return false;
  }
  return true;
}

function sortValue(row, key){
  if (key === "__id"){
    const n = parseFloatLoose(val(row, COL.id));
    return {t:"num", v: Number.isFinite(n) ? n : Infinity};
  }
  if (key === "__title"){
    const t = val(row, COL.title) || "";
    return {t:"title", v: t};
  }
  if (key === "__system") return {t:"str", v: (val(row, COL.system)||"")};
  if (key === "__source") return {t:"str", v: (val(row, COL.source)||"")};
  if (key === "__genre") return {t:"str", v: (val(row, COL.genre)||"")};
  if (key === "__dev") return {t:"str", v: (val(row, COL.dev)||"")};
  if (key === "__main"){
    const n = parseFloatLoose(val(row, COL.main));
    return {t:"num", v: Number.isFinite(n) ? n : Infinity};
  }
  if (key === "__meta"){
    const n = scoreNum(val(row, COL.meta));
    return {t:"num", v: Number.isFinite(n) ? n : Infinity};
  }
  if (key === "__user"){
    const n = scoreNum(val(row, COL.user));
    return {t:"num", v: Number.isFinite(n) ? n : Infinity};
  }
  if (key === "__life"){
    const n = parseFloatLoose(val(row, COL.life));
    return {t:"num", v: Number.isFinite(n) ? n : Infinity};
  }
  return {t:"str", v:""};
}
function sortMatches(arr){
  const dir = viewState.sortDir === "asc" ? 1 : -1;
  const key = viewState.sortKey;

  arr.sort((a,b) => {
    const av = sortValue(a.row, key);
    const bv = sortValue(b.row, key);

    if (av.t === "num" && bv.t === "num"){
      if (av.v === bv.v) return 0;
      return dir * (av.v < bv.v ? -1 : 1);
    }
    if (av.t === "title" && bv.t === "title"){
      return dir * av.v.localeCompare(bv.v, "de", {
        sensitivity: "base",
        numeric: true,
        ignorePunctuation: true
      });
    }
    const as = String(av.v ?? "");
    const bs = String(bv.v ?? "");
    return dir * as.localeCompare(bs, "de", { sensitivity:"base", numeric:true, ignorePunctuation:true });
  });

  return arr;
}

function renderValue(value){
  if (value && typeof value === "object" && value.href) {
    const a = document.createElement("a");
    a.href = value.href;
    a.textContent = value.text || "Link";
    a.title = value.href;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    return a;
  }
  const t = s(value);
  return document.createTextNode(t || PLACEHOLDER);
}
function kvLine(label, node){
  const line = document.createElement("div");
  line.className = "kvLine";
  const k = document.createElement("div"); k.className="k"; k.textContent=label;
  const v = document.createElement("div"); v.className="v"; v.appendChild(node);
  line.append(k,v);
  return line;
}
function makeChip(text){
  const c = document.createElement("span");
  c.className = "chip"; c.textContent=text;
  return c;
}
function makeBadge(text, cls=""){
  const b = document.createElement("span");
  b.className = "badge" + (cls ? " " + cls : "");
  b.textContent = text;
  return b;
}
function makeToggleBlock(label, contentText){
  const d = document.createElement("details");
  d.className = "subdetails";
  const sum = document.createElement("summary");
  const btn = document.createElement("span");
  btn.className = "summaryBtn";
  btn.textContent = `${label} anzeigen`;
  sum.appendChild(btn);
  d.appendChild(sum);

  const wrap = document.createElement("div"); wrap.className="content";
  const txt = document.createElement("div"); txt.className="v contentText";
  txt.textContent = contentText || PLACEHOLDER;
  wrap.appendChild(txt);
  d.appendChild(wrap);

  d.addEventListener("toggle", () => btn.textContent = d.open ? `${label} ausblenden` : `${label} anzeigen`);
  return d;
}

function parsePlatformPairs(text){
  const t = String(text ?? "").trim();
  if (!t) return [];
  const hits = [];
  for (const p of PLATFORM_LIST) {
    const re = new RegExp(`\\b${p}\\b`, "g");
    let m; while ((m = re.exec(t)) !== null) hits.push({ p, i: m.index });
  }
  hits.sort((a,b)=>a.i-b.i);
  if (!hits.length) return [];
  const out = [];
  for (let j=0;j<hits.length;j++){
    const start = hits[j].i;
    const end = (j+1<hits.length) ? hits[j+1].i : t.length;
    const p = hits[j].p;
    let seg = t.slice(start, end).trim();
    seg = seg.replace(new RegExp(`^${p}\\s*`), "").trim();
    out.push({ platform: p, text: seg || PLACEHOLDER });
  }
  return out;
}
function parseFraction(text){
  const s = String(text ?? "");
  let m = s.match(/(\d+)\s*(?:of|von|\/)\s*(\d+)/i);
  if (!m) return null;
  const a = parseInt(m[1], 10), b = parseInt(m[2], 10);
  if (!b) return null;
  const pct = Math.max(0, Math.min(1, a / b));
  return { a, b, pct };
}
function progressNode(fr){
  const wrap = document.createElement("div"); wrap.className="progressWrap";
  const bar = document.createElement("div"); bar.className="progressBar";
  const fill = document.createElement("div"); fill.className="progressFill"; fill.style.width = `${Math.round(fr.pct*100)}%`;
  bar.appendChild(fill);
  const lab = document.createElement("div"); lab.className="progressLabel"; lab.textContent = `${Math.round(fr.pct*100)}% (${fr.a}/${fr.b})`;
  wrap.append(bar, lab);
  return wrap;
}
function trophyList(items){
  const wrap = document.createElement("div"); wrap.className="trophyList";
  for (const it of items) {
    const rowEl = document.createElement("div"); rowEl.className="trophyRow";
    const chip = document.createElement("span"); chip.className="platformChip"; chip.textContent = it.platform || "â€”";
    const right = document.createElement("div"); right.className="trophyRight";
    const txt = document.createElement("div"); txt.className="trophyText"; txt.textContent = it.text || PLACEHOLDER;
    right.appendChild(txt);
    const fr = parseFraction(it.text);
    if (fr) right.appendChild(progressNode(fr));
    rowEl.append(chip, right);
    wrap.appendChild(rowEl);
  }
  return wrap;
}
function trophyNodeFromText(text){
  const raw = String(text ?? "").trim();
  if (!raw) return document.createTextNode(PLACEHOLDER);
  const pairs = parsePlatformPairs(raw);
  if (pairs.length) return trophyList(pairs);

  const outer = document.createElement("div");
  outer.style.display="grid"; outer.style.gap="8px";
  const txt = document.createElement("div"); txt.className="trophyText"; txt.textContent = raw;
  outer.appendChild(txt);
  const fr = parseFraction(raw);
  if (fr) outer.appendChild(progressNode(fr));
  return outer;
}

function createCard(row, rowIndex1Based){
  const card = document.createElement("div"); card.className="card";

  const titleRow = document.createElement("div"); titleRow.className="titleRow";
  const title = document.createElement("div"); title.className="title";
  title.textContent = val(row, COL.title) || "(ohne Titel)";
  if (isDelistedRow(row)) title.classList.add("delisted");

  const badges = document.createElement("div"); badges.className="badges";
  if (isDelistedRow(row)) badges.appendChild(makeBadge("Delisted","delisted"));
  const favLabel = formatFavorite(row);
  if (favLabel) badges.appendChild(makeBadge(favLabel));
  if (isPlatinum(row)) badges.appendChild(makeBadge("ðŸ’Ž Platin","platin"));
  if (isCompleted(row)) badges.appendChild(makeBadge("âœ… 100 %","completed"));

  titleRow.append(title, badges);

  const metaRow = document.createElement("div"); metaRow.className="metaRow";
  const idB = document.createElement("span"); idB.className="idBadge"; idB.textContent = `ID ${val(row, COL.id) || PLACEHOLDER}`;
  metaRow.appendChild(idB);

  let plats = platformsFromSystem(row);
  if (!plats.length){
    const fromT = extractPlatformsFromText(val(row, COL.trophies));
    const fromP = extractPlatformsFromText(val(row, COL.platinum));
    plats = [...new Set([...fromT, ...fromP])];
  }
  if (plats.length) plats.forEach(p => metaRow.appendChild(makeChip(p)));
  else metaRow.appendChild(makeChip(PLACEHOLDER));
  metaRow.appendChild(makeChip(val(row, COL.availability) || PLACEHOLDER));

  const key = document.createElement("div"); key.className="keyFacts";
  key.appendChild(kvLine("Genre", renderValue(val(row, COL.genre))));
  key.appendChild(kvLine("Entwickler", renderValue(val(row, COL.dev))));
  key.appendChild(kvLine("Spielzeit", renderValue(val(row, COL.main))));
  key.appendChild(kvLine("Metascore", renderValue(val(row, COL.meta))));
  key.appendChild(kvLine("Userwertung", renderValue(val(row, COL.user))));

  const detailsWrap = document.createElement("div"); detailsWrap.className="detailsWrap";
  const details = document.createElement("details");
  const summary = document.createElement("summary");
  const sumSpan = document.createElement("span"); sumSpan.className="summaryBtn"; sumSpan.textContent="Mehr Details";
  summary.appendChild(sumSpan); details.appendChild(summary);
  details.addEventListener("toggle", ()=> sumSpan.textContent = details.open ? "Weniger Details" : "Mehr Details");

  function addSection(titleText, nodes){
    const sec = document.createElement("div"); sec.className="section";
    const st = document.createElement("div"); st.className="sectionTitle"; st.textContent=titleText;
    sec.appendChild(st);
    nodes.forEach(n => sec.appendChild(n));
    details.appendChild(sec);
  }

  const storeVal = (viewState.fileMode === "xlsx")
    ? getValueWithLink(row, COL.store, rowIndex1Based)
    : val(row, COL.store);

  addSection("Beschreibung", [ makeToggleBlock("Kurzbeschreibung", val(row, COL.desc)) ]);

  addSection("Store", [
    kvLine("Quelle", renderValue(val(row, COL.source))),
    kvLine("Store", renderValue(storeVal)),
    kvLine("VerfÃ¼gbarkeit", renderValue(val(row, COL.availability))),
  ]);

  addSection("Extras", [
    makeToggleBlock("Besonderheiten", val(row, COL.special)),
    makeToggleBlock("Eastereggs", val(row, COL.easter)),
  ]);

  addSection("TrophÃ¤en", [
    kvLine("Fortschritt", trophyNodeFromText(val(row, COL.trophies))),
    kvLine("Status", statusPillNode(row)),   // prettier
    kvLine("Platin", trophyNodeFromText(val(row, COL.platinum))),
  ]);

  addSection("Humorstatistik", [
    kvLine("Gesamtstunden", renderValue(val(row, COL.hours))),
    kvLine("% Lebenszeit", renderValue(val(row, COL.life))),
    kvLine("Jahre", renderValue(val(row, COL.years))),
  ]);

  detailsWrap.appendChild(details);
  card.append(titleRow, metaRow, key, detailsWrap);
  return card;
}

function updateCounters(){
  const total = matches.length;
  els.count.textContent = total ? `Treffer: ${total} Â· angezeigt: ${shown}/${total}` : "";
}
function renderMore(){
  if (isLoading) return;
  const total = matches.length;
  if (shown >= total) return;

  isLoading = true;
  const end = Math.min(shown + PAGE_SIZE, total);
  const frag = document.createDocumentFragment();
  for (let i = shown; i < end; i++){
    const { row, idx } = matches[i];
    frag.appendChild(createCard(row, idx));
  }
  els.grid.appendChild(frag);
  shown = end;
  els.status.textContent = total ? (shown < total ? "Lade weitere Kartenâ€¦" : "Alle Karten angezeigt.") : "Keine Treffer.";
  updateCounters();
  isLoading = false;
}

function sortKeyLabel(key){
  const it = SORT_KEYS.find(x=>x.key===key);
  return it ? it.label : key;
}
function activeFilterCount(){
  return Object.values(viewState.filters).filter(Boolean).length;
}
function updateSortLabel(){
  const arrow = viewState.sortDir === "asc" ? "â†‘" : "â†“";
  els.sortLabel.textContent = `Sort: ${sortKeyLabel(viewState.sortKey)} ${arrow}`;
  els.sheetMiniInfo.textContent = `${sortKeyLabel(viewState.sortKey)} ${arrow} Â· Filter aktiv: ${activeFilterCount()}`;
}

function rebuildMatches(){
  els.grid.innerHTML = "";
  shown = 0;

  const q = parseQuery(viewState.search);

  matches = allRows
    .map((row, i) => ({ row, idx: headerRowIndex + 1 + i }))
    .filter(o => queryMatchesRow(q, o.row))
    .filter(o => rowPassesFilters(o.row));

  sortMatches(matches);

  renderMore();

  requestAnimationFrame(() => {
    if (io) { io.disconnect(); io.observe(els.sentinel); }
  });

  els.status.textContent = matches.length ? "Bereit." : "Keine Treffer.";
  updateCounters();
  updateSortLabel();
}

const sheetDraft = {
  sortKey: viewState.sortKey,
  sortDir: viewState.sortDir,
  filters: {...viewState.filters},
};

function openSheet(){
  sheetDraft.sortKey = viewState.sortKey;
  sheetDraft.sortDir = viewState.sortDir;
  sheetDraft.filters = {...viewState.filters};
  renderSheetControls();
  els.overlay.classList.add("show");
  els.sheetBox.classList.add("show");
  els.sheetBox.setAttribute("aria-hidden","false");
}
function closeSheet(){
  els.overlay.classList.remove("show");
  els.sheetBox.classList.remove("show");
  els.sheetBox.setAttribute("aria-hidden","true");
}

function renderSheetControls(){
  els.sortList.innerHTML = "";
  for (const it of SORT_KEYS){
    const row = document.createElement("div");
    row.className = "sortChoice" + (sheetDraft.sortKey === it.key ? " active" : "");
    row.addEventListener("click", () => {
      sheetDraft.sortKey = it.key;
      renderSheetControls();
    });

    const left = document.createElement("div");
    const name = document.createElement("div"); name.className="sortName"; name.textContent = it.label;
    const meta = document.createElement("div"); meta.className="sortMeta"; meta.textContent = it.meta;
    left.append(name, meta);

    const right = document.createElement("div"); right.className="dirBtns";
    const up = document.createElement("button");
    up.className = "dirBtn" + (sheetDraft.sortDir === "asc" && sheetDraft.sortKey === it.key ? " on" : "");
    up.textContent = "â†‘";
    up.addEventListener("click", (e) => {
      e.stopPropagation();
      sheetDraft.sortKey = it.key;
      sheetDraft.sortDir = "asc";
      renderSheetControls();
    });

    const down = document.createElement("button");
    down.className = "dirBtn" + (sheetDraft.sortDir === "desc" && sheetDraft.sortKey === it.key ? " on" : "");
    down.textContent = "â†“";
    down.addEventListener("click", (e) => {
      e.stopPropagation();
      sheetDraft.sortKey = it.key;
      sheetDraft.sortDir = "desc";
      renderSheetControls();
    });

    right.append(up, down);
    row.append(left, right);
    els.sortList.appendChild(row);
  }

  const filterDefs = [
    { key:"fav", label:"â­ Favorit" },
    { key:"platin", label:"ðŸ’Ž Platin" },
    { key:"completed", label:"âœ… 100 %" },
    { key:"delisted", label:"Delisted" },
    { key:"psplus", label:"PS Plus" },
    { key:"buy", label:"gekauft" },
    { key:"disc", label:"Disc" },
  ];
  els.filterTogs.innerHTML = "";
  for (const f of filterDefs){
    const t = document.createElement("div");
    t.className = "tog" + (sheetDraft.filters[f.key] ? " on" : "");
    t.textContent = f.label;
    t.addEventListener("click", () => {
      sheetDraft.filters[f.key] = !sheetDraft.filters[f.key];
      renderSheetControls();
    });
    els.filterTogs.appendChild(t);
  }

  const platformDefs = [
    { key:"ps5", label:"PS5" },
    { key:"ps4", label:"PS4" },
    { key:"ps3", label:"PS3" },
    { key:"vita", label:"Vita" },
  ];
  els.platformTogs.innerHTML = "";
  for (const p of platformDefs){
    const t = document.createElement("div");
    t.className = "tog" + (sheetDraft.filters[p.key] ? " on" : "");
    t.textContent = p.label;
    t.addEventListener("click", () => {
      sheetDraft.filters[p.key] = !sheetDraft.filters[p.key];
      renderSheetControls();
    });
    els.platformTogs.appendChild(t);
  }

  els.sheetMiniInfo.textContent =
    `${sortKeyLabel(sheetDraft.sortKey)} ${(sheetDraft.sortDir==="asc"?"â†‘":"â†“")} Â· Filter aktiv: ${Object.values(sheetDraft.filters).filter(Boolean).length}`;
}

function applySheet(){
  viewState.sortKey = sheetDraft.sortKey;
  viewState.sortDir = sheetDraft.sortDir;
  viewState.filters = {...sheetDraft.filters};
  saveState();
  closeSheet();
  rebuildMatches();
}

function setupObserver(){
  if (io) io.disconnect();
  io = new IntersectionObserver((entries)=>{
    const e = entries[0];
    if (e && e.isIntersecting) renderMore();
  }, { root:null, threshold:0.1 });
  io.observe(els.sentinel);
}
setupObserver();

function resetUIForNewData(){
  els.grid.innerHTML = "";
  els.count.textContent = "";
  els.status.textContent = "Lese Dateiâ€¦";
  els.search.disabled = true;
  els.openSheetBtn.disabled = true;
  els.openSheetBtn2.disabled = true;
  els.sheet.disabled = true;
  els.sheet.innerHTML = "<option>Sheet auswÃ¤hlenâ€¦</option>";
  linkMap.clear();
  headerRowIndex = 1;
  allRows = []; matches = []; shown = 0; columns = [];
  workbook = null;
}

async function loadXLSX(file){
  if (typeof XLSX === "undefined") throw new Error("XLSX Library nicht geladen (xlsx.full.min.js fehlt?)");
  viewState.fileMode = "xlsx";

  const buf = await file.arrayBuffer();
  workbook = XLSX.read(buf, { type: "array", cellStyles: true });

  els.sheet.innerHTML = "<option>Sheet auswÃ¤hlenâ€¦</option>";
  workbook.SheetNames.forEach(n => {
    const o = document.createElement("option");
    o.value = n; o.textContent = n;
    els.sheet.appendChild(o);
  });

  els.sheet.disabled = false;
  els.status.textContent = "Sheet wÃ¤hlenâ€¦";

  if (viewState.sheetName && workbook.SheetNames.includes(viewState.sheetName)){
    els.sheet.value = viewState.sheetName;
    loadSheet(viewState.sheetName);
  }
}

function loadSheet(name){
  const ws = workbook.Sheets[name];
  const json = XLSX.utils.sheet_to_json(ws, { defval: "" });

  allRows = json;
  columns = json.length ? Object.keys(json[0]) : [];
  COL = resolveColumns(columns);

  buildLinks(ws);
  applyDelistedFromStyles(ws);

  viewState.sheetName = name;
  saveState();

  els.search.disabled = false;
  els.openSheetBtn.disabled = false;
  els.openSheetBtn2.disabled = false;

  els.search.value = viewState.search || "";
  els.compactSearch.value = viewState.search || "";

  els.status.textContent = `Geladen: ${allRows.length} Zeilen`;
  rebuildMatches();
}

function detectDelimiter(firstLine){
  const commas = (firstLine.match(/,/g) || []).length;
  const semis  = (firstLine.match(/;/g) || []).length;
  return semis > commas ? ";" : ",";
}
function parseCSV(text){
  const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
  while (lines.length && !lines[0].trim()) lines.shift();
  if (!lines.length) return { rows: [], headers: [] };
  const delim = detectDelimiter(lines[0]);

  function splitLine(line){
    const out = [];
    let cur = "", inQ = false;
    for (let i=0;i<line.length;i++){
      const ch = line[i];
      if (ch === '"'){
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === delim && !inQ){
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(v => v.trim());
  }

  const headers = splitLine(lines[0]).map(h => h.replace(/^\uFEFF/, "").trim());
  const rows = [];
  for (let r=1; r<lines.length; r++){
    const line = lines[r];
    if (!line || !line.trim()) continue;
    const cells = splitLine(line);
    const obj = {};
    for (let c=0; c<headers.length; c++) obj[headers[c]] = cells[c] ?? "";
    rows.push(obj);
  }
  return { rows, headers };
}
async function loadCSV(file){
  viewState.fileMode = "csv";
  workbook = null;
  linkMap.clear();

  const buf = await file.arrayBuffer();
  const text = new TextDecoder("utf-8").decode(buf);
  const parsed = parseCSV(text);

  allRows = parsed.rows;
  columns = parsed.headers;
  COL = resolveColumns(columns);

  els.sheet.disabled = true;
  els.sheet.innerHTML = "<option>(CSV: kein Sheet)</option>";

  els.search.disabled = false;
  els.openSheetBtn.disabled = false;
  els.openSheetBtn2.disabled = false;

  els.search.value = viewState.search || "";
  els.compactSearch.value = viewState.search || "";

  els.status.textContent = `CSV geladen: ${allRows.length} Zeilen`;
  saveState();
  rebuildMatches();
}

els.file.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  resetUIForNewData();
  const name = (f.name || "").toLowerCase();
  try{
    if (name.endsWith(".csv")) await loadCSV(f);
    else await loadXLSX(f);
  }catch(err){
    els.status.textContent = "Fehler beim Einlesen: " + (err?.message || String(err));
  }
});
els.sheet.addEventListener("change", () => {
  const name = els.sheet.value;
  if (!name || name === "Sheet auswÃ¤hlenâ€¦") return;
  loadSheet(name);
});

function setSearch(q){
  viewState.search = q || "";
  els.search.value = viewState.search;
  els.compactSearch.value = viewState.search;
  saveState();
  rebuildMatches();
}
els.search.addEventListener("input", (e) => setSearch(e.target.value));
els.compactSearch.addEventListener("input", (e) => setSearch(e.target.value));

els.openSheetBtn.addEventListener("click", openSheet);
els.openSheetBtn2.addEventListener("click", openSheet);
els.overlay.addEventListener("click", closeSheet);
els.sheetClose.addEventListener("click", closeSheet);
els.applySheetBtn.addEventListener("click", applySheet);
els.clearFiltersBtn.addEventListener("click", () => {
  sheetDraft.filters = {
    fav:false, platin:false, completed:false, delisted:false,
    ps5:false, ps4:false, ps3:false, vita:false,
    psplus:false, buy:false, disc:false
  };
  renderSheetControls();
});

els.fabTop.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));

let lastY = 0;
let isCompact = false;
let rafPending = false;

function setCompact(next){
  if (next === isCompact) return;
  isCompact = next;
  els.hdr.classList.toggle("compact", isCompact);
}
window.addEventListener("scroll", () => {
  if (rafPending) return;
  rafPending = true;

  requestAnimationFrame(() => {
    rafPending = false;

    const y = window.scrollY;
    const goingDown = y > lastY;
    lastY = y;

    els.fabTop.classList.toggle("show", y > 500);

    const active = document.activeElement;
    const typing = active && (active.tagName === "INPUT" || active.tagName === "SELECT" || active.isContentEditable);
    if (typing) return;

    if (!isCompact && goingDown && y > 160) setCompact(true);
    else if (isCompact && !goingDown && y < 220) setCompact(false);
  });
}, { passive:true });

function updateSortLabel(){
  const arrow = viewState.sortDir === "asc" ? "â†‘" : "â†“";
  els.sortLabel.textContent = `Sort: ${sortKeyLabel(viewState.sortKey)} ${arrow}`;
  els.sheetMiniInfo.textContent = `${sortKeyLabel(viewState.sortKey)} ${arrow} Â· Filter aktiv: ${Object.values(viewState.filters).filter(Boolean).length}`;
}
updateSortLabel();
</script>
</body>
</html>