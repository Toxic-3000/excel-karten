<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spieleliste</title>
<style>
:root{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  --bg:#f6f7f9;
  --card:#fff;
  --text:#111;
  --muted:#6b7280;
  --line:#e9e9e9;
  --accent:#2536a4;
  --danger:#b00020;
  --dangerBg:#ffe7ea;
  --chipBg:#eef2ff;
}
body{margin:0;background:var(--bg);color:var(--text)}
header{
  position:sticky;top:0;z-index:10;
  background:#fff;border-bottom:1px solid #e7e7e7;
  padding:12px 14px;display:grid;gap:10px
}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
input,select,button{
  flex:1;min-width:170px;
  padding:10px 12px;border:1px solid #ddd;border-radius:12px;
  background:#fff;font-size:14px
}
button{cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
main{padding:14px}
.hint{color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(310px,1fr));gap:12px}

.card{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  box-shadow:0 1px 2px rgba(0,0,0,.04);
  display:grid;gap:10px
}
.cardTop{display:grid;gap:6px}
.titleRow{display:flex;gap:10px;align-items:flex-start;justify-content:space-between}
.title{font-weight:800;font-size:16px;line-height:1.15}
.title.delisted{ text-decoration:line-through; color:var(--danger); }
.badges{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
.badge{
  font-size:12px;font-weight:650;
  padding:4px 8px;border-radius:999px;
  background:var(--chipBg);color:var(--accent);
  white-space:nowrap
}
.badge.delisted{background:var(--dangerBg);color:var(--danger)}
.badge.platin{background:#eef2ff;color:#1f2a8a}

.metaRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.chip{
  font-size:12px;color:#374151;
  background:#f3f4f6;border:1px solid #ececec;
  padding:4px 8px;border-radius:999px;
  white-space:nowrap
}
/* ID hervorheben */
.idBadge{
  font-size:12px;
  font-weight:900;
  letter-spacing:.02em;
  padding:4px 10px;
  border-radius:999px;
  background:var(--accent);
  color:#fff;
  border:1px solid rgba(0,0,0,0.05);
}

.keyFacts{
  display:grid;gap:8px;
  border-top:1px solid var(--line);
  padding-top:10px
}
.kvLine{
  display:grid;
  grid-template-columns:120px 1fr;
  gap:10px;align-items:start
}
.k{color:var(--muted);font-size:12px}
.v{font-size:13px;word-break:break-word}

.detailsWrap{border-top:1px solid var(--line);padding-top:10px}
details{border:0}
summary{
  cursor:pointer;color:var(--accent);
  font-size:13px;user-select:none
}
summary::-webkit-details-marker{display:none}
.summaryBtn{display:inline-flex;align-items:center;gap:8px}
.summaryBtn::after{content:"â–¾";font-size:12px;transform:translateY(-1px)}
details[open] .summaryBtn::after{content:"â–´"}

.section{
  border-top:1px solid var(--line);
  padding-top:10px;
  margin-top:10px;
  display:grid;gap:8px
}
.sectionTitle{
  font-size:11px;
  letter-spacing:.08em;
  color:var(--muted);
  text-transform:uppercase;
}

.subdetails summary{color:#374151;font-size:13px}
.subdetails .summaryBtn{color:#374151}
.subdetails .summaryBtn::after{color:#6b7280}
.subdetails .content{ margin-top: 8px; }
.subdetails .contentText{ line-height:1.35; }

a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
.counter{font-size:12px;color:#555}

/* Trophy (wie vorher) */
.trophyList{display:grid;gap:8px}
.trophyRow{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:start}
.platformChip{
  font-size:11px;font-weight:800;
  padding:2px 8px;border-radius:999px;
  background:#f3f4f6;border:1px solid #ececec;color:#374151;
  height:fit-content
}
.trophyRight{display:grid;gap:6px}
.trophyText{font-size:13px;color:#111;line-height:1.2}
.progressWrap{display:grid;gap:4px}
.progressBar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
.progressFill{height:100%;background:var(--accent);width:0%}
.progressLabel{font-size:12px;color:var(--muted)}
</style>
</head>
<body>

<header>
  <div class="row">
    <strong>Spieleliste</strong>
    <span class="hint">Clean Cards Â· Multi-System Â· Trophy Bars Â· ðŸ’Ž Platin</span>
  </div>
  <div class="row">
    <input id="file" type="file" accept=".xlsx,.xls" />
    <select id="sheetSelect" disabled><option>Sheet auswÃ¤hlenâ€¦</option></select>
  </div>
  <div class="row">
    <input id="search" type="search" placeholder="Sucheâ€¦" disabled />
    <button id="moreBtn" disabled>Mehr laden</button>
    <button id="topBtn" disabled>â†‘ Top</button>
  </div>
  <div class="row">
    <span id="status" class="hint">Datei wÃ¤hlen â†’ Sheet wÃ¤hlen â†’ suchen</span>
    <span id="count" class="counter"></span>
  </div>
</header>

<main><div id="grid" class="grid"></div></main>

<script src="xlsx.full.min.js"></script>
<script>
const PAGE_SIZE = 60;
const PLACEHOLDER = "â€”";
const SHOW_EMPTY_IN_KEYFACTS = true;
const SHOW_EMPTY_IN_DETAILS  = true;

const COL_ALIASES = {
  id: ["ID"],
  title: ["Spieletitel","Spiel","Titel","Name"],
  fav: ["Favorit","Favorite"],
  system: ["System","Plattform","Platform"],
  availability: ["VerfÃ¼gbarkeit","Verfuegbarkeit","Availability"],
  store: ["Store Link","Store-Link","StoreLink","Store"],
  source: ["Quelle","Source"],
  genre: ["Genre"],
  subgenre: ["Subgenre","Subgenre / Stimmung","Subgenre/Stimmung"],
  dev: ["Entwickler","Developer","Studio"],
  desc: ["Kurzbeschreibung","Beschreibung","Description"],
  easter: ["Eastereggs","Easter Eggs"],
  special: ["Besonderheiten","Highlights"],
  main: ["Spielzeit (Main)","Spielzeit Main","Main Story (Std.)","Main Story"],
  hundred: ["Spielzeit (100%)","Spielzeit 100%","100 % (Std.)","100% (Std.)","100%"],
  meta: ["Metascore","Pressemeinung (Ã˜)"],
  user: ["Userwertung","Userwertung (Ã˜)"],
  trophies: ["TrophÃ¤en Fortschritt","TrophÃ¤en-Fortschritt","TrophÃ¤enfortschritt","Trophies Progress"],
  platinum: ["Platin","Platinum"],
  hours: ["Gesamtstunden (Humorstatistik)","Humorstatistik â€“ Gesamtstunden"],
  life: ["% Lebenszeit (Humorstatistik)","Humorstatistik â€“ % Lebenszeit"],
  years: ["Jahre (Humorstatistik)","Humorstatistik â€“ Jahre"],
};
let COL = {};
const PLATFORM_LIST = ["PS5","PS4","PS3","PS2","PS1","PSVita","Vita","PC","Switch","Xbox","Series","One"];

const els = {
  file: document.getElementById("file"),
  sheet: document.getElementById("sheetSelect"),
  search: document.getElementById("search"),
  more: document.getElementById("moreBtn"),
  top: document.getElementById("topBtn"),
  status: document.getElementById("status"),
  count: document.getElementById("count"),
  grid: document.getElementById("grid"),
};

let workbook = null;
let allRows = [];
let matches = [];
let shown = 0;
let columns = [];
let linkMap = new Map();
let headerRowIndex = 1;

const s = v => (v == null ? "" : String(v).trim());

function normHeader(x){
  return String(x ?? "").replace(/\u00A0/g," ").replace(/\s+/g," ").trim().toLowerCase();
}
function resolveColumns(cols){
  const byNorm = new Map(cols.map(c => [normHeader(c), c]));
  const resolved = {};
  for (const [key, aliases] of Object.entries(COL_ALIASES)) {
    let found = "";
    for (const a of aliases) {
      const hit = byNorm.get(normHeader(a));
      if (hit) { found = hit; break; }
    }
    resolved[key] = found;
  }
  return resolved;
}
function val(row, colName){
  if (!colName) return "";
  const v = row[colName];
  return v == null ? "" : String(v).trim();
}

/* Plattformen */
function extractPlatformsFromText(text){
  const t = String(text ?? "");
  const found = [];
  const re = /\b(PS5|PS4|PS3|PS2|PS1|PSVita|Vita|PC|Switch|Xbox|Series|One)\b/g;
  let m;
  while ((m = re.exec(t)) !== null) found.push(m[1]);
  return [...new Set(found)];
}
function platformsFromSystem(row){
  return extractPlatformsFromText(val(row, COL.system));
}

/* Links / Delisted */
function buildLinks(ws){
  linkMap.clear();
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  headerRowIndex = headerR + 1;

  const headerByCol = new Map();
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    headerByCol.set(c, cell && cell.v != null ? String(cell.v).trim() : "");
  }

  for (let rr = headerR + 1; rr <= r.e.r; rr++){
    const row1 = rr + 1;
    for (let c = r.s.c; c <= r.e.c; c++){
      const cell = ws[XLSX.utils.encode_cell({ r: rr, c })];
      if (cell && cell.l && cell.l.Target){
        const colName = headerByCol.get(c);
        if (colName) linkMap.set(`${row1}:${colName}`, String(cell.l.Target));
      }
    }
  }
}
function applyDelistedFromStyles(ws){
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const titleCol = COL.title;
  if (!titleCol) return;

  const headerR = r.s.r;
  let titleC = null;
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    const h = cell && cell.v != null ? String(cell.v).trim() : "";
    if (h === titleCol) { titleC = c; break; }
  }
  if (titleC == null) return;

  for (let i = 0; i < allRows.length; i++){
    const rr = headerR + 1 + i;
    const cell = ws[XLSX.utils.encode_cell({ r: rr, c: titleC })];
    const strike = !!(cell && cell.s && cell.s.font && (cell.s.font.strike || cell.s.font.strikethrough));
    if (strike) allRows[i].__delisted = true;
  }
}
function isDelistedRow(row){
  if (row.__delisted) return true;
  const v = val(row, COL.availability).toLowerCase();
  return v === "delisted" || v === "removed" || v.includes("store entfernt");
}
function getValueWithLink(row, colName, rowIndex1Based){
  const text = val(row, colName);
  const href = linkMap.get(`${rowIndex1Based}:${colName}`);
  if (href) return { text: text || "Store Link", href };
  return text;
}

/* UI helpers */
function renderValue(value){
  if (value && typeof value === "object" && value.href) {
    const a = document.createElement("a");
    a.href = value.href;
    a.textContent = value.text || "Link";
    a.title = value.href;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    return a;
  }
  const t = s(value);
  return document.createTextNode(t || PLACEHOLDER);
}
function kvLine(label, valueNode){
  const line = document.createElement("div");
  line.className = "kvLine";
  const k = document.createElement("div");
  k.className = "k";
  k.textContent = label;
  const v = document.createElement("div");
  v.className = "v";
  v.appendChild(valueNode);
  line.append(k, v);
  return line;
}
function makeChip(text){
  const c = document.createElement("span");
  c.className = "chip";
  c.textContent = text;
  return c;
}
function makeIdBadge(idText){
  const b = document.createElement("span");
  b.className = "idBadge";
  b.textContent = `ID ${idText || PLACEHOLDER}`;
  return b;
}
function makeBadge(text, cls=""){
  const b = document.createElement("span");
  b.className = "badge" + (cls ? " " + cls : "");
  b.textContent = text;
  return b;
}
function formatFavorite(row){
  const f = val(row, COL.fav).toLowerCase();
  if (!f) return "";
  return (f === "x" || f === "1" || f === "true" || f === "yes" || f === "y" || f.includes("â­")) ? "â­ Favorit" : "";
}
function isPlatinum(row){
  const p = val(row, COL.platinum).toLowerCase();
  if (!p) return false;
  return p.includes("platinum") || p === "x" || p === "ja" || p === "yes" || p === "true";
}
function formatPlaytime(row){
  const m = val(row, COL.main);
  const h = val(row, COL.hundred);
  if (!m && !h) return "";
  if (m && h) return `${m}h / ${h}h`;
  return m ? `${m}h` : `${h}h`;
}

/* Toggle-Block wie Beschreibung (wiederverwendbar) */
function makeToggleBlock(label, contentText){
  const d = document.createElement("details");
  d.className = "subdetails";

  const ssum = document.createElement("summary");
  const sbtn = document.createElement("span");
  sbtn.className = "summaryBtn";
  sbtn.textContent = `${label} anzeigen`;
  ssum.appendChild(sbtn);
  d.appendChild(ssum);

  const wrap = document.createElement("div");
  wrap.className = "content";
  const txt = document.createElement("div");
  txt.className = "v contentText";
  txt.textContent = contentText || PLACEHOLDER;
  wrap.appendChild(txt);
  d.appendChild(wrap);

  d.addEventListener("toggle", () => {
    sbtn.textContent = d.open ? `${label} ausblenden` : `${label} anzeigen`;
  });

  return d;
}

/* Trophy */
function parsePlatformPairs(text){
  const t = String(text ?? "").trim();
  if (!t) return [];
  const hits = [];
  for (const p of PLATFORM_LIST) {
    const re = new RegExp(`\\b${p}\\b`, "g");
    let m;
    while ((m = re.exec(t)) !== null) hits.push({ p, i: m.index });
  }
  hits.sort((a,b)=>a.i-b.i);
  if (!hits.length) return [];

  const out = [];
  for (let j=0;j<hits.length;j++){
    const start = hits[j].i;
    const end = (j+1<hits.length) ? hits[j+1].i : t.length;
    const p = hits[j].p;
    let seg = t.slice(start, end).trim();
    seg = seg.replace(new RegExp(`^${p}\\s*`), "").trim();
    out.push({ platform: p, text: seg || PLACEHOLDER });
  }
  return out;
}
function parseFraction(text){
  const s = String(text ?? "");
  let m = s.match(/(\d+)\s*(?:of|von|\/)\s*(\d+)/i);
  if (!m) return null;
  const a = parseInt(m[1], 10);
  const b = parseInt(m[2], 10);
  if (!b) return null;
  const pct = Math.max(0, Math.min(1, a / b));
  return { a, b, pct };
}
function progressNode(fr){
  const wrap = document.createElement("div");
  wrap.className = "progressWrap";
  const bar = document.createElement("div");
  bar.className = "progressBar";
  const fill = document.createElement("div");
  fill.className = "progressFill";
  fill.style.width = `${Math.round(fr.pct * 100)}%`;
  bar.appendChild(fill);
  const lab = document.createElement("div");
  lab.className = "progressLabel";
  lab.textContent = `${Math.round(fr.pct * 100)}% (${fr.a}/${fr.b})`;
  wrap.append(bar, lab);
  return wrap;
}
function trophyList(items){
  const wrap = document.createElement("div");
  wrap.className = "trophyList";
  for (const it of items) {
    const rowEl = document.createElement("div");
    rowEl.className = "trophyRow";

    const chip = document.createElement("span");
    chip.className = "platformChip";
    chip.textContent = it.platform || "â€”";

    const right = document.createElement("div");
    right.className = "trophyRight";

    const txt = document.createElement("div");
    txt.className = "trophyText";
    txt.textContent = it.text || PLACEHOLDER;
    right.appendChild(txt);

    const fr = parseFraction(it.text);
    if (fr) right.appendChild(progressNode(fr));

    rowEl.append(chip, right);
    wrap.appendChild(rowEl);
  }
  return wrap;
}
function trophyNeutral(text, sysPlatforms){
  const outer = document.createElement("div");
  outer.style.display = "grid";
  outer.style.gap = "8px";

  if (sysPlatforms && sysPlatforms.length) {
    const chipRow = document.createElement("div");
    chipRow.style.display = "flex";
    chipRow.style.gap = "6px";
    chipRow.style.flexWrap = "wrap";
    for (const p of sysPlatforms) chipRow.appendChild(makeChip(p));
    outer.appendChild(chipRow);
  }

  const txt = document.createElement("div");
  txt.className = "trophyText";
  txt.textContent = text || PLACEHOLDER;
  outer.appendChild(txt);

  const fr = parseFraction(text);
  if (fr) outer.appendChild(progressNode(fr));

  return outer;
}
function trophyNodeFromText(text, row){
  const raw = String(text ?? "").trim();
  if (!raw) return document.createTextNode(PLACEHOLDER);

  const pairs = parsePlatformPairs(raw);
  if (pairs.length) return trophyList(pairs);

  const sysPlatforms = platformsFromSystem(row);
  if (sysPlatforms.length === 1) return trophyList([{ platform: sysPlatforms[0], text: raw }]);
  if (sysPlatforms.length > 1) return trophyNeutral(raw, sysPlatforms);
  return trophyNeutral(raw, []);
}

/* Card */
function createCard(row, rowIndex1Based){
  const card = document.createElement("div");
  card.className = "card";

  const top = document.createElement("div");
  top.className = "cardTop";

  const titleRow = document.createElement("div");
  titleRow.className = "titleRow";

  const title = document.createElement("div");
  title.className = "title";
  title.textContent = val(row, COL.title) || "(ohne Titel)";
  if (isDelistedRow(row)) title.classList.add("delisted");

  const badges = document.createElement("div");
  badges.className = "badges";
  if (isDelistedRow(row)) badges.appendChild(makeBadge("Delisted", "delisted"));
  const favLabel = formatFavorite(row);
  if (favLabel) badges.appendChild(makeBadge(favLabel));
  if (isPlatinum(row)) badges.appendChild(makeBadge("ðŸ’Ž Platin", "platin"));

  titleRow.append(title, badges);

  const metaRow = document.createElement("div");
  metaRow.className = "metaRow";

  // ID stÃ¤rker
  metaRow.appendChild(makeIdBadge(val(row, COL.id)));

  // Plattform-Chips
  let plats = platformsFromSystem(row);
  if (!plats.length) {
    const fromT = extractPlatformsFromText(val(row, COL.trophies));
    const fromP = extractPlatformsFromText(val(row, COL.platinum));
    plats = [...new Set([...fromT, ...fromP])];
  }
  if (plats.length) plats.forEach(p => metaRow.appendChild(makeChip(p)));
  else metaRow.appendChild(makeChip(PLACEHOLDER));

  metaRow.appendChild(makeChip(val(row, COL.availability) || PLACEHOLDER));

  top.append(titleRow, metaRow);

  const key = document.createElement("div");
  key.className = "keyFacts";

  const genre = val(row, COL.genre);
  const subg  = val(row, COL.subgenre);
  const pt    = formatPlaytime(row);
  const metaScore = val(row, COL.meta);
  const userScore = val(row, COL.user);

  if (genre || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Genre", renderValue(genre)));
  if (subg  || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Subgenre / Stimmung", renderValue(subg)));
  if (pt    || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Spielzeit", renderValue(pt)));
  if (metaScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Metascore", renderValue(metaScore)));
  if (userScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Userwertung", renderValue(userScore)));

  const detailsWrap = document.createElement("div");
  detailsWrap.className = "detailsWrap";

  const details = document.createElement("details");
  const summary = document.createElement("summary");
  const sumSpan = document.createElement("span");
  sumSpan.className = "summaryBtn";
  sumSpan.textContent = "Mehr Details";
  summary.appendChild(sumSpan);
  details.appendChild(summary);

  // ZustandsabhÃ¤ngiger Text
  details.addEventListener("toggle", () => {
    sumSpan.textContent = details.open ? "Weniger Details" : "Mehr Details";
  });

  function addSection(titleText, lines){
    if (!lines.some(x => x != null)) return;
    const sec = document.createElement("div");
    sec.className = "section";
    const st = document.createElement("div");
    st.className = "sectionTitle";
    st.textContent = titleText;
    sec.appendChild(st);
    for (const line of lines) if (line) sec.appendChild(line);
    details.appendChild(sec);
  }

  // Beschreibung toggle
  addSection("Beschreibung", [
    makeToggleBlock("Kurzbeschreibung", val(row, COL.desc))
  ]);

  // Store
  const storeVal = getValueWithLink(row, COL.store, rowIndex1Based);
  const source = val(row, COL.source);
  const availability = val(row, COL.availability);
  addSection("Store", [
    (storeVal || SHOW_EMPTY_IN_DETAILS) ? kvLine("Store", renderValue(storeVal)) : null,
    (source   || SHOW_EMPTY_IN_DETAILS) ? kvLine("Quelle", renderValue(source)) : null,
    (availability || SHOW_EMPTY_IN_DETAILS) ? kvLine("VerfÃ¼gbarkeit", renderValue(availability)) : null,
  ]);

  // Entwickler
  const dev = val(row, COL.dev);
  addSection("Entwickler", [
    (dev || SHOW_EMPTY_IN_DETAILS) ? kvLine("Entwickler", renderValue(dev)) : null
  ]);

  // Extras: jetzt ausklappbar
  addSection("Extras", [
    makeToggleBlock("Besonderheiten", val(row, COL.special)),
    makeToggleBlock("Eastereggs", val(row, COL.easter))
  ]);

  // TrophÃ¤en
  const trophies = val(row, COL.trophies);
  const platinum = val(row, COL.platinum);
  addSection("TrophÃ¤en", [
    kvLine("Fortschritt", trophyNodeFromText(trophies, row)),
    kvLine("Platin", trophyNodeFromText(platinum, row)),
  ]);

  // Humorstatistik
  const hours = val(row, COL.hours);
  const life  = val(row, COL.life);
  const years = val(row, COL.years);
  addSection("Humorstatistik", [
    (hours || SHOW_EMPTY_IN_DETAILS) ? kvLine("Gesamtstunden", renderValue(hours)) : null,
    (life  || SHOW_EMPTY_IN_DETAILS) ? kvLine("% Lebenszeit", renderValue(life)) : null,
    (years || SHOW_EMPTY_IN_DETAILS) ? kvLine("Jahre", renderValue(years)) : null,
  ]);

  detailsWrap.appendChild(details);
  card.append(top, key, detailsWrap);
  return card;
}

/* Paging / Search */
function updateCounters(){
  const total = matches.length;
  els.count.textContent = total ? `Treffer: ${total} Â· angezeigt: ${shown}/${total}` : "";
  els.more.disabled = shown >= total;
  els.more.textContent = els.more.disabled ? "Mehr laden" : `Mehr laden (+${Math.min(PAGE_SIZE, total - shown)})`;
  // Top-Button: sobald etwas angezeigt wird, aktivieren
  els.top.disabled = shown === 0;
}

function renderMore(){
  const total = matches.length;
  if (shown >= total) return;

  const end = Math.min(shown + PAGE_SIZE, total);
  const frag = document.createDocumentFragment();

  for (let i = shown; i < end; i++){
    const { row, idx } = matches[i];
    frag.appendChild(createCard(row, idx));
  }

  els.grid.appendChild(frag);
  shown = end;

  els.status.textContent = total
    ? (shown < total ? "Mehr laden zeigt weitere Kartenâ€¦" : "Alle Karten angezeigt.")
    : "Keine Treffer.";

  updateCounters();
}

function startSearch(q){
  els.grid.innerHTML = "";
  shown = 0;

  const term = (q || "").toLowerCase().trim();

  matches = allRows
    .map((row, i) => ({ row, idx: headerRowIndex + 1 + i }))
    .filter(o => {
      if (!term) return true;
      const fast =
        val(o.row, COL.id) + " " +
        val(o.row, COL.title) + " " +
        val(o.row, COL.dev) + " " +
        val(o.row, COL.genre) + " " +
        val(o.row, COL.subgenre);
      if (fast.toLowerCase().includes(term)) return true;
      return Object.values(o.row).some(v => s(v).toLowerCase().includes(term));
    });

  renderMore();
}

/* Events */
els.top.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));
els.more.addEventListener("click", () => renderMore());

els.file.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  els.status.textContent = "Lese Dateiâ€¦";

  if (typeof XLSX === "undefined") {
    els.status.textContent = "Fehler: XLSX Library nicht geladen (xlsx.full.min.js fehlt?)";
    return;
  }

  const buf = await f.arrayBuffer();
  workbook = XLSX.read(buf, { type: "array", cellStyles: true });

  els.sheet.innerHTML = "<option>Sheet auswÃ¤hlenâ€¦</option>";
  workbook.SheetNames.forEach(n => {
    const o = document.createElement("option");
    o.value = n; o.textContent = n;
    els.sheet.appendChild(o);
  });

  els.sheet.disabled = false;
  els.search.disabled = true;
  els.more.disabled = true;
  els.top.disabled = true;
  els.grid.innerHTML = "";
  els.count.textContent = "";
  els.status.textContent = "Sheet wÃ¤hlenâ€¦";
});

els.sheet.addEventListener("change", () => {
  const name = els.sheet.value;
  if (!name || name === "Sheet auswÃ¤hlenâ€¦") return;

  const ws = workbook.Sheets[name];

  const json = XLSX.utils.sheet_to_json(ws, { defval: "" });
  allRows = json;
  columns = json.length ? Object.keys(json[0]) : [];

  COL = resolveColumns(columns);

  buildLinks(ws);
  applyDelistedFromStyles(ws);

  els.search.disabled = false;
  els.status.textContent = `Geladen: ${allRows.length} Zeilen`;
  startSearch(els.search.value || "");
});

els.search.addEventListener("input", (e) => startSearch(e.target.value));
</script>
</body>
</html>