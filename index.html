<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Spieleliste</title>

  <!-- SheetJS lokal: xlsx.full.min.js liegt im gleichen Ordner -->
  <script src="./xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --chip:#f3f4f6;
      --chipText:#374151;
      --shadow:0 10px 25px rgba(17,24,39,.08);
      --radius:18px;
      --radius2:14px;
      --pad:14px;
      --accent:#1f4cff;

      --goodBg:#e8f7ee; --goodText:#166534; --goodLine:#bfe8cc;
      --blueBg:#eaf2ff; --blueText:#1d4ed8; --blueLine:#bfd6ff;
      --warnBg:#ffecec; --warnText:#991b1b; --warnLine:#fecaca;
      --sleepBg:#f3f4f6; --sleepText:#4b5563; --sleepLine:#e5e7eb;
      --delBg:#ffecec; --delText:#991b1b;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;padding:16px 14px 80px}
    h1{margin:8px 2px 10px;font-size:28px;letter-spacing:-.02em}
    .muted{color:var(--muted)}
    .topbar{
      position:sticky; top:0; z-index:20;
      background:linear-gradient(to bottom, rgba(246,247,251,.96), rgba(246,247,251,.86));
      backdrop-filter:saturate(150%) blur(10px);
      border-bottom:1px solid rgba(229,231,235,.7);
      padding:10px 0 12px;
    }
    .panel{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:12px;
    }
    .row{display:flex;gap:10px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    .grow{flex:1}
    .btn, select, input{
      width:100%;
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px 12px;
      font-size:16px;
      background:#fff;
      outline:none;
    }
    input:focus, select:focus{border-color:#c7d2fe; box-shadow:0 0 0 4px rgba(99,102,241,.12)}
    .btn{
      cursor:pointer;
      background:#fff;
      font-weight:600;
    }
    .btn:active{transform:translateY(1px)}
    .btnIcon{
      width:54px; min-width:54px;
      display:flex;align-items:center;justify-content:center;
      font-size:20px;
      background:#eef2ff;
      border-color:#dbeafe;
    }
    .stats{
      display:flex;gap:14px;flex-wrap:wrap;
      padding:8px 2px 0;
      font-size:14px;
      color:var(--muted);
    }

    /* Mini/Full Menu */
    .menuFull{display:block}
    .menuMini{
      display:none;
      padding:10px 12px;
    }
    .miniRow{display:flex;gap:10px;align-items:center}
    .miniRow input{padding:11px 12px}
    .miniStats{display:flex;gap:12px;flex-wrap:wrap;font-size:13px;color:var(--muted);padding-top:8px}
    .hidden{display:none !important;}

    /* Filter chips */
    .chips{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .chip{
      user-select:none;
      border:1px solid var(--line);
      background:var(--chip);
      color:var(--chipText);
      padding:8px 10px;
      border-radius:999px;
      font-size:14px;
      cursor:pointer;
      display:inline-flex;align-items:center;gap:8px;
    }
    .chip[data-on="1"]{
      background:#eef2ff;
      border-color:#c7d2fe;
      color:#1d4ed8;
      font-weight:600;
    }
    .chipSmall{padding:7px 10px;font-size:13px}
    .chipClear{background:#fff}

    /* Cards */
    .list{display:flex;flex-direction:column;gap:14px;margin-top:14px}
    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:22px;
      box-shadow:var(--shadow);
      padding:14px 14px 10px;
    }
    .card.delisted{
      border-color:#fecaca;
      background:linear-gradient(to bottom, #fff, #fff7f7);
    }
    .cardHead{display:flex;gap:10px;align-items:flex-start;justify-content:space-between}
    .title{
      margin:0;
      font-size:20px;
      line-height:1.1;
      letter-spacing:-.01em;
    }
    .badgeStack{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      min-width:130px;
    }
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:7px 10px;
      border-radius:999px;
      font-size:14px;
      font-weight:700;
      border:1px solid var(--line);
      background:#fff;
      white-space:nowrap;
    }
    .pill.good{background:var(--goodBg);color:var(--goodText);border-color:var(--goodLine)}
    .pill.blue{background:var(--blueBg);color:var(--blueText);border-color:var(--blueLine)}
    .pill.warn{background:var(--warnBg);color:var(--warnText);border-color:var(--warnLine)}
    .pill.sleep{background:var(--sleepBg);color:var(--sleepText);border-color:var(--sleepLine)}
    .metaRow{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
      margin-top:10px;padding-top:10px;border-top:1px solid var(--line);
    }
    .idPill{
      background:#102a83;
      color:#fff;
      border:none;
      font-weight:800;
      letter-spacing:.02em;
      padding:8px 12px;
    }
    .sysPill,.availPill{
      background:#f3f4f6;border-color:#e5e7eb;color:#111827;font-weight:700;
    }
    .kv{display:grid;grid-template-columns: 160px 1fr;gap:8px 14px;margin-top:12px}
    .k{color:var(--muted);font-size:14px}
    .v{font-size:15px}
    .v strong{font-weight:800}
    .hr{height:1px;background:var(--line);margin:10px 0}

    /* Details toggle */
    details{
      border-top:1px solid var(--line);
      margin-top:10px;
      padding-top:10px;
    }
    summary{
      cursor:pointer;
      user-select:none;
      list-style:none;
      display:flex;align-items:center;gap:8px;
      color:#1f2a6a;
      font-weight:800;
      padding:8px 0;
    }
    summary::-webkit-details-marker{display:none}
    .sectionTitle{
      font-size:12px;
      letter-spacing:.12em;
      color:var(--muted);
      margin:12px 0 6px;
      text-transform:uppercase;
    }
    .subdetails{
      border-top:1px solid var(--line);
      padding-top:10px;
      margin-top:10px;
    }
    .subdetails summary{
      color:#111827;
      font-weight:800;
      padding:6px 0;
    }
    .longText{
      white-space:pre-wrap;
      line-height:1.35;
      margin-top:8px;
    }
    .longText.gapTop{margin-top:10px}

    /* Store link */
    a.store{
      color:#1d4ed8;
      text-decoration:none;
      font-weight:800;
    }
    a.store:hover{text-decoration:underline}

    /* Trophy blocks */
    .trophyGrid{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:6px;
    }
    .tRow{
      display:grid;
      grid-template-columns: 50px 1fr;
      gap:10px;
      align-items:center;
    }
    .tSys{
      display:inline-flex;align-items:center;justify-content:center;
      font-weight:900;
      border:1px solid var(--line);
      background:#f3f4f6;
      border-radius:999px;
      padding:6px 10px;
      font-size:13px;
      width:max-content;
    }
    .barWrap{
      display:flex;flex-direction:column;gap:6px;
    }
    .barLine{
      display:flex;justify-content:space-between;align-items:baseline;
      gap:10px;
      font-size:14px;
    }
    .bar{
      height:10px;border-radius:999px;
      background:#e5e7eb;
      overflow:hidden;
      border:1px solid #e5e7eb;
    }
    .bar > div{
      height:100%;
      width:0%;
      background:#1d4ed8;
    }
    .barNote{font-size:12px;color:var(--muted)}
    .tPills{display:flex;gap:8px;flex-wrap:wrap;margin-top:2px}

    /* Floating Top button */
    .fabTop{
      position:fixed;
      right:14px;
      bottom:18px;
      z-index:30;
      border:none;
      border-radius:999px;
      padding:12px 14px;
      box-shadow:0 14px 30px rgba(17,24,39,.18);
      background:#ffffff;
      border:1px solid var(--line);
      font-weight:900;
      cursor:pointer;
      display:none;
    }
    .fabTop.show{display:block}

    /* Sentinel */
    #sentinel{height:1px}

    /* Small helper */
    .help{
      background:#fff;
      border:1px dashed #d1d5db;
      border-radius:16px;
      padding:10px 12px;
      margin-top:10px;
      color:#374151;
      font-size:14px;
    }

    @media (max-width:520px){
      .kv{grid-template-columns: 140px 1fr;}
      .badgeStack{min-width:120px}
      .btnIcon{min-width:52px;width:52px}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <h1>Spieleliste</h1>

      <!-- FULL MENU -->
      <div id="menuFull" class="panel menuFull">
        <div class="row">
          <input id="file" class="grow" type="file" accept=".xlsx,.xls,.csv" />
          <select id="sheet" class="grow" disabled>
            <option value="">Sheet wÃ¤hlenâ€¦</option>
          </select>
        </div>

        <div class="row" style="margin-top:10px">
          <input id="q" class="grow" placeholder="Sucheâ€¦ (z.B. id:643 dev:naughty system:ps4 plus platin 100 delisted)" />
          <select id="sort" class="grow" disabled>
            <option value="id">Sort: ID</option>
            <option value="title">Sort: Spieletitel</option>
            <option value="system">Sort: System</option>
            <option value="quelle">Sort: Quelle</option>
            <option value="genre">Sort: Genre</option>
            <option value="dev">Sort: Entwickler</option>
            <option value="main">Sort: Spielzeit (Main)</option>
            <option value="meta">Sort: Metascore</option>
            <option value="user">Sort: Userwertung</option>
            <option value="life">% Lebenszeit</option>
          </select>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="sortDir" class="btn" disabled>Aufsteigend</button>
          <button id="toggleMini" class="btn btnIcon" title="MenÃ¼ minimieren">â–¾</button>
        </div>

        <div class="help">
          <details>
            <summary>Suche &amp; Filter kurz erklÃ¤rt</summary>
            <div style="margin-top:8px;line-height:1.35">
              Du kannst frei tippen (Volltext Ã¼ber alle Spalten) oder Tokens nutzen:
              <div style="margin-top:8px">
                <span style="font-family:var(--mono)">id:12</span>,
                <span style="font-family:var(--mono)">title:uncharted</span>,
                <span style="font-family:var(--mono)">dev:capcom</span>,
                <span style="font-family:var(--mono)">genre:adventure</span>,
                <span style="font-family:var(--mono)">system:ps5</span>,
                <span style="font-family:var(--mono)">quelle:plus</span>,
                <span style="font-family:var(--mono)">delisted</span>,
                <span style="font-family:var(--mono)">fav</span>,
                <span style="font-family:var(--mono)">platin</span>,
                <span style="font-family:var(--mono)">100</span>,
                <span style="font-family:var(--mono)">ungespielt</span>,
                <span style="font-family:var(--mono)">inarbeit</span>
              </div>
              <div style="margin-top:8px;color:var(--muted)">Tipp: mehrere Tokens kombinieren, z.B. <span style="font-family:var(--mono)">system:ps4 plus inarbeit</span></div>
            </div>
          </details>
        </div>

        <div class="chips" id="chips"></div>

        <div class="stats" id="stats">
          <span class="muted">Datei wÃ¤hlen â†’ Sheet wÃ¤hlen â†’ suchen</span>
        </div>
      </div>

      <!-- MINI MENU -->
      <div id="menuMini" class="panel menuMini">
        <div class="miniRow">
          <input id="qMini" class="grow" placeholder="Sucheâ€¦" />
          <button id="openFull" class="btn btnIcon" title="MenÃ¼ Ã¶ffnen">â‰¡</button>
        </div>
        <div class="miniStats" id="miniStats"></div>
      </div>
    </div>

    <div class="list" id="list"></div>
    <div id="sentinel"></div>

    <button id="fabTop" class="fabTop" title="Nach oben">â†‘ Top</button>
  </div>

<script>
(() => {
  // -------------------------
  // Utilities
  // -------------------------
  const $ = (id) => document.getElementById(id);
  const norm = (v) => (v === null || v === undefined) ? "" : String(v).replace(/\u00A0/g," ").trim();
  const lower = (v) => norm(v).toLowerCase();
  const has = (v) => norm(v).length > 0;
  const toNum = (v) => {
    const s = norm(v).replace(",", ".").replace(/[^0-9.\-]/g,"");
    if(!s) return NaN;
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  };
  const deCompare = (a,b) => {
    const A = norm(a), B = norm(b);
    return A.localeCompare(B, "de", { sensitivity:"base", numeric:true });
  };

  const SYSTEMS = ["PS5","PS4","PS3","Vita"];
  const SOURCE_KEYS = ["PS Plus","Digital","Disc"];

  function parseSystems(systemCell){
    const s = norm(systemCell);
    if(!s) return [];
    // Excel: "PS3, PS4, Vita" oder "PS4, PS5"
    return s.split(",").map(x => x.trim()).filter(Boolean);
  }
  function inferSingleSystem(systemCell){
    const arr = parseSystems(systemCell);
    if(arr.length === 1) return arr[0];
    return null;
  }

  function normalizeQuelle(q){
    const s = norm(q);
    if(!s) return "";
    // Du willst "gekauft" als Digital labeln
    if(s.toLowerCase() === "gekauft") return "Digital";
    if(s.toLowerCase().includes("ps plus")) return "PS Plus";
    if(s.toLowerCase().includes("disc")) return "Disc";
    return s; // falls spÃ¤ter noch mehr kommt
  }

  // Parse multi-platform blocks like:
  // "PS4\n15 of 15\n\nPS5\n---"
  // or singleplatform: "15 of 27"
  // or empty
  function parsePlatformBlock(text, systemCell){
    const raw = norm(text);
    const singleSys = inferSingleSystem(systemCell);

    const result = {}; // platform -> value string
    if(!raw){
      if(singleSys) result[singleSys] = "";
      return result;
    }

    // If it contains explicit platform headings
    const hasHeading = SYSTEMS.some(sys => new RegExp(`\\b${sys}\\b`, "i").test(raw));
    if(hasHeading){
      // split into chunks by blank lines, but keep pairing "PS4" + next lines
      // normalize line breaks
      const lines = raw.replace(/\r/g,"").split("\n").map(l => l.trim());
      let cur = null;
      let buf = [];
      const flush = () => {
        if(cur){
          result[cur] = buf.filter(Boolean).join("\n").trim();
        }
        cur = null; buf = [];
      };
      for(const line of lines){
        if(!line){ continue; }
        const sys = SYSTEMS.find(s => s.toLowerCase() === line.toLowerCase());
        if(sys){
          flush();
          cur = sys;
        } else {
          if(!cur && singleSys){
            // fallback: treat as singleplatform content
            result[singleSys] = lines.filter(Boolean).join("\n").trim();
            return result;
          }
          buf.push(line);
        }
      }
      flush();
      return result;
    }

    // singleplatform value without platform label
    if(singleSys){
      result[singleSys] = raw;
    } else {
      // ambiguous: store under "ALL"
      result["ALL"] = raw;
    }
    return result;
  }

  function parseProgressValue(v){
    // "15 of 27" -> {done:15,total:27,pct:55.5}
    const s = norm(v);
    if(!s || s === "---") return null;
    const m = s.match(/(\d+)\s*of\s*(\d+)/i);
    if(!m) return null;
    const done = parseInt(m[1],10);
    const total = parseInt(m[2],10);
    if(!Number.isFinite(done) || !Number.isFinite(total) || total<=0) return null;
    const pct = Math.max(0, Math.min(100, (done/total)*100));
    return { done, total, pct };
  }

  function isDelisted(row){
    return lower(row["VerfÃ¼gbarkeit"]).includes("delisted") || lower(row["VerfÃ¼gbarkeit"]).includes("entfernt");
  }

  function getStoreHref(row){
    // SheetJS may store hyperlink in a separate structure, we attach it during XLSX parsing.
    // We store it as row.__storeHref
    return row.__storeHref || "";
  }

  function computeTrophyState(row){
    // Returns per platform:
    // { platform, progress: {done,total,pct}|null, completion: "unplayed|inarbeit|done", platinum:"unplayed|inarbeit|done" }
    const systems = parseSystems(row["System"]);
    const singleSys = inferSingleSystem(row["System"]);

    const progMap = parsePlatformBlock(row["TrophÃ¤en Fortschritt"], row["System"]);
    const compMap = parsePlatformBlock(row["100%"], row["System"]);
    const platMap = parsePlatformBlock(row["Platin"], row["System"]);

    // Ensure at least those systems appear (for consistent UI)
    const platforms = new Set();
    systems.forEach(s => platforms.add(s));
    Object.keys(progMap).forEach(k => platforms.add(k));
    Object.keys(compMap).forEach(k => platforms.add(k));
    Object.keys(platMap).forEach(k => platforms.add(k));
    if(platforms.size === 0 && singleSys) platforms.add(singleSys);
    if(platforms.size === 0) platforms.add("ALL");

    const out = [];
    for(const p of platforms){
      const progRaw = (progMap[p] ?? "").trim();
      const compRaw = (compMap[p] ?? "").trim();
      const platRaw = (platMap[p] ?? "").trim();

      const progress = parseProgressValue(progRaw);

      // completion "done" if:
      // - 100% cell says "Completed" OR
      // - progress is x of x
      const compDone = /completed/i.test(compRaw) || (progress && progress.done === progress.total);

      // platinum "done" if:
      // - platin cell says "Platinum"
      const platDone = /platinum/i.test(platRaw);

      const hasAny = !!progress || compDone || platDone || /---/.test(progRaw) || /---/.test(compRaw) || /---/.test(platRaw);

      // unplayed vs inarbeit:
      // If no progress and not done/platinum => unplayed
      // If progress exists but not done => inarbeit
      const completion = compDone ? "done" : (progress ? "inarbeit" : "unplayed");
      const platinum = platDone ? "done" : (progress ? "inarbeit" : "unplayed");

      out.push({ platform:p, progress, completion, platinum, hasAny });
    }

    // Sort platforms by known order
    out.sort((a,b) => {
      const ai = SYSTEMS.indexOf(a.platform);
      const bi = SYSTEMS.indexOf(b.platform);
      if(ai === -1 && bi === -1) return deCompare(a.platform,b.platform);
      if(ai === -1) return 1;
      if(bi === -1) return -1;
      return ai - bi;
    });

    // Global flags for badges/filters:
    const anyProgress = out.some(x => x.progress && x.progress.done > 0);
    const anyDone100 = out.some(x => x.completion === "done");
    const anyPlatin = out.some(x => x.platinum === "done");
    const allUnplayed = out.every(x => x.completion === "unplayed" && x.platinum === "unplayed" && !x.progress);

    return { perPlatform: out, anyProgress, anyDone100, anyPlatin, allUnplayed };
  }

  // -------------------------
  // State
  // -------------------------
  const LS_KEY = "spieleliste_ui_state_v3";
  const state = {
    rows: [],
    filtered: [],
    rendered: 0,
    batch: 40,
    sortKey: "id",
    sortDir: "asc",
    sheetName: "",
    fileName: "",
    q: "",
    chips: {
      fav:false,
      platin:false,
      done100:false,
      delisted:false,
      ps5:false,
      ps4:false,
      ps3:false,
      vita:false,
      plus:false,
      digital:false,
      disc:false,
      unplayed:false,
      inarbeit:false
    },
    menuMini:false
  };

  function saveState(){
    const payload = {
      sortKey: state.sortKey,
      sortDir: state.sortDir,
      sheetName: state.sheetName,
      q: state.q,
      chips: state.chips,
      menuMini: state.menuMini
    };
    localStorage.setItem(LS_KEY, JSON.stringify(payload));
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const p = JSON.parse(raw);
      if(p.sortKey) state.sortKey = p.sortKey;
      if(p.sortDir) state.sortDir = p.sortDir;
      if(typeof p.sheetName === "string") state.sheetName = p.sheetName;
      if(typeof p.q === "string") state.q = p.q;
      if(p.chips) state.chips = {...state.chips, ...p.chips};
      if(typeof p.menuMini === "boolean") state.menuMini = p.menuMini;
    }catch(e){}
  }

  // -------------------------
  // UI Init
  // -------------------------
  loadState();

  const fileEl = $("file");
  const sheetEl = $("sheet");
  const qEl = $("q");
  const qMiniEl = $("qMini");
  const sortEl = $("sort");
  const sortDirEl = $("sortDir");
  const chipsEl = $("chips");
  const listEl = $("list");
  const statsEl = $("stats");
  const miniStatsEl = $("miniStats");
  const fabTop = $("fabTop");

  const menuFull = $("menuFull");
  const menuMini = $("menuMini");
  const toggleMiniBtn = $("toggleMini");
  const openFullBtn = $("openFull");
  const sentinel = $("sentinel");

  qEl.value = state.q;
  qMiniEl.value = state.q;
  sortEl.value = state.sortKey;
  sortDirEl.textContent = (state.sortDir === "asc") ? "Aufsteigend" : "Absteigend";

  function setMenuMode(mini){
    state.menuMini = mini;
    if(mini){
      menuFull.classList.add("hidden");
      menuMini.style.display = "block";
    } else {
      menuFull.classList.remove("hidden");
      menuMini.style.display = "none";
    }
    saveState();
  }
  setMenuMode(state.menuMini);

  toggleMiniBtn.addEventListener("click", () => setMenuMode(true));
  openFullBtn.addEventListener("click", () => setMenuMode(false));

  // Avoid flicker: we do NOT auto-hide on scroll anymore.
  // You already have the mini mode button â€“ cleaner and stable.

  // -------------------------
  // Chips
  // -------------------------
  const CHIP_DEFS = [
    { key:"fav", label:"â­ Favorit" },
    { key:"platin", label:"ðŸ’Ž Platin" },
    { key:"done100", label:"âœ… 100 %" },
    { key:"inarbeit", label:"â³ In Arbeit" },
    { key:"unplayed", label:"ðŸ’¤ Ungespielt" },
    { key:"delisted", label:"Delisted" },
    { key:"ps5", label:"PS5" },
    { key:"ps4", label:"PS4" },
    { key:"ps3", label:"PS3" },
    { key:"vita", label:"Vita" },
    { key:"plus", label:"PS Plus" },
    { key:"digital", label:"Digital" },
    { key:"disc", label:"Disc" },
  ];

  function renderChips(){
    chipsEl.innerHTML = "";
    for(const c of CHIP_DEFS){
      const btn = document.createElement("button");
      btn.className = "chip";
      btn.type = "button";
      btn.textContent = c.label;
      btn.dataset.on = state.chips[c.key] ? "1" : "0";
      btn.addEventListener("click", () => {
        state.chips[c.key] = !state.chips[c.key];
        saveState();
        renderChips();
        applyAll();
      });
      chipsEl.appendChild(btn);
    }
    const clear = document.createElement("button");
    clear.className = "chip chipSmall chipClear";
    clear.type = "button";
    clear.textContent = "Filter lÃ¶schen";
    clear.addEventListener("click", () => {
      for(const k of Object.keys(state.chips)) state.chips[k] = false;
      saveState();
      renderChips();
      applyAll();
    });
    chipsEl.appendChild(clear);
  }
  renderChips();

  // -------------------------
  // Sorting
  // -------------------------
  function sortRows(rows){
    const dir = state.sortDir === "asc" ? 1 : -1;
    const key = state.sortKey;

    const getVal = (r) => {
      switch(key){
        case "id": return toNum(r["ID"]);
        case "title": return norm(r["Spieletitel"]);
        case "system": return norm(r["System"]);
        case "quelle": return normalizeQuelle(r["Quelle"]);
        case "genre": return norm(r["Genre"]);
        case "dev": return norm(r["Entwickler"]);
        case "main": return toNum(r["Spielzeit (Main)"]);
        case "meta": return toNum(r["Metascore"]);
        case "user": return toNum(r["Userwertung"]);
        case "life": return toNum(r["% Lebenszeit (Humorstatistik)"]);
        default: return norm(r[key] ?? "");
      }
    };

    // stable sort: decorate-sort-undecorate
    return rows
      .map((r,i)=>({r,i,v:getVal(r)}))
      .sort((a,b)=>{
        const av=a.v, bv=b.v;

        // numbers first if both are numbers
        const an = typeof av === "number" && Number.isFinite(av);
        const bn = typeof bv === "number" && Number.isFinite(bv);

        let cmp = 0;
        if(an && bn){
          cmp = av - bv;
        } else {
          // title sorting MUST be stable & locale-correct
          if(key === "title"){
            cmp = deCompare(String(av), String(bv));
          } else {
            cmp = deCompare(String(av), String(bv));
          }
        }
        if(cmp === 0) cmp = a.i - b.i;
        return cmp * dir;
      })
      .map(x=>x.r);
  }

  sortDirEl.addEventListener("click", () => {
    state.sortDir = (state.sortDir === "asc") ? "desc" : "asc";
    sortDirEl.textContent = (state.sortDir === "asc") ? "Aufsteigend" : "Absteigend";
    saveState();
    applyAll();
  });

  sortEl.addEventListener("change", () => {
    state.sortKey = sortEl.value;
    saveState();
    applyAll();
  });

  // -------------------------
  // Query parsing
  // -------------------------
  function parseQuery(q){
    const raw = norm(q);
    if(!raw) return { tokens:[], text:"" };

    const parts = raw.split(/\s+/).filter(Boolean);
    const tokens = [];
    const textParts = [];

    for(const p of parts){
      const m = p.match(/^(\w+):(.*)$/);
      if(m){
        tokens.push({k:m[1].toLowerCase(), v:m[2]});
      } else {
        // flags
        const f = p.toLowerCase();
        if(["delisted","fav","platin","100","ungespielt","inarbeit"].includes(f)){
          tokens.push({k:f, v:"1"});
        } else {
          textParts.push(p);
        }
      }
    }
    return { tokens, text: textParts.join(" ").trim() };
  }

  function matchRow(row, q){
    const {tokens, text} = parseQuery(q);

    // fulltext over all visible columns (cheap but ok for 1200 rows)
    const hay = Object.keys(row)
      .filter(k => !k.startsWith("__"))
      .map(k => norm(row[k]))
      .join(" â€¢ ")
      .toLowerCase();

    if(text){
      const t = text.toLowerCase();
      if(!hay.includes(t)) return false;
    }

    // Token matches
    for(const t of tokens){
      const k = t.k;
      const v = t.v;

      if(k === "id"){
        if(!norm(row["ID"]).includes(v)) return false;
      } else if(k === "title"){
        if(!lower(row["Spieletitel"]).includes(v.toLowerCase())) return false;
      } else if(k === "dev"){
        if(!lower(row["Entwickler"]).includes(v.toLowerCase())) return false;
      } else if(k === "genre"){
        if(!lower(row["Genre"]).includes(v.toLowerCase())) return false;
      } else if(k === "system"){
        if(!lower(row["System"]).includes(v.toLowerCase())) return false;
      } else if(k === "quelle"){
        if(!lower(normalizeQuelle(row["Quelle"])).includes(v.toLowerCase())) return false;
      } else if(k === "delisted"){
        if(!isDelisted(row)) return false;
      } else if(k === "fav"){
        if(lower(row["Favorit"]) !== "x") return false;
      } else if(k === "platin"){
        if(!row.__trophy.anyPlatin) return false;
      } else if(k === "100"){
        if(!row.__trophy.anyDone100) return false;
      } else if(k === "ungespielt"){
        if(!row.__trophy.allUnplayed) return false;
      } else if(k === "inarbeit"){
        if(!(row.__trophy.anyProgress && !row.__trophy.anyDone100)) return false;
      }
    }

    return true;
  }

  // -------------------------
  // Apply filters + sort + render
  // -------------------------
  function applyFilters(rows){
    return rows.filter(r => {
      // chips
      if(state.chips.fav && lower(r["Favorit"]) !== "x") return false;
      if(state.chips.delisted && !isDelisted(r)) return false;

      const sys = lower(r["System"]);
      if(state.chips.ps5 && !sys.includes("ps5")) return false;
      if(state.chips.ps4 && !sys.includes("ps4")) return false;
      if(state.chips.ps3 && !sys.includes("ps3")) return false;
      if(state.chips.vita && !sys.includes("vita")) return false;

      const q = lower(normalizeQuelle(r["Quelle"]));
      if(state.chips.plus && !q.includes("ps plus")) return false;
      if(state.chips.digital && !q.includes("digital")) return false;
      if(state.chips.disc && !q.includes("disc")) return false;

      if(state.chips.platin && !r.__trophy.anyPlatin) return false;
      if(state.chips.done100 && !r.__trophy.anyDone100) return false;

      if(state.chips.unplayed && !r.__trophy.allUnplayed) return false;
      if(state.chips.inarbeit && !(r.__trophy.anyProgress && !r.__trophy.anyDone100)) return false;

      // query
      if(state.q && !matchRow(r, state.q)) return false;

      return true;
    });
  }

  function updateStats(){
    const total = state.rows.length;
    const hits = state.filtered.length;
    const shown = state.rendered;
    const msg = (total === 0)
      ? "Datei wÃ¤hlen â†’ Sheet wÃ¤hlen â†’ suchen"
      : `Treffer: ${hits} Â· angezeigt: ${shown}/${hits}`;
    statsEl.textContent = msg;
    miniStatsEl.textContent = msg;
  }

  function clearList(){
    listEl.innerHTML = "";
    state.rendered = 0;
    updateStats();
  }

  function formatScore(v){
    const s = norm(v);
    if(!s) return "â€”";
    // already in "xx / 100" but keep safe
    if(/\//.test(s)) return s;
    const n = toNum(s);
    return Number.isFinite(n) ? `${Math.round(n)} / 100` : s;
  }

  function formatPlaytime(main, full){
    const m = norm(main), f = norm(full);
    if(!m && !f) return "â€”";
    if(m && f) return `${m}h / ${f}h`;
    if(m) return `${m}h`;
    return `â€” / ${f}h`;
  }

  function pillForCompletion(stateName){
    // unplayed / inarbeit / done
    if(stateName === "done") return {cls:"good", text:"âœ… 100% erreicht"};
    if(stateName === "inarbeit") return {cls:"warn", text:"â³ In Arbeit"};
    return {cls:"sleep", text:"ðŸ’¤ Ungespielt"};
  }
  function pillForPlatinum(stateName){
    if(stateName === "done") return {cls:"blue", text:"ðŸ’Ž Platin erlangt"};
    if(stateName === "inarbeit") return {cls:"warn", text:"â³ In Arbeit"};
    return {cls:"sleep", text:"ðŸ’¤ Ungespielt"};
  }

  function renderTrophies(row){
    const t = row.__trophy;
    const wrap = document.createElement("div");
    wrap.className = "trophyGrid";

    for(const p of t.perPlatform){
      const tr = document.createElement("div");
      tr.className = "tRow";

      const sys = document.createElement("div");
      sys.className = "tSys";
      sys.textContent = p.platform === "ALL" ? "â€”" : p.platform;

      const bw = document.createElement("div");
      bw.className = "barWrap";

      // Progress line
      const line = document.createElement("div");
      line.className = "barLine";
      const left = document.createElement("div");
      left.style.fontWeight = "900";

      // If no progress and unplayed -> show Ungespielt
      if(!p.progress){
        left.textContent = "Ungespielt";
      } else {
        left.textContent = `${p.progress.done} of ${p.progress.total}`;
      }

      const right = document.createElement("div");
      right.className = "barNote";
      right.textContent = p.progress ? `${Math.round(p.progress.pct)}%` : "";

      line.appendChild(left);
      line.appendChild(right);

      const bar = document.createElement("div");
      bar.className = "bar";
      const fill = document.createElement("div");
      fill.style.width = p.progress ? `${p.progress.pct}%` : "0%";
      bar.appendChild(fill);

      const pills = document.createElement("div");
      pills.className = "tPills";

      const c = pillForCompletion(p.completion);
      const cp = document.createElement("span");
      cp.className = `pill ${c.cls}`;
      cp.textContent = c.text;

      const pl = pillForPlatinum(p.platinum);
      const pp = document.createElement("span");
      pp.className = `pill ${pl.cls}`;
      pp.textContent = pl.text;

      pills.appendChild(cp);
      pills.appendChild(pp);

      bw.appendChild(line);
      bw.appendChild(bar);
      bw.appendChild(pills);

      tr.appendChild(sys);
      tr.appendChild(bw);
      wrap.appendChild(tr);
    }

    return wrap;
  }

  function card(row){
    const c = document.createElement("div");
    c.className = "card" + (isDelisted(row) ? " delisted" : "");

    const head = document.createElement("div");
    head.className = "cardHead";

    const left = document.createElement("div");
    left.style.flex = "1";

    const title = document.createElement("h2");
    title.className = "title";
    title.textContent = norm(row["Spieletitel"]) || "â€”";
    left.appendChild(title);

    const stack = document.createElement("div");
    stack.className = "badgeStack";

    if(lower(row["Favorit"]) === "x"){
      const b = document.createElement("span");
      b.className = "pill";
      b.textContent = "â­ Favorit";
      stack.appendChild(b);
    }

    // top badges from trophy state
    if(row.__trophy.anyPlatin){
      const b = document.createElement("span");
      b.className = "pill blue";
      b.textContent = "ðŸ’Ž Platin erlangt";
      stack.appendChild(b);
    }
    if(row.__trophy.anyDone100){
      const b = document.createElement("span");
      b.className = "pill good";
      b.textContent = "âœ… 100% erreicht";
      stack.appendChild(b);
    }

    head.appendChild(left);
    head.appendChild(stack);
    c.appendChild(head);

    // meta row: ID + systems + availability
    const meta = document.createElement("div");
    meta.className = "metaRow";

    const id = document.createElement("span");
    id.className = "pill idPill";
    id.textContent = `ID ${norm(row["ID"]) || "â€”"}`;
    meta.appendChild(id);

    const systems = parseSystems(row["System"]);
    if(systems.length){
      for(const s of systems){
        const p = document.createElement("span");
        p.className = "pill sysPill";
        p.textContent = s;
        meta.appendChild(p);
      }
    } else {
      const p = document.createElement("span");
      p.className = "pill sysPill";
      p.textContent = "â€”";
      meta.appendChild(p);
    }

    const av = document.createElement("span");
    av.className = "pill availPill";
    av.textContent = isDelisted(row) ? "Delisted" : (norm(row["VerfÃ¼gbarkeit"]) || "â€”");
    meta.appendChild(av);

    c.appendChild(meta);

    // compact fields (always visible)
    const kv = document.createElement("div");
    kv.className = "kv";

    const addKV = (k, vNodeOrText) => {
      const kk = document.createElement("div");
      kk.className = "k";
      kk.textContent = k;

      const vv = document.createElement("div");
      vv.className = "v";
      if(vNodeOrText instanceof Node) vv.appendChild(vNodeOrText);
      else vv.textContent = has(vNodeOrText) ? vNodeOrText : "â€”";

      kv.appendChild(kk);
      kv.appendChild(vv);
    };

    addKV("Genre", norm(row["Genre"]) || "â€”");
    addKV("Entwickler", norm(row["Entwickler"]) || "â€”");
    addKV("Spielzeit", formatPlaytime(row["Spielzeit (Main)"], row["Spielzeit (100%)"]));
    addKV("Metascore", formatScore(row["Metascore"]));
    addKV("Userwertung", formatScore(row["Userwertung"]));

    c.appendChild(kv);

    // Details
    const det = document.createElement("details");
    det.open = false;
    const sum = document.createElement("summary");
    sum.textContent = "Mehr Details";
    det.appendChild(sum);

    det.addEventListener("toggle", () => {
      sum.textContent = det.open ? "Weniger Details" : "Mehr Details";
    });

    const sec = document.createElement("div");

    // Beschreibung (ausklappbar)
    const sDescTitle = document.createElement("div");
    sDescTitle.className = "sectionTitle";
    sDescTitle.textContent = "BESCHREIBUNG";
    sec.appendChild(sDescTitle);

    const desc = document.createElement("details");
    desc.className = "subdetails";
    const s1 = document.createElement("summary");
    s1.textContent = "Kurzbeschreibung anzeigen";
    desc.appendChild(s1);

    const descText = document.createElement("div");
    descText.className = "longText gapTop";
    descText.textContent = norm(row["Kurzbeschreibung"]) || "â€”";
    desc.appendChild(descText);
    sec.appendChild(desc);

    // STORE
    const sStoreTitle = document.createElement("div");
    sStoreTitle.className = "sectionTitle";
    sStoreTitle.textContent = "STORE";
    sec.appendChild(sStoreTitle);

    const storeKV = document.createElement("div");
    storeKV.className = "kv";

    const qNorm = normalizeQuelle(row["Quelle"]);
    const storeHref = getStoreHref(row);

    const storeLinkNode = (() => {
      const a = document.createElement("a");
      a.className = "store";
      a.textContent = "Store Link";
      if(storeHref){
        a.href = storeHref;
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.title = storeHref;
      } else {
        a.href = "#";
        a.addEventListener("click", (e)=>e.preventDefault());
        a.style.color = "#6b7280";
        a.style.fontWeight = "700";
        a.textContent = "â€”";
      }
      return a;
    })();

    const addKV2 = (root, k, vNodeOrText) => {
      const kk = document.createElement("div");
      kk.className = "k";
      kk.textContent = k;

      const vv = document.createElement("div");
      vv.className = "v";
      if(vNodeOrText instanceof Node) vv.appendChild(vNodeOrText);
      else vv.textContent = has(vNodeOrText) ? vNodeOrText : "â€”";

      root.appendChild(kk);
      root.appendChild(vv);
    };

    addKV2(storeKV, "Quelle", qNorm || "â€”");
    addKV2(storeKV, "Store", storeLinkNode);
    addKV2(storeKV, "VerfÃ¼gbarkeit", norm(row["VerfÃ¼gbarkeit"]) || "â€”");
    sec.appendChild(storeKV);

    // EXTRAS
    const sExtrasTitle = document.createElement("div");
    sExtrasTitle.className = "sectionTitle";
    sExtrasTitle.textContent = "EXTRAS";
    sec.appendChild(sExtrasTitle);

    const detBes = document.createElement("details");
    detBes.className = "subdetails";
    const sBes = document.createElement("summary");
    sBes.textContent = "Besonderheiten anzeigen";
    detBes.appendChild(sBes);
    const besTxt = document.createElement("div");
    besTxt.className = "longText gapTop";
    besTxt.textContent = norm(row["Besonderheiten"]) || "â€”";
    detBes.appendChild(besTxt);
    sec.appendChild(detBes);

    const detEgg = document.createElement("details");
    detEgg.className = "subdetails";
    const sEgg = document.createElement("summary");
    sEgg.textContent = "Eastereggs anzeigen";
    detEgg.appendChild(sEgg);
    const eggTxt = document.createElement("div");
    eggTxt.className = "longText gapTop";
    eggTxt.textContent = norm(row["Eastereggs"]) || "â€”";
    detEgg.appendChild(eggTxt);
    sec.appendChild(detEgg);

    // TROPHÃ„EN
    const sTrTitle = document.createElement("div");
    sTrTitle.className = "sectionTitle";
    sTrTitle.textContent = "TROPHÃ„EN";
    sec.appendChild(sTrTitle);

    sec.appendChild(renderTrophies(row));

    // HUMORSTATISTIK
    const sHumTitle = document.createElement("div");
    sHumTitle.className = "sectionTitle";
    sHumTitle.textContent = "HUMORSTATISTIK";
    sec.appendChild(sHumTitle);

    const humKV = document.createElement("div");
    humKV.className = "kv";
    addKV2(humKV, "Gesamtstunden", norm(row["Gesamtstunden (Humorstatistik)"]) || "â€”");
    addKV2(humKV, "% Lebenszeit", norm(row["% Lebenszeit (Humorstatistik)"]) || "â€”");
    addKV2(humKV, "Jahre", norm(row["Jahre (Humorstatistik)"]) || "â€”");
    sec.appendChild(humKV);

    det.appendChild(sec);
    c.appendChild(det);

    return c;
  }

  function renderMore(){
    const remaining = state.filtered.length - state.rendered;
    if(remaining <= 0){
      updateStats();
      return;
    }
    const take = Math.min(state.batch, remaining);
    const slice = state.filtered.slice(state.rendered, state.rendered + take);
    for(const r of slice){
      listEl.appendChild(card(r));
    }
    state.rendered += take;
    updateStats();
  }

  function applyAll(){
    clearList();
    const filtered = applyFilters(state.rows);
    const sorted = sortRows(filtered);
    state.filtered = sorted;
    renderMore();
  }

  // Infinite scroll
  const io = new IntersectionObserver((entries) => {
    for(const e of entries){
      if(e.isIntersecting){
        renderMore();
      }
    }
  }, { root:null, threshold:0.1 });
  io.observe(sentinel);

  // Top button
  window.addEventListener("scroll", () => {
    const y = window.scrollY || document.documentElement.scrollTop;
    fabTop.classList.toggle("show", y > 700);
  }, {passive:true});

  fabTop.addEventListener("click", () => {
    window.scrollTo({ top:0, behavior:"smooth" });
  });

  // Search sync
  function onQueryInput(v){
    state.q = v;
    qEl.value = v;
    qMiniEl.value = v;
    saveState();
    applyAll();
  }
  qEl.addEventListener("input", () => onQueryInput(qEl.value));
  qMiniEl.addEventListener("input", () => onQueryInput(qMiniEl.value));

  // -------------------------
  // File loading
  // -------------------------
  function setDisabled(disabled){
    sheetEl.disabled = disabled;
    sortEl.disabled = disabled;
    sortDirEl.disabled = disabled;
  }

  async function readFileAsArrayBuffer(file){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsArrayBuffer(file);
    });
  }

  async function readFileAsText(file){
    return new Promise((resolve,reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsText(file, "utf-8");
    });
  }

  function rowsFromCSV(text){
    // Basic CSV parser supporting quoted fields
    const rows = [];
    const lines = text.replace(/\r/g,"").split("\n").filter(l => l.length>0);
    if(lines.length === 0) return rows;

    const parseLine = (line) => {
      const out = [];
      let cur = "", inQ = false;
      for(let i=0;i<line.length;i++){
        const ch = line[i];
        if(ch === '"'){
          if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        } else if(ch === "," && !inQ){
          out.push(cur); cur = "";
        } else {
          cur += ch;
        }
      }
      out.push(cur);
      return out;
    };

    const header = parseLine(lines[0]).map(h => h.trim());
    for(let i=1;i<lines.length;i++){
      const parts = parseLine(lines[i]);
      if(parts.every(x => !x)) continue;
      const r = {};
      header.forEach((h,idx) => r[h] = parts[idx] ?? "");
      rows.push(r);
    }
    return rows;
  }

  function attachComputed(row){
    row.__trophy = computeTrophyState(row);
    return row;
  }

  function populateSortOptions(){
    // only the meaningful ones (as you specified) in that exact order
    sortEl.innerHTML = "";
    const opts = [
      ["id","Sort: ID"],
      ["title","Sort: Spieletitel"],
      ["system","Sort: System"],
      ["quelle","Sort: Quelle"],
      ["genre","Sort: Genre"],
      ["dev","Sort: Entwickler"],
      ["main","Sort: Spielzeit (Main)"],
      ["meta","Sort: Metascore"],
      ["user","Sort: Userwertung"],
      ["life","Sort: Lebenszeit %"],
    ];
    for(const [v,t] of opts){
      const o = document.createElement("option");
      o.value = v;
      o.textContent = t;
      sortEl.appendChild(o);
    }
    sortEl.value = state.sortKey || "id";
  }

  function setSheets(names){
    sheetEl.innerHTML = "";
    const o0 = document.createElement("option");
    o0.value = "";
    o0.textContent = "Sheet wÃ¤hlenâ€¦";
    sheetEl.appendChild(o0);

    for(const n of names){
      const o = document.createElement("option");
      o.value = n;
      o.textContent = n;
      sheetEl.appendChild(o);
    }
    // restore last sheet if present
    if(state.sheetName && names.includes(state.sheetName)){
      sheetEl.value = state.sheetName;
    } else if(names.length){
      sheetEl.value = names[0];
    }
  }

  function buildRowsFromSheet(workbook, sheetName){
    const ws = workbook.Sheets[sheetName];
    if(!ws) return [];

    // read as objects
    const json = XLSX.utils.sheet_to_json(ws, { defval:"", raw:false });

    // Extract store hyperlink by reading cell objects:
    // We locate the "Store Link" column letter via header row.
    // This is a bit more involved, but itâ€™s worth it for clickable links.
    const range = XLSX.utils.decode_range(ws["!ref"]);
    const headerRow = range.s.r; // first row
    const headerMap = {}; // headerName -> colIndex
    for(let c=range.s.c;c<=range.e.c;c++){
      const addr = XLSX.utils.encode_cell({r:headerRow,c});
      const cell = ws[addr];
      const h = cell ? norm(cell.v) : "";
      if(h) headerMap[h] = c;
    }
    const storeCol = headerMap["Store Link"];

    // attach per-row href if present
    if(Number.isInteger(storeCol)){
      for(let i=0;i<json.length;i++){
        const rIndex = headerRow + 1 + i; // data starts next row
        const addr = XLSX.utils.encode_cell({r:rIndex,c:storeCol});
        const cell = ws[addr];
        if(cell && cell.l && cell.l.Target){
          json[i].__storeHref = cell.l.Target;
        } else {
          // fallback: if cell value looks like URL
          const v = norm(json[i]["Store Link"]);
          if(/^https?:\/\//i.test(v)) json[i].__storeHref = v;
        }
      }
    }

    // Normalize "Quelle" to Digital label later in UI, but keep raw in row
    return json.map(r => attachComputed(r));
  }

  let currentWorkbook = null;

  fileEl.addEventListener("change", async () => {
    const f = fileEl.files && fileEl.files[0];
    if(!f) return;

    state.fileName = f.name;
    currentWorkbook = null;
    state.rows = [];
    clearList();
    setDisabled(true);

    try{
      if(f.name.toLowerCase().endsWith(".csv")){
        const text = await readFileAsText(f);
        const rows = rowsFromCSV(text).map(r => attachComputed(r));
        state.rows = rows;
        setSheets(["CSV"]);
        sheetEl.disabled = true;
        populateSortOptions();
        setDisabled(false);
        applyAll();
        return;
      }

      const buf = await readFileAsArrayBuffer(f);
      const wb = XLSX.read(buf, { type:"array" });
      currentWorkbook = wb;

      setSheets(wb.SheetNames);
      sheetEl.disabled = false;
      populateSortOptions();
      setDisabled(false);

      // auto-load selected sheet
      const pick = sheetEl.value || wb.SheetNames[0];
      state.sheetName = pick;
      saveState();

      state.rows = buildRowsFromSheet(wb, pick);
      applyAll();
    } catch(err){
      console.error(err);
      statsEl.textContent = "Fehler beim Einlesen. PrÃ¼fe, ob xlsx.full.min.js korrekt geladen ist.";
      miniStatsEl.textContent = "Fehler beim Einlesen.";
    }
  });

  sheetEl.addEventListener("change", () => {
    if(!currentWorkbook) return;
    const pick = sheetEl.value;
    if(!pick) return;
    state.sheetName = pick;
    saveState();
    state.rows = buildRowsFromSheet(currentWorkbook, pick);
    applyAll();
  });

  // Initial disabled until file loaded
  setDisabled(true);

})();
</script>
</body>
</html>