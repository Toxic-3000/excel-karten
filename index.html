<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Excel → Karten</title>
<style>
:root{font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif}
body{margin:0;background:#f6f7f9;color:#111}
header{position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e7e7e7;padding:12px 14px;display:grid;gap:10px}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
input,select,button{flex:1;min-width:170px;padding:10px 12px;border:1px solid #ddd;border-radius:12px;background:#fff;font-size:14px}
button{cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
main{padding:14px}
.hint{color:#666;font-size:13px}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(290px,1fr));gap:12px}
.card{background:#fff;border:1px solid #e9e9e9;border-radius:16px;padding:12px;box-shadow:0 1px 2px rgba(0,0,0,.04);display:grid;gap:10px}
.title{font-weight:700;font-size:16px;line-height:1.2}
.delistedTitle{text-decoration:line-through;color:#b00020}
.meta{font-size:12px;color:#555;display:flex;gap:8px;flex-wrap:wrap}
.badgeDelisted{background:#ffe7ea;color:#b00020;padding:4px 8px;border-radius:999px;font-weight:600}
.kv{display:grid;gap:6px}
.line{display:grid;grid-template-columns:140px 1fr;gap:10px;align-items:start}
.k{color:#666;font-size:12px}
.v{font-size:13px;word-break:break-word}
details{border-top:1px solid #eee;padding-top:8px}
summary{cursor:pointer;color:#2536a4;font-size:13px;user-select:none}
a{color:#2536a4;text-decoration:none}
a:hover{text-decoration:underline}
.footer{padding:0 14px 14px;color:#666;font-size:12px}
.counter{font-size:12px;color:#555}
</style>
</head>
<body>
<header>
  <div class="row">
    <strong>Excel → Karten</strong>
    <span class="hint">Kompakt + Details (Excel Mobile Style)</span>
  </div>
  <div class="row">
    <input id="file" type="file" accept=".xlsx,.xls" />
    <select id="sheetSelect" disabled><option>Sheet auswählen…</option></select>
  </div>
  <div class="row">
    <input id="search" type="search" placeholder="Suche…" disabled />
    <button id="moreBtn" disabled>Mehr laden</button>
    <button id="topBtn" disabled>↑ Top</button>
  </div>
  <div class="row">
    <span id="status" class="hint">Datei wählen → Sheet wählen → suchen</span>
    <span id="count" class="counter"></span>
  </div>
</header>

<main><div id="grid" class="grid"></div></main>
<div id="footer" class="footer"></div>

<script src="xlsx.full.min.js"></script>
<script>
/* ---------- UI ---------- */
const els = {
  file: document.getElementById("file"),
  sheet: document.getElementById("sheetSelect"),
  search: document.getElementById("search"),
  more: document.getElementById("moreBtn"),
  top: document.getElementById("topBtn"),
  status: document.getElementById("status"),
  count: document.getElementById("count"),
  grid: document.getElementById("grid"),
  footer: document.getElementById("footer"),
};

/* ---------- Optionen ---------- */
const PAGE_SIZE = 60;
const MAX_RESULTS = 600;
const PLACEHOLDER = "—";
const SHOW_EMPTY_IN_DETAILS = true;     // Details zeigen auch leere Spalten (mit —)
const SHOW_EMPTY_IN_HEADER  = false;    // Header-Bereich lieber nur echte Werte

// Das ist DEINE gewünschte "immer sichtbar"-Reihenfolge:
const CARD_HEADER_FIELDS = ["ID","Spieletitel","Favorit","Genre","Subgenre / Stimmung"];

// Für Details: zuerst diese Felder (wenn vorhanden), danach Rest alphabetisch
const DETAILS_PRIORITY = [
  "Entwickler","System","Verfügbarkeit","Store Link","Metascore","Userwertung",
  "Spielzeit (Main)","Spielzeit (100%)",
  "Gesamtstunden (Humorstatistik)","% Lebenszeit (Humorstatistik)","Jahre (Humorstatistik)",
  "Kurzbeschreibung","Quelle"
];

/* ---------- Zustand ---------- */
let workbook = null;
let allRows = [];
let columns = [];
let matches = [];
let shown = 0;
let linkMap = new Map();              // `${row1based}:${colName}` -> href
let headerRowIndex = 1;               // 1-basiert

const s = v => (v == null ? "" : String(v).trim());

function normalizeColName(name){ return s(name); }

function renderValue(value){
  if (value && typeof value === "object" && value.href) {
    const a = document.createElement("a");
    a.href = value.href;
    a.textContent = value.text || "Link";
    a.title = value.href;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    return a;
  }
  const t = s(value);
  return document.createTextNode(t || PLACEHOLDER);
}

function makeLine(k, v){
  const line = document.createElement("div");
  line.className = "line";
  const kk = document.createElement("div");
  kk.className = "k"; kk.textContent = k;
  const vv = document.createElement("div");
  vv.className = "v"; vv.appendChild(renderValue(v));
  line.append(kk, vv);
  return line;
}

function pickTitle(row){
  // exakt deine Spalte
  if (s(row["Spieletitel"])) return s(row["Spieletitel"]);
  // fallback
  for (const key of ["Titel","Name","Spiel"]) {
    const t = s(row[key]);
    if (t) return t;
  }
  for (const k of columns) {
    const t = s(row[k]);
    if (t) return t;
  }
  return "(ohne Titel)";
}

function isDelistedRow(row){
  if (row.__delisted) return true;
  const v = s(row["Verfügbarkeit"]).toLowerCase();
  return v === "delisted" || v === "removed" || v.includes("store entfernt");
}

function orderedDetailsColumns(cols){
  const have = new Set(cols);
  const first = DETAILS_PRIORITY.filter(c => have.has(c));
  // alles, was nicht in Header oder Priority ist, danach alphabetisch
  const skip = new Set([...CARD_HEADER_FIELDS, ...first]);
  const rest = cols.filter(c => !skip.has(c)).sort((a,b)=>a.localeCompare(b));
  return [...first, ...rest];
}

function getValueWithLink(row, col, rowIndex1Based){
  const raw = row[col];
  const text = s(raw);
  const href = linkMap.get(`${rowIndex1Based}:${col}`);
  if (href) return { text: text || "Store Link", href };
  return raw;
}

/* ---------- Karte ---------- */
function createCard(row, rowIndex1Based){
  const card = document.createElement("div");
  card.className = "card";

  const titleEl = document.createElement("div");
  titleEl.className = "title";
  titleEl.textContent = pickTitle(row);
  if (isDelistedRow(row)) titleEl.classList.add("delistedTitle");

  const meta = document.createElement("div");
  meta.className = "meta";
  if (isDelistedRow(row)) {
    const b = document.createElement("span");
    b.className = "badgeDelisted";
    b.textContent = "Delisted";
    meta.appendChild(b);
  }

  // --- Header-Block (nur deine 5 Felder) ---
  const headerKv = document.createElement("div");
  headerKv.className = "kv";

  for (const col of CARD_HEADER_FIELDS) {
    if (!columns.includes(col)) continue; // falls Spalte anders heißt
    const val = getValueWithLink(row, col, rowIndex1Based);
    const text = s(row[col]);
    if (!SHOW_EMPTY_IN_HEADER && !text) continue;
    headerKv.appendChild(makeLine(col, val));
  }

  // --- Details-Block (Rest) ---
  const details = document.createElement("details");
  const summary = document.createElement("summary");
  summary.textContent = "Mehr Details";
  details.appendChild(summary);

  const detailsKv = document.createElement("div");
  detailsKv.className = "kv";

  const detailCols = orderedDetailsColumns(columns);

  for (const col of detailCols) {
    // Header-Felder nicht nochmal in Details duplizieren (optional)
    if (CARD_HEADER_FIELDS.includes(col)) continue;

    const val = getValueWithLink(row, col, rowIndex1Based);
    const text = s(row[col]);
    if (!SHOW_EMPTY_IN_DETAILS && !text) continue;
    detailsKv.appendChild(makeLine(col, val));
  }

  details.appendChild(detailsKv);

  card.append(titleEl, meta, headerKv, details);
  return card;
}

/* ---------- Paging / Suche ---------- */
function updateCounters(){
  const total = matches.length;
  const cap = Math.min(total, MAX_RESULTS);
  els.count.textContent = total ? `Treffer: ${total} · angezeigt: ${Math.min(shown, cap)}/${cap}` : "";
  els.more.disabled = shown >= cap;
  els.more.textContent = els.more.disabled ? "Mehr laden" : `Mehr laden (+${Math.min(PAGE_SIZE, cap - shown)})`;
}

function renderMore(){
  const total = matches.length;
  const cap = Math.min(total, MAX_RESULTS);
  if (shown >= cap) return;

  const end = Math.min(shown + PAGE_SIZE, cap);
  const frag = document.createDocumentFragment();

  for (let i = shown; i < end; i++){
    const { row, idx } = matches[i];
    frag.appendChild(createCard(row, idx));
  }

  els.grid.appendChild(frag);
  shown = end;

  els.status.textContent = total
    ? (shown < cap ? "Mehr laden zeigt weitere Karten…" : "Alle angezeigten Karten erreicht.")
    : "Keine Treffer.";

  updateCounters();
}

function startSearch(q){
  els.grid.innerHTML = "";
  shown = 0;

  const term = (q || "").toLowerCase().trim();

  matches = allRows
    .map((row, i) => ({ row, idx: headerRowIndex + 1 + i }))
    .filter(o => {
      if (!term) return true;
      // schneller: ID/Titel/Entwickler/Genre/Subgenre zuerst, dann fallback Vollscan
      const fast =
        s(o.row["ID"]) + " " +
        s(o.row["Spieletitel"]) + " " +
        s(o.row["Entwickler"]) + " " +
        s(o.row["Genre"]) + " " +
        s(o.row["Subgenre / Stimmung"]);
      if (fast.toLowerCase().includes(term)) return true;
      return Object.values(o.row).some(v => s(v).toLowerCase().includes(term));
    });

  renderMore(); // nur erste Seite
}

/* ---------- XLSX: Links + Delisted ---------- */
function buildLinks(ws){
  linkMap.clear();
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  headerRowIndex = headerR + 1;

  const headerByCol = new Map();
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    headerByCol.set(c, cell && cell.v != null ? String(cell.v).trim() : "");
  }

  for (let rr = headerR + 1; rr <= r.e.r; rr++){
    const row1 = rr + 1;
    for (let c = r.s.c; c <= r.e.c; c++){
      const cell = ws[XLSX.utils.encode_cell({ r: rr, c })];
      if (cell && cell.l && cell.l.Target){
        const colName = headerByCol.get(c);
        if (colName) linkMap.set(`${row1}:${colName}`, String(cell.l.Target));
      }
    }
  }
}

function applyDelistedFromStyles(ws){
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  let titleC = null;

  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    const h = cell && cell.v != null ? String(cell.v).trim() : "";
    if (h === "Spieletitel") { titleC = c; break; }
  }
  if (titleC == null) return;

  for (let i = 0; i < allRows.length; i++){
    const rr = headerR + 1 + i;
    const cell = ws[XLSX.utils.encode_cell({ r: rr, c: titleC })];
    const strike = !!(cell && cell.s && cell.s.font && (cell.s.font.strike || cell.s.font.strikethrough));
    if (strike) allRows[i].__delisted = true;
  }
}

/* ---------- Events ---------- */
els.file.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  els.status.textContent = "Lese Datei…";
  const buf = await f.arrayBuffer();
  workbook = XLSX.read(buf, { type: "array", cellStyles: true });

  els.sheet.innerHTML = "<option>Sheet auswählen…</option>";
  workbook.SheetNames.forEach(n => {
    const o = document.createElement("option"); o.value = n; o.textContent = n;
    els.sheet.appendChild(o);
  });

  els.sheet.disabled = false;
  els.search.disabled = true;
  els.more.disabled = true;
  els.top.disabled = false;
  els.grid.innerHTML = "";
  els.count.textContent = "";
  els.status.textContent = "Sheet wählen…";
});

els.sheet.addEventListener("change", () => {
  const name = els.sheet.value;
  if (!name || name === "Sheet auswählen…") return;

  const ws = workbook.Sheets[name];
  const json = XLSX.utils.sheet_to_json(ws, { defval: "" });

  allRows = json;
  // Spalten aus erster Zeile + Normierung
  const rawCols = json.length ? Object.keys(json[0]).map(normalizeColName) : [];
  columns = rawCols;

  buildLinks(ws);
  applyDelistedFromStyles(ws);

  els.grid.innerHTML = "";
  els.status.textContent = `Geladen: ${allRows.length} Zeilen`;
  els.search.disabled = false;

  startSearch("");
});

els.search.addEventListener("input", (e) => startSearch(e.target.value));
els.more.addEventListener("click", () => renderMore());
els.top.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));
</script>
</body>
</html>