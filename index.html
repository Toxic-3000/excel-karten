<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spieleliste</title>
<style>
:root{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  --bg:#f6f7f9;
  --card:#fff;
  --text:#111;
  --muted:#6b7280;
  --line:#e9e9e9;
  --accent:#2536a4;
  --danger:#b00020;
  --dangerBg:#ffe7ea;
  --chipBg:#eef2ff;
}
body{margin:0;background:var(--bg);color:var(--text)}
header{
  position:sticky;top:0;z-index:10;
  background:#fff;border-bottom:1px solid #e7e7e7;
  padding:12px 14px;display:grid;gap:10px
}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
input,select,button{
  flex:1;min-width:160px;
  padding:10px 12px;border:1px solid #ddd;border-radius:12px;
  background:#fff;font-size:14px
}
button{cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}

main{padding:14px}
.hint{color:var(--muted);font-size:13px}
.counter{font-size:12px;color:#555}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(310px,1fr));gap:12px}

.card{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  box-shadow:0 1px 2px rgba(0,0,0,.04);
  display:grid;gap:10px
}
.cardTop{display:grid;gap:6px}

/* Titel links, Badge-Spalte rechts */
.titleRow{
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:start;
}
.title{font-weight:800;font-size:16px;line-height:1.15}
.title.delisted{ text-decoration:line-through; color:var(--danger); }

/* Badges immer untereinander */
.badges{
  display:flex;
  flex-direction:column;
  gap:8px;
  align-items:flex-end;
  justify-content:flex-start;
  min-width:120px;
}
.badge{
  width:fit-content;
  font-size:12px;font-weight:650;
  padding:4px 8px;border-radius:999px;
  background:var(--chipBg);color:var(--accent);
  white-space:nowrap
}
.badge.delisted{background:var(--dangerBg);color:var(--danger)}
.badge.platin{background:#eef2ff;color:#1f2a8a}

.metaRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.chip{
  font-size:12px;color:#374151;
  background:#f3f4f6;border:1px solid #ececec;
  padding:4px 8px;border-radius:999px;
  white-space:nowrap
}
.chip.on{
  background:var(--chipBg);
  border-color:#d7ddff;
  color:var(--accent);
}
.chip.btn{cursor:pointer; user-select:none}
.chip.btn:active{transform:translateY(1px)}

.idBadge{
  font-size:12px;
  font-weight:900;
  letter-spacing:.02em;
  padding:4px 10px;
  border-radius:999px;
  background:var(--accent);
  color:#fff;
  border:1px solid rgba(0,0,0,0.05);
}

.keyFacts{
  display:grid;gap:8px;
  border-top:1px solid var(--line);
  padding-top:10px
}
.kvLine{
  display:grid;
  grid-template-columns:120px 1fr;
  gap:10px;align-items:start
}
.k{color:var(--muted);font-size:12px}
.v{font-size:13px;word-break:break-word}

.detailsWrap{border-top:1px solid var(--line);padding-top:10px}
details{border:0}
summary{
  cursor:pointer;color:var(--accent);
  font-size:13px;user-select:none
}
summary::-webkit-details-marker{display:none}
.summaryBtn{display:inline-flex;align-items:center;gap:8px}
.summaryBtn::after{content:"‚ñæ";font-size:12px;transform:translateY(-1px)}
details[open] .summaryBtn::after{content:"‚ñ¥"}

.section{
  border-top:1px solid var(--line);
  padding-top:10px;
  margin-top:10px;
  display:grid;gap:8px
}
.sectionTitle{
  font-size:11px;
  letter-spacing:.08em;
  color:var(--muted);
  text-transform:uppercase;
}

.subdetails summary{color:#374151;font-size:13px}
.subdetails .summaryBtn{color:#374151}
.subdetails .summaryBtn::after{color:#6b7280}
.subdetails .content{ margin-top: 8px; }
.subdetails .contentText{ line-height:1.35; white-space:pre-line }

a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}

/* Trophy */
.trophyList{display:grid;gap:8px}
.trophyRow{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:start}
.platformChip{
  font-size:11px;font-weight:800;
  padding:2px 8px;border-radius:999px;
  background:#f3f4f6;border:1px solid #ececec;color:#374151;
  height:fit-content
}
.trophyRight{display:grid;gap:6px}
.trophyText{font-size:13px;color:#111;line-height:1.2}
.progressWrap{display:grid;gap:4px}
.progressBar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
.progressFill{height:100%;background:var(--accent);width:0%}
.progressLabel{font-size:12px;color:var(--muted)}

/* Floating Top Button */
#fabTop{
  position:fixed;
  right:14px;
  bottom:16px;
  z-index:50;
  display:none;
  border-radius:999px;
  padding:12px 14px;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 10px 24px rgba(0,0,0,.12);
  font-weight:700;
}
#fabTop.show{display:inline-flex}
</style>
</head>
<body>

<header>
  <div class="row">
    <strong>Spieleliste</strong>
    <span class="hint">Filter ¬∑ Sort ¬∑ Query-Suche ¬∑ Persistenz ¬∑ CSV-Fallback</span>
  </div>

  <div class="row">
    <input id="file" type="file" accept=".xlsx,.xls,.csv,text/csv" />
    <select id="sheetSelect" disabled><option>Sheet ausw√§hlen‚Ä¶</option></select>
  </div>

  <div class="row">
    <input id="search" type="search" placeholder="Suche‚Ä¶ (z.B. id:643 dev:capcom platform:ps5 fav:1)" disabled />
    <select id="sortSelect" disabled>
      <option value="id">Sort: ID</option>
      <option value="title">Sort: Titel</option>
      <option value="meta">Sort: Metascore</option>
      <option value="user">Sort: Userwertung</option>
      <option value="main">Sort: Spielzeit (Main)</option>
    </select>
    <button id="sortDirBtn" disabled>‚Üë</button>
  </div>

  <div class="row" id="filtersRow">
    <span class="chip btn" data-filter="fav">‚≠ê Favorit</span>
    <span class="chip btn" data-filter="platin">üíé Platin</span>
    <span class="chip btn" data-filter="delisted">Delisted</span>
    <span class="chip btn" data-filter="ps5">PS5</span>
    <span class="chip btn" data-filter="ps4">PS4</span>
    <span class="chip btn" data-filter="ps3">PS3</span>
    <span class="chip btn" data-filter="vita">Vita</span>
    <button id="clearFiltersBtn" disabled>Filter l√∂schen</button>
  </div>

  <div class="row">
    <button id="moreBtn" disabled>Mehr laden</button>
    <span id="status" class="hint">Datei w√§hlen ‚Üí Sheet w√§hlen ‚Üí suchen</span>
    <span id="count" class="counter"></span>
  </div>
</header>

<main><div id="grid" class="grid"></div></main>

<button id="fabTop" aria-label="Nach oben">‚Üë Top</button>

<script src="xlsx.full.min.js"></script>
<script>
/* ================== Settings ================== */
const PAGE_SIZE = 60;
const PLACEHOLDER = "‚Äî";
const SHOW_EMPTY_IN_KEYFACTS = true;
const SHOW_EMPTY_IN_DETAILS  = true;

const STORAGE_KEY = "spieleliste_view_state_v1";

const COL_ALIASES = {
  id: ["ID"],
  title: ["Spieletitel","Spiel","Titel","Name"],
  fav: ["Favorit","Favorite"],
  system: ["System","Plattform","Platform"],
  availability: ["Verf√ºgbarkeit","Verfuegbarkeit","Availability"],
  store: ["Store Link","Store-Link","StoreLink","Store"],
  source: ["Quelle","Source"],
  genre: ["Genre"],
  subgenre: ["Subgenre","Subgenre / Stimmung","Subgenre/Stimmung"],
  dev: ["Entwickler","Developer","Studio"],
  desc: ["Kurzbeschreibung","Beschreibung","Description"],
  easter: ["Eastereggs","Easter Eggs"],
  special: ["Besonderheiten","Highlights"],
  main: ["Spielzeit (Main)","Spielzeit Main","Main Story (Std.)","Main Story"],
  hundred: ["Spielzeit (100%)","Spielzeit 100%","100 % (Std.)","100% (Std.)","100%"],
  meta: ["Metascore","Pressemeinung (√ò)"],
  user: ["Userwertung","Userwertung (√ò)"],
  trophies: ["Troph√§en Fortschritt","Troph√§en-Fortschritt","Troph√§enfortschritt","Trophies Progress"],
  platinum: ["Platin","Platinum"],
  hours: ["Gesamtstunden (Humorstatistik)","Humorstatistik ‚Äì Gesamtstunden"],
  life: ["% Lebenszeit (Humorstatistik)","Humorstatistik ‚Äì % Lebenszeit"],
  years: ["Jahre (Humorstatistik)","Humorstatistik ‚Äì Jahre"],
};
let COL = {};

const PLATFORM_LIST = ["PS5","PS4","PS3","PS2","PS1","PSVita","Vita","PC","Switch","Xbox","Series","One"];
const PLATFORM_CANON = { "psvita":"vita", "vita":"vita", "ps5":"ps5", "ps4":"ps4", "ps3":"ps3" };

/* ================== DOM ================== */
const els = {
  file: document.getElementById("file"),
  sheet: document.getElementById("sheetSelect"),
  search: document.getElementById("search"),
  sort: document.getElementById("sortSelect"),
  sortDir: document.getElementById("sortDirBtn"),
  filtersRow: document.getElementById("filtersRow"),
  clearFilters: document.getElementById("clearFiltersBtn"),
  more: document.getElementById("moreBtn"),
  status: document.getElementById("status"),
  count: document.getElementById("count"),
  grid: document.getElementById("grid"),
  fabTop: document.getElementById("fabTop"),
};

const s = v => (v == null ? "" : String(v).trim());

/* ================== State ================== */
let workbook = null;
let allRows = [];
let matches = [];
let shown = 0;
let columns = [];
let linkMap = new Map();   // `${row1based}:${colName}` -> href (XLSX only)
let headerRowIndex = 1;    // 1-based header row (XLSX)

const viewState = {
  fileMode: "",            // "xlsx" | "csv"
  sheetName: "",
  search: "",
  sortKey: "id",
  sortDir: "asc",          // "asc" | "desc"
  filters: { fav:false, platin:false, delisted:false, ps5:false, ps4:false, ps3:false, vita:false },
};

/* ================== Persistenz ================== */
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const st = JSON.parse(raw);
    if (st && typeof st === "object"){
      Object.assign(viewState, st);
      if (st.filters) Object.assign(viewState.filters, st.filters);
    }
  }catch(e){}
}
function saveState(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(viewState));
  }catch(e){}
}
loadState();

/* ================== Header resolver ================== */
function normHeader(x){
  return String(x ?? "")
    .replace(/\u00A0/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();
}
function resolveColumns(cols){
  const byNorm = new Map(cols.map(c => [normHeader(c), c]));
  const resolved = {};
  for (const [key, aliases] of Object.entries(COL_ALIASES)) {
    let found = "";
    for (const a of aliases) {
      const hit = byNorm.get(normHeader(a));
      if (hit) { found = hit; break; }
    }
    resolved[key] = found;
  }
  return resolved;
}
function val(row, colName){
  if (!colName) return "";
  const v = row[colName];
  return v == null ? "" : String(v).trim();
}

/* ================== Plattform parsing ================== */
function extractPlatformsFromText(text){
  const t = String(text ?? "");
  const found = [];
  const re = /\b(PS5|PS4|PS3|PS2|PS1|PSVita|Vita|PC|Switch|Xbox|Series|One)\b/g;
  let m;
  while ((m = re.exec(t)) !== null) found.push(m[1]);
  return [...new Set(found)];
}
function platformsFromSystem(row){
  return extractPlatformsFromText(val(row, COL.system));
}
function rowHasPlatform(row, key){ // key: ps5/ps4/ps3/vita
  const plats = platformsFromSystem(row).map(p => p.toLowerCase());
  if (!plats.length){
    const fallback = [...extractPlatformsFromText(val(row, COL.trophies)), ...extractPlatformsFromText(val(row, COL.platinum))].map(p=>p.toLowerCase());
    return fallback.some(p => PLATFORM_CANON[p] === key || p === key);
  }
  return plats.some(p => PLATFORM_CANON[p] === key || p === key);
}

/* ================== XLSX Links & Delisted style ================== */
function buildLinks(ws){
  linkMap.clear();
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  headerRowIndex = headerR + 1;

  const headerByCol = new Map();
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    headerByCol.set(c, cell && cell.v != null ? String(cell.v).trim() : "");
  }

  for (let rr = headerR + 1; rr <= r.e.r; rr++){
    const row1 = rr + 1;
    for (let c = r.s.c; c <= r.e.c; c++){
      const cell = ws[XLSX.utils.encode_cell({ r: rr, c })];
      if (cell && cell.l && cell.l.Target){
        const colName = headerByCol.get(c);
        if (colName) linkMap.set(`${row1}:${colName}`, String(cell.l.Target));
      }
    }
  }
}
function applyDelistedFromStyles(ws){
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const titleCol = COL.title;
  if (!titleCol) return;

  const headerR = r.s.r;
  let titleC = null;
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    const h = cell && cell.v != null ? String(cell.v).trim() : "";
    if (h === titleCol) { titleC = c; break; }
  }
  if (titleC == null) return;

  for (let i = 0; i < allRows.length; i++){
    const rr = headerR + 1 + i;
    const cell = ws[XLSX.utils.encode_cell({ r: rr, c: titleC })];
    const strike = !!(cell && cell.s && cell.s.font && (cell.s.font.strike || cell.s.font.strikethrough));
    if (strike) allRows[i].__delisted = true;
  }
}
function isDelistedRow(row){
  if (row.__delisted) return true;
  const v = val(row, COL.availability).toLowerCase();
  return v === "delisted" || v === "removed" || v.includes("store entfernt");
}
function getValueWithLink(row, colName, rowIndex1Based){
  const text = val(row, colName);
  const href = linkMap.get(`${rowIndex1Based}:${colName}`);
  if (href) return { text: text || "Store Link", href };
  return text;
}

/* ================== Parsing helper (Scores / Hours) ================== */
function parseScore(text){
  const t = String(text ?? "").trim();
  if (!t) return NaN;
  // "72 / 100" -> 72
  const m = t.match(/(\d+(?:[.,]\d+)?)/);
  if (!m) return NaN;
  return parseFloat(m[1].replace(",", "."));
}
function parseHours(text){
  const t = String(text ?? "").trim();
  if (!t) return NaN;
  const m = t.match(/(\d+(?:[.,]\d+)?)/);
  if (!m) return NaN;
  return parseFloat(m[1].replace(",", "."));
}

/* ================== UI helpers ================== */
function renderValue(value){
  if (value && typeof value === "object" && value.href) {
    const a = document.createElement("a");
    a.href = value.href;
    a.textContent = value.text || "Link";
    a.title = value.href;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    return a;
  }
  const t = s(value);
  return document.createTextNode(t || PLACEHOLDER);
}
function kvLine(label, valueNode){
  const line = document.createElement("div");
  line.className = "kvLine";
  const k = document.createElement("div");
  k.className = "k";
  k.textContent = label;
  const v = document.createElement("div");
  v.className = "v";
  v.appendChild(valueNode);
  line.append(k, v);
  return line;
}
function makeChip(text, cls=""){
  const c = document.createElement("span");
  c.className = "chip" + (cls ? " " + cls : "");
  c.textContent = text;
  return c;
}
function makeIdBadge(idText){
  const b = document.createElement("span");
  b.className = "idBadge";
  b.textContent = `ID ${idText || PLACEHOLDER}`;
  return b;
}
function makeBadge(text, cls=""){
  const b = document.createElement("span");
  b.className = "badge" + (cls ? " " + cls : "");
  b.textContent = text;
  return b;
}
function formatFavorite(row){
  const f = val(row, COL.fav).toLowerCase();
  if (!f) return "";
  return (f === "x" || f === "1" || f === "true" || f === "yes" || f === "y" || f.includes("‚≠ê")) ? "‚≠ê Favorit" : "";
}
function isPlatinum(row){
  const p = val(row, COL.platinum).toLowerCase();
  if (!p) return false;
  return p.includes("platinum") || p === "x" || p === "ja" || p === "yes" || p === "true";
}
function formatPlaytime(row){
  const m = val(row, COL.main);
  const h = val(row, COL.hundred);
  if (!m && !h) return "";
  if (m && h) return `${m}h / ${h}h`;
  return m ? `${m}h` : `${h}h`;
}

/* Toggle-Block */
function makeToggleBlock(label, contentText){
  const d = document.createElement("details");
  d.className = "subdetails";

  const ssum = document.createElement("summary");
  const sbtn = document.createElement("span");
  sbtn.className = "summaryBtn";
  sbtn.textContent = `${label} anzeigen`;
  ssum.appendChild(sbtn);
  d.appendChild(ssum);

  const wrap = document.createElement("div");
  wrap.className = "content";
  const txt = document.createElement("div");
  txt.className = "v contentText";
  txt.textContent = contentText || PLACEHOLDER;
  wrap.appendChild(txt);
  d.appendChild(wrap);

  d.addEventListener("toggle", () => {
    sbtn.textContent = d.open ? `${label} ausblenden` : `${label} anzeigen`;
  });

  return d;
}

/* Trophy */
function parsePlatformPairs(text){
  const t = String(text ?? "").trim();
  if (!t) return [];
  const hits = [];
  for (const p of PLATFORM_LIST) {
    const re = new RegExp(`\\b${p}\\b`, "g");
    let m;
    while ((m = re.exec(t)) !== null) hits.push({ p, i: m.index });
  }
  hits.sort((a,b)=>a.i-b.i);
  if (!hits.length) return [];

  const out = [];
  for (let j=0;j<hits.length;j++){
    const start = hits[j].i;
    const end = (j+1<hits.length) ? hits[j+1].i : t.length;
    const p = hits[j].p;
    let seg = t.slice(start, end).trim();
    seg = seg.replace(new RegExp(`^${p}\\s*`), "").trim();
    out.push({ platform: p, text: seg || PLACEHOLDER });
  }
  return out;
}
function parseFraction(text){
  const s = String(text ?? "");
  let m = s.match(/(\d+)\s*(?:of|von|\/)\s*(\d+)/i);
  if (!m) return null;
  const a = parseInt(m[1], 10);
  const b = parseInt(m[2], 10);
  if (!b) return null;
  const pct = Math.max(0, Math.min(1, a / b));
  return { a, b, pct };
}
function progressNode(fr){
  const wrap = document.createElement("div");
  wrap.className = "progressWrap";
  const bar = document.createElement("div");
  bar.className = "progressBar";
  const fill = document.createElement("div");
  fill.className = "progressFill";
  fill.style.width = `${Math.round(fr.pct * 100)}%`;
  bar.appendChild(fill);
  const lab = document.createElement("div");
  lab.className = "progressLabel";
  lab.textContent = `${Math.round(fr.pct * 100)}% (${fr.a}/${fr.b})`;
  wrap.append(bar, lab);
  return wrap;
}
function trophyList(items){
  const wrap = document.createElement("div");
  wrap.className = "trophyList";
  for (const it of items) {
    const rowEl = document.createElement("div");
    rowEl.className = "trophyRow";

    const chip = document.createElement("span");
    chip.className = "platformChip";
    chip.textContent = it.platform || "‚Äî";

    const right = document.createElement("div");
    right.className = "trophyRight";

    const txt = document.createElement("div");
    txt.className = "trophyText";
    txt.textContent = it.text || PLACEHOLDER;
    right.appendChild(txt);

    const fr = parseFraction(it.text);
    if (fr) right.appendChild(progressNode(fr));

    rowEl.append(chip, right);
    wrap.appendChild(rowEl);
  }
  return wrap;
}
function trophyNeutral(text, sysPlatforms){
  const outer = document.createElement("div");
  outer.style.display = "grid";
  outer.style.gap = "8px";

  if (sysPlatforms && sysPlatforms.length) {
    const chipRow = document.createElement("div");
    chipRow.style.display = "flex";
    chipRow.style.gap = "6px";
    chipRow.style.flexWrap = "wrap";
    for (const p of sysPlatforms) chipRow.appendChild(makeChip(p));
    outer.appendChild(chipRow);
  }

  const txt = document.createElement("div");
  txt.className = "trophyText";
  txt.textContent = text || PLACEHOLDER;
  outer.appendChild(txt);

  const fr = parseFraction(text);
  if (fr) outer.appendChild(progressNode(fr));

  return outer;
}
function trophyNodeFromText(text, row){
  const raw = String(text ?? "").trim();
  if (!raw) return document.createTextNode(PLACEHOLDER);

  const pairs = parsePlatformPairs(raw);
  if (pairs.length) return trophyList(pairs);

  const sysPlatforms = platformsFromSystem(row);
  if (sysPlatforms.length === 1) return trophyList([{ platform: sysPlatforms[0], text: raw }]);
  if (sysPlatforms.length > 1) return trophyNeutral(raw, sysPlatforms);
  return trophyNeutral(raw, []);
}

/* ================== Card ================== */
function createCard(row, rowIndex1Based){
  const card = document.createElement("div");
  card.className = "card";

  const top = document.createElement("div");
  top.className = "cardTop";

  const titleRow = document.createElement("div");
  titleRow.className = "titleRow";

  const title = document.createElement("div");
  title.className = "title";
  title.textContent = val(row, COL.title) || "(ohne Titel)";
  if (isDelistedRow(row)) title.classList.add("delisted");

  const badges = document.createElement("div");
  badges.className = "badges";
  if (isDelistedRow(row)) badges.appendChild(makeBadge("Delisted", "delisted"));
  const favLabel = formatFavorite(row);
  if (favLabel) badges.appendChild(makeBadge(favLabel));
  if (isPlatinum(row)) badges.appendChild(makeBadge("üíé Platin", "platin"));

  titleRow.append(title, badges);

  const metaRow = document.createElement("div");
  metaRow.className = "metaRow";
  metaRow.appendChild(makeIdBadge(val(row, COL.id)));

  let plats = platformsFromSystem(row);
  if (!plats.length) {
    const fromT = extractPlatformsFromText(val(row, COL.trophies));
    const fromP = extractPlatformsFromText(val(row, COL.platinum));
    plats = [...new Set([...fromT, ...fromP])];
  }
  if (plats.length) plats.forEach(p => metaRow.appendChild(makeChip(p)));
  else metaRow.appendChild(makeChip(PLACEHOLDER));

  metaRow.appendChild(makeChip(val(row, COL.availability) || PLACEHOLDER));

  top.append(titleRow, metaRow);

  const key = document.createElement("div");
  key.className = "keyFacts";

  const genre = val(row, COL.genre);
  const subg  = val(row, COL.subgenre);
  const pt    = formatPlaytime(row);
  const metaScore = val(row, COL.meta);
  const userScore = val(row, COL.user);

  if (genre || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Genre", renderValue(genre)));
  if (subg  || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Subgenre / Stimmung", renderValue(subg)));
  if (pt    || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Spielzeit", renderValue(pt)));
  if (metaScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Metascore", renderValue(metaScore)));
  if (userScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Userwertung", renderValue(userScore)));

  const detailsWrap = document.createElement("div");
  detailsWrap.className = "detailsWrap";

  const details = document.createElement("details");
  const summary = document.createElement("summary");
  const sumSpan = document.createElement("span");
  sumSpan.className = "summaryBtn";
  sumSpan.textContent = "Mehr Details";
  summary.appendChild(sumSpan);
  details.appendChild(summary);

  details.addEventListener("toggle", () => {
    sumSpan.textContent = details.open ? "Weniger Details" : "Mehr Details";
  });

  function addSection(titleText, lines){
    if (!lines.some(x => x != null)) return;
    const sec = document.createElement("div");
    sec.className = "section";
    const st = document.createElement("div");
    st.className = "sectionTitle";
    st.textContent = titleText;
    sec.appendChild(st);
    for (const line of lines) if (line) sec.appendChild(line);
    details.appendChild(sec);
  }

  addSection("Beschreibung", [ makeToggleBlock("Kurzbeschreibung", val(row, COL.desc)) ]);

  const storeVal = (viewState.fileMode === "xlsx")
    ? getValueWithLink(row, COL.store, rowIndex1Based)
    : val(row, COL.store);

  const source = val(row, COL.source);
  const availability = val(row, COL.availability);
  addSection("Store", [
    (storeVal || SHOW_EMPTY_IN_DETAILS) ? kvLine("Store", renderValue(storeVal)) : null,
    (source   || SHOW_EMPTY_IN_DETAILS) ? kvLine("Quelle", renderValue(source)) : null,
    (availability || SHOW_EMPTY_IN_DETAILS) ? kvLine("Verf√ºgbarkeit", renderValue(availability)) : null,
  ]);

  const dev = val(row, COL.dev);
  addSection("Entwickler", [
    (dev || SHOW_EMPTY_IN_DETAILS) ? kvLine("Entwickler", renderValue(dev)) : null
  ]);

  addSection("Extras", [
    makeToggleBlock("Besonderheiten", val(row, COL.special)),
    makeToggleBlock("Eastereggs", val(row, COL.easter))
  ]);

  const trophies = val(row, COL.trophies);
  const platinum = val(row, COL.platinum);
  addSection("Troph√§en", [
    kvLine("Fortschritt", trophyNodeFromText(trophies, row)),
    kvLine("Platin", trophyNodeFromText(platinum, row)),
  ]);

  const hours = val(row, COL.hours);
  const life  = val(row, COL.life);
  const years = val(row, COL.years);
  addSection("Humorstatistik", [
    (hours || SHOW_EMPTY_IN_DETAILS) ? kvLine("Gesamtstunden", renderValue(hours)) : null,
    (life  || SHOW_EMPTY_IN_DETAILS) ? kvLine("% Lebenszeit", renderValue(life)) : null,
    (years || SHOW_EMPTY_IN_DETAILS) ? kvLine("Jahre", renderValue(years)) : null,
  ]);

  detailsWrap.appendChild(details);
  card.append(top, key, detailsWrap);
  return card;
}

/* ================== Query Syntax ================== */
function parseQuery(q){
  const raw = (q || "").trim();
  const tokens = raw.length ? raw.split(/\s+/) : [];
  const filters = {
    text: [],
    id: "",
    dev: "",
    platform: "",
    genre: "",
    sub: "",
    fav: null,
    platin: null,
    delisted: null,
  };

  for (const t of tokens){
    const m = t.match(/^(\w+)\:(.+)$/);
    if (!m){ filters.text.push(t); continue; }
    const key = m[1].toLowerCase();
    const val = m[2];

    const truthy = v => ["1","true","yes","ja","x"].includes(String(v).toLowerCase());
    const falsy  = v => ["0","false","no","nein"].includes(String(v).toLowerCase());

    if (key === "id") filters.id = val;
    else if (key === "dev") filters.dev = val;
    else if (key === "platform" || key === "plat") filters.platform = val.toLowerCase();
    else if (key === "genre") filters.genre = val;
    else if (key === "sub") filters.sub = val;
    else if (key === "fav") filters.fav = truthy(val) ? true : (falsy(val) ? false : null);
    else if (key === "platin") filters.platin = truthy(val) ? true : (falsy(val) ? false : null);
    else if (key === "delisted") filters.delisted = truthy(val) ? true : (falsy(val) ? false : null);
    else filters.text.push(t);
  }
  return filters;
}
function queryMatchesRow(qf, row){
  const txt = qf.text.join(" ").toLowerCase();
  if (txt){
    const hay = Object.values(row).map(v => s(v).toLowerCase()).join(" ");
    if (!hay.includes(txt)) return false;
  }
  if (qf.id){
    const idv = val(row, COL.id).toLowerCase();
    if (!idv.includes(qf.id.toLowerCase())) return false;
  }
  if (qf.dev){
    const dv = val(row, COL.dev).toLowerCase();
    if (!dv.includes(qf.dev.toLowerCase())) return false;
  }
  if (qf.genre){
    const gv = val(row, COL.genre).toLowerCase();
    if (!gv.includes(qf.genre.toLowerCase())) return false;
  }
  if (qf.sub){
    const sv = val(row, COL.subgenre).toLowerCase();
    if (!sv.includes(qf.sub.toLowerCase())) return false;
  }
  if (qf.platform){
    const p = qf.platform.toLowerCase();
    const canon = PLATFORM_CANON[p] || p;
    if (!rowHasPlatform(row, canon)) return false;
  }
  if (qf.fav !== null){
    const isFav = !!formatFavorite(row);
    if (isFav !== qf.fav) return false;
  }
  if (qf.platin !== null){
    const pl = isPlatinum(row);
    if (pl !== qf.platin) return false;
  }
  if (qf.delisted !== null){
    const d = isDelistedRow(row);
    if (d !== qf.delisted) return false;
  }
  return true;
}

/* ================== Sort ================== */
function sortMatches(arr){
  const key = viewState.sortKey;
  const dir = viewState.sortDir === "asc" ? 1 : -1;

  const get = (row) => {
    if (key === "id") return parseScore(val(row, COL.id));
    if (key === "title") return val(row, COL.title).toLowerCase();
    if (key === "meta") return parseScore(val(row, COL.meta));
    if (key === "user") return parseScore(val(row, COL.user));
    if (key === "main") return parseHours(val(row, COL.main));
    return 0;
  };

  arr.sort((a,b) => {
    const av = get(a.row);
    const bv = get(b.row);

    // Strings
    if (typeof av === "string" || typeof bv === "string"){
      const as = String(av ?? "");
      const bs = String(bv ?? "");
      return dir * as.localeCompare(bs, "de", { sensitivity: "base" });
    }

    // Numbers (NaN -> bottom)
    const an = Number.isFinite(av) ? av : -Infinity;
    const bn = Number.isFinite(bv) ? bv : -Infinity;
    if (an === bn) return 0;
    return dir * (an < bn ? -1 : 1);
  });

  return arr;
}

/* ================== Filters (Chips) ================== */
function applyChipUI(){
  for (const el of els.filtersRow.querySelectorAll(".chip[data-filter]")){
    const k = el.getAttribute("data-filter");
    const on = !!viewState.filters[k];
    el.classList.toggle("on", on);
  }
  els.clearFilters.disabled = !(Object.values(viewState.filters).some(Boolean));
}
function rowPassesChipFilters(row){
  const f = viewState.filters;
  if (f.fav && !formatFavorite(row)) return false;
  if (f.platin && !isPlatinum(row)) return false;
  if (f.delisted && !isDelistedRow(row)) return false;

  const platformFilters = ["ps5","ps4","ps3","vita"].filter(k => f[k]);
  if (platformFilters.length){
    // OR-Logik: irgendeine Plattform passt
    const ok = platformFilters.some(k => rowHasPlatform(row, k));
    if (!ok) return false;
  }
  return true;
}

/* ================== Paging / Render ================== */
function updateCounters(){
  const total = matches.length;
  els.count.textContent = total ? `Treffer: ${total} ¬∑ angezeigt: ${shown}/${total}` : "";
  els.more.disabled = shown >= total;
  els.more.textContent = els.more.disabled ? "Mehr laden" : `Mehr laden (+${Math.min(PAGE_SIZE, total - shown)})`;
}
function renderMore(){
  const total = matches.length;
  if (shown >= total) return;

  const end = Math.min(shown + PAGE_SIZE, total);
  const frag = document.createDocumentFragment();

  for (let i = shown; i < end; i++){
    const { row, idx } = matches[i];
    frag.appendChild(createCard(row, idx));
  }
  els.grid.appendChild(frag);
  shown = end;

  els.status.textContent = total
    ? (shown < total ? "Mehr laden zeigt weitere Karten‚Ä¶" : "Alle Karten angezeigt.")
    : "Keine Treffer.";

  updateCounters();
}
function rebuildMatches(){
  els.grid.innerHTML = "";
  shown = 0;

  const q = parseQuery(viewState.search);

  matches = allRows
    .map((row, i) => ({ row, idx: headerRowIndex + 1 + i }))
    .filter(o => queryMatchesRow(q, o.row))
    .filter(o => rowPassesChipFilters(o.row));

  sortMatches(matches);
  renderMore();

  // Controls enable
  els.more.disabled = matches.length === 0;
  els.sort.disabled = false;
  els.sortDir.disabled = false;
}
function startSearch(q){
  viewState.search = q || "";
  saveState();
  rebuildMatches();
}

/* ================== CSV fallback ================== */
function detectDelimiter(firstLine){
  const commas = (firstLine.match(/,/g) || []).length;
  const semis  = (firstLine.match(/;/g) || []).length;
  return semis > commas ? ";" : ",";
}
function parseCSV(text){
  // Simple CSV parser with quotes; supports \r\n or \n
  const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
  // skip empty leading lines
  while (lines.length && !lines[0].trim()) lines.shift();
  if (!lines.length) return { rows: [], headers: [] };

  const delim = detectDelimiter(lines[0]);

  function splitLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const ch = line[i];
      if (ch === '"'){
        // double quote escape
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === delim && !inQ){
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(v => v.trim());
  }

  const headers = splitLine(lines[0]).map(h => h.replace(/^\uFEFF/, "").trim());
  const rows = [];

  for (let r=1; r<lines.length; r++){
    const line = lines[r];
    if (!line || !line.trim()) continue;
    const cells = splitLine(line);
    const obj = {};
    for (let c=0; c<headers.length; c++){
      obj[headers[c]] = cells[c] ?? "";
    }
    rows.push(obj);
  }
  return { rows, headers };
}

/* ================== Load file ================== */
function resetUIForNewData(){
  els.grid.innerHTML = "";
  els.count.textContent = "";
  els.more.disabled = true;
  els.sort.disabled = true;
  els.sortDir.disabled = true;
  els.clearFilters.disabled = true;
  els.search.disabled = true;
  els.sheet.disabled = true;
  els.sheet.innerHTML = "<option>Sheet ausw√§hlen‚Ä¶</option>";
  linkMap.clear();
  headerRowIndex = 1;
  allRows = [];
  matches = [];
  shown = 0;
}
async function loadXLSX(file){
  if (typeof XLSX === "undefined") {
    els.status.textContent = "Fehler: XLSX Library nicht geladen (xlsx.full.min.js fehlt?)";
    return;
  }
  viewState.fileMode = "xlsx";
  const buf = await file.arrayBuffer();
  workbook = XLSX.read(buf, { type: "array", cellStyles: true });

  els.sheet.innerHTML = "<option>Sheet ausw√§hlen‚Ä¶</option>";
  workbook.SheetNames.forEach(n => {
    const o = document.createElement("option");
    o.value = n; o.textContent = n;
    els.sheet.appendChild(o);
  });

  els.sheet.disabled = false;
  els.status.textContent = "Sheet w√§hlen‚Ä¶";

  // Persist: restore last sheet if exists
  if (viewState.sheetName && workbook.SheetNames.includes(viewState.sheetName)){
    els.sheet.value = viewState.sheetName;
    loadSheet(viewState.sheetName);
  }
}
function loadSheet(name){
  const ws = workbook.Sheets[name];
  const json = XLSX.utils.sheet_to_json(ws, { defval: "" });

  allRows = json;
  columns = json.length ? Object.keys(json[0]) : [];
  COL = resolveColumns(columns);

  buildLinks(ws);
  applyDelistedFromStyles(ws);

  els.search.disabled = false;
  els.sort.disabled = false;
  els.sortDir.disabled = false;

  els.search.value = viewState.search || "";
  els.sort.value = viewState.sortKey || "id";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";

  viewState.sheetName = name;
  saveState();

  els.status.textContent = `Geladen: ${allRows.length} Zeilen`;
  rebuildMatches();
}
async function loadCSV(file){
  viewState.fileMode = "csv";
  workbook = null;
  linkMap.clear();

  const buf = await file.arrayBuffer();
  const text = new TextDecoder("utf-8").decode(buf);

  const parsed = parseCSV(text);
  allRows = parsed.rows;
  columns = parsed.headers;

  COL = resolveColumns(columns);

  // CSV has no styling; no strike-through detection
  els.sheet.disabled = true;
  els.sheet.innerHTML = "<option>(CSV: kein Sheet)</option>";
  els.search.disabled = false;
  els.sort.disabled = false;
  els.sortDir.disabled = false;

  els.search.value = viewState.search || "";
  els.sort.value = viewState.sortKey || "id";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";

  els.status.textContent = `CSV geladen: ${allRows.length} Zeilen`;
  saveState();
  rebuildMatches();
}

/* ================== Events ================== */
els.more.addEventListener("click", () => renderMore());

els.fabTop.addEventListener("click", () => {
  window.scrollTo({ top: 0, behavior: "smooth" });
});

window.addEventListener("scroll", () => {
  const show = window.scrollY > 500;
  els.fabTop.classList.toggle("show", show);
}, { passive:true });

els.file.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  resetUIForNewData();
  els.status.textContent = "Lese Datei‚Ä¶";

  const name = (f.name || "").toLowerCase();
  try{
    if (name.endsWith(".csv")){
      await loadCSV(f);
    } else {
      await loadXLSX(f);
    }
  }catch(err){
    els.status.textContent = "Fehler beim Einlesen: " + (err?.message || String(err));
  }
});

els.sheet.addEventListener("change", () => {
  const name = els.sheet.value;
  if (!name || name === "Sheet ausw√§hlen‚Ä¶") return;
  loadSheet(name);
});

els.search.addEventListener("input", (e) => startSearch(e.target.value));

els.sort.addEventListener("change", (e) => {
  viewState.sortKey = e.target.value;
  saveState();
  rebuildMatches();
});
els.sortDir.addEventListener("click", () => {
  viewState.sortDir = (viewState.sortDir === "asc") ? "desc" : "asc";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";
  saveState();
  rebuildMatches();
});

/* Filter chips */
els.filtersRow.addEventListener("click", (e) => {
  const t = e.target;
  if (!(t instanceof HTMLElement)) return;

  if (t.id === "clearFiltersBtn"){
    for (const k of Object.keys(viewState.filters)) viewState.filters[k] = false;
    applyChipUI();
    saveState();
    rebuildMatches();
    return;
  }

  if (t.classList.contains("chip") && t.dataset.filter){
    const k = t.dataset.filter;
    viewState.filters[k] = !viewState.filters[k];
    applyChipUI();
    saveState();
    rebuildMatches();
  }
});

/* ================== Restore UI state (filters + controls) ================== */
function bootApplyUI(){
  // Apply chips state
  applyChipUI();
  // Controls initial (until file loaded)
  els.sort.value = viewState.sortKey || "id";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";
  els.search.value = viewState.search || "";
}
bootApplyUI();
</script>
</body>
</html>