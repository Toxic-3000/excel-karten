<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Spieleliste</title>
  <style>
    :root{
      --bg:#f6f7fb;
      --card:#fff;
      --text:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --shadow: 0 10px 30px rgba(17,24,39,.08);
      --shadow2: 0 6px 18px rgba(17,24,39,.08);
      --radius:18px;
      --radius2:14px;

      --blue:#1d4ed8;
      --blueBg:#e8efff;

      --ok:#16a34a;
      --okBg:#e8f8ee;

      --warn:#b45309;
      --warnBg:#fff2e0;

      --bad:#dc2626;
      --badBg:#ffe9e9;

      --plat:#2563eb;
      --platBg:#e7f0ff;

      --sleep:#334155;
      --sleepBg:#edf2f7;

      --chip:#f3f4f6;
      --chipText:#111827;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    .wrap{
      max-width:980px;
      margin:0 auto;
      padding:18px 14px 40px;
    }

    h1{
      margin:6px 0 12px;
      font-size:26px;
      letter-spacing:-.02em;
    }

    .topbar{
      position: sticky;
      top:0;
      z-index:50;
      padding:10px 0 10px;
      background: linear-gradient(to bottom, rgba(246,247,251,.98), rgba(246,247,251,.92));
      backdrop-filter: blur(10px);
    }

    .controls{
      background:var(--card);
      border:1px solid var(--line);
      box-shadow: var(--shadow2);
      border-radius: var(--radius);
      padding:12px;
    }

    .grid2{
      display:grid;
      grid-template-columns: 1.1fr 1fr;
      gap:10px;
    }
    @media (max-width:720px){
      .grid2{ grid-template-columns: 1fr; }
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    label.small{
      font-size:12px;
      color:var(--muted);
      display:block;
      margin:0 0 6px;
    }

    input[type="file"]{
      width:100%;
      padding:9px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
    }

    select, input[type="text"]{
      width:100%;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      background:#fff;
      font-size:16px;
      outline:none;
    }
    input[type="text"]:focus, select:focus{
      border-color:#c7d2fe;
      box-shadow:0 0 0 4px rgba(99,102,241,.12);
    }

    .miniRow{
      display:flex;
      gap:10px;
      align-items:center;
    }

    .btnIcon{
      min-width:48px;
      height:44px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#eef2ff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:20px;
      cursor:pointer;
      user-select:none;
    }
    .btnIcon:active{ transform: translateY(1px); }

    .pillRow{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--chip);
      color:var(--chipText);
      font-size:13px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .chip.on{
      border-color:#c7d2fe;
      background:#eef2ff;
    }
    .chip .dot{
      width:8px;height:8px;border-radius:999px;
      background:#9ca3af;
    }

    .chip.ok .dot{ background:var(--ok); }
    .chip.warn .dot{ background:var(--warn); }
    .chip.bad .dot{ background:var(--bad); }
    .chip.plat .dot{ background:var(--plat); }
    .chip.sleep .dot{ background:var(--sleep); }

    .chipGroupTitle{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
    }

    .stats{
      margin-top:10px;
      font-size:13px;
      color:var(--muted);
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    .cards{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 12px;
      overflow:hidden;
    }

    .cardHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }

    .title{
      font-weight:800;
      font-size:20px;
      line-height:1.15;
      letter-spacing:-.01em;
    }

    .badgeCol{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      min-width: 140px;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      font-weight:700;
      font-size:13px;
      border:1px solid var(--line);
      background:#f8fafc;
      white-space:nowrap;
    }

    .badge.fav{ background:#fff7ed; border-color:#fed7aa; }
    .badge.del{ background:#ffe9e9; border-color:#fecaca; color:var(--bad); text-decoration: line-through; }
    .badge.ok{ background:var(--okBg); border-color:#bbf7d0; color:#14532d; }
    .badge.warn{ background:var(--warnBg); border-color:#fed7aa; color:#7c2d12; }
    .badge.plat{ background:var(--platBg); border-color:#bfdbfe; color:#1e40af; }
    .badge.sleep{ background:var(--sleepBg); border-color:#cbd5e1; color:#0f172a; }

    .idPill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      background:var(--blue);
      color:#fff;
      font-weight:900;
      font-size:13px;
      letter-spacing:.02em;
    }

    .subBadges{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
      align-items:center;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      background:#f3f4f6;
      border:1px solid var(--line);
      font-weight:700;
      font-size:13px;
      color:#111827;
      white-space:nowrap;
    }
    .tag.gray{ color:var(--muted); font-weight:700; }
    .tag.avail{ background:#f8fafc; }
    .tag.sys{ background:#f3f4f6; }

    .kv{
      margin-top:10px;
      border-top:1px solid var(--line);
      padding-top:10px;
      display:grid;
      grid-template-columns: 190px 1fr;
      gap:8px 10px;
    }
    @media (max-width:520px){
      .kv{ grid-template-columns: 1fr; }
      .k{ font-size:12px; }
    }
    .k{ color:var(--muted); font-size:13px; }
    .v{ font-weight:700; font-size:14px; }
    .v.mono{ font-variant-numeric: tabular-nums; }
    .v a{ color:#2563eb; text-decoration:none; font-weight:800; }
    .v a:hover{ text-decoration:underline; }

    .detailsToggle{
      margin-top:10px;
      border-top:1px solid var(--line);
      padding-top:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      color:#1e3a8a;
      font-weight:800;
      cursor:pointer;
      user-select:none;
    }

    .section{
      margin-top:10px;
      border-top:1px solid var(--line);
      padding-top:10px;
    }
    .secTitle{
      font-size:12px;
      letter-spacing:.12em;
      color:var(--muted);
      font-weight:900;
      margin-bottom:8px;
    }

    .subToggle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 0;
      cursor:pointer;
      user-select:none;
      color:#1f2937;
      font-weight:900;
    }
    .subBody{
      padding:6px 0 10px;
      color:#111827;
      font-weight:650;
      line-height:1.45;
      white-space:pre-wrap;
    }
    .mutedSmall{
      color:var(--muted);
      font-size:12px;
      font-weight:700;
    }

    .trophyGrid{
      display:grid;
      grid-template-columns: 62px 1fr;
      gap:10px 10px;
      align-items:start;
    }
    .platChip{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#f3f4f6;
      font-size:12px;
      font-weight:900;
      width:max-content;
    }

    .tLines{
      display:grid;
      gap:8px;
    }
    .tLine{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .bar{
      height:8px;
      background:#eef2ff;
      border-radius:999px;
      overflow:hidden;
      border:1px solid #dbeafe;
      margin-top:6px;
    }
    .bar i{
      display:block;
      height:100%;
      background:#1d4ed8;
      width:0%;
      border-radius:999px;
    }
    .barNote{
      margin-top:6px;
      font-size:12px;
      color:var(--muted);
      font-weight:800;
    }

    .fabTop{
      position: fixed;
      right:14px;
      bottom:14px;
      z-index:60;
      display:none;
    }
    .fabTop button{
      border:1px solid var(--line);
      background:#fff;
      border-radius:999px;
      padding:10px 12px;
      font-weight:900;
      box-shadow: var(--shadow2);
      cursor:pointer;
    }

    .drawerOverlay{
      position: fixed;
      inset:0;
      background: rgba(17,24,39,.35);
      backdrop-filter: blur(3px);
      z-index:80;
      display:none;
    }
    .drawer{
      position: fixed;
      inset: 0 0 auto 0;
      max-height: 86vh;
      background:#fff;
      border-top-left-radius: 22px;
      border-top-right-radius: 22px;
      box-shadow: 0 -12px 30px rgba(17,24,39,.18);
      z-index:90;
      transform: translateY(110%);
      transition: transform .22s ease;
      padding:14px 14px 18px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .drawer.open{ transform: translateY(0); }
    .drawerOverlay.open{ display:block; }

    .drawerHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .drawerTitle{
      font-weight:950;
      font-size:16px;
    }
    .drawerClose{
      border:1px solid var(--line);
      background:#f3f4f6;
      border-radius:999px;
      padding:8px 12px;
      font-weight:900;
      cursor:pointer;
    }

    .hint{
      margin-top:8px;
      border:1px dashed var(--line);
      background:#f8fafc;
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      color:var(--muted);
      font-weight:650;
      line-height:1.35;
    }

    .sentinel{
      height:1px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar" id="topbar">
      <h1>Spieleliste</h1>

      <div class="controls">
        <div class="grid2">
          <div>
            <label class="small">Datei auswÃ¤hlen (XLSX)</label>
            <input id="file" type="file" accept=".xlsx,.xls" />
          </div>
          <div>
            <label class="small">Sheet</label>
            <select id="sheet" disabled>
              <option value="">Sheet auswÃ¤hlenâ€¦</option>
            </select>
          </div>
        </div>

        <div class="grid2" style="margin-top:10px;">
          <div class="miniRow">
            <input id="q" type="text" placeholder='Sucheâ€¦ (z.B. id:643 delisted favoritlevel)' />
          </div>
          <div class="miniRow">
            <select id="sort">
              <option value="id_asc">Sort: ID â†‘</option>
              <option value="id_desc">Sort: ID â†“</option>
              <option value="title_asc">Sort: Spieletitel (Text) â†‘</option>
              <option value="title_desc">Sort: Spieletitel (Text) â†“</option>
              <option value="system_asc">Sort: System â†‘</option>
              <option value="system_desc">Sort: System â†“</option>
              <option value="source_asc">Sort: Quelle â†‘</option>
              <option value="source_desc">Sort: Quelle â†“</option>
              <option value="genre_asc">Sort: Genre â†‘</option>
              <option value="genre_desc">Sort: Genre â†“</option>
              <option value="dev_asc">Sort: Entwickler â†‘</option>
              <option value="dev_desc">Sort: Entwickler â†“</option>
              <option value="main_asc">Sort: Spielzeit (Main) â†‘</option>
              <option value="main_desc">Sort: Spielzeit (Main) â†“</option>
              <option value="meta_desc">Sort: Metascore â†“</option>
              <option value="meta_asc">Sort: Metascore â†‘</option>
              <option value="user_desc">Sort: Userwertung â†“</option>
              <option value="user_asc">Sort: Userwertung â†‘</option>
              <option value="life_desc">Sort: Lebenszeit % â†“</option>
              <option value="life_asc">Sort: Lebenszeit % â†‘</option>
            </select>

            <div class="btnIcon" id="openFilters" title="Filter & Sort">
              â˜°
            </div>
          </div>
        </div>

        <div class="stats" id="stats">Datei wÃ¤hlen â†’ Sheet wÃ¤hlen â†’ los</div>
      </div>
    </div>

    <div class="cards" id="cards"></div>
    <div class="sentinel" id="sentinel"></div>
  </div>

  <div class="fabTop" id="fabTop">
    <button id="btnTop">â†‘ Top</button>
  </div>

  <div class="drawerOverlay" id="overlay"></div>
  <div class="drawer" id="drawer">
    <div class="drawerHead">
      <div class="drawerTitle">Sortieren & Filtern</div>
      <button class="drawerClose" id="closeDrawer">SchlieÃŸen</button>
    </div>

    <div class="hint">
      <b>Suche:</b> normaler Text durchsucht Titel/Genre/Subgenre/Entwickler/Quelle. <br>
      <b>Query:</b> <code>id:12</code>, <code>system:ps5</code>, <code>source:digital</code>, <code>delisted</code>, <code>favorite</code>, <code>plat</code>, <code>completed</code>, <code>inprogress</code>, <code>unplayed</code> (auch kombinierbar).
    </div>

    <div class="chipGroupTitle">Status</div>
    <div class="pillRow" id="filterStatus"></div>

    <div class="chipGroupTitle">System</div>
    <div class="pillRow" id="filterSystem"></div>

    <div class="chipGroupTitle">Quelle</div>
    <div class="pillRow" id="filterSource"></div>

    <div class="chipGroupTitle">TrophÃ¤en</div>
    <div class="pillRow" id="filterTrophy"></div>

    <div class="pillRow" style="margin-top:14px;">
      <div class="chip" id="clearFilters"><span class="dot"></span>Filter lÃ¶schen</div>
    </div>
  </div>

  <script src="xlsx.full.min.js"></script>
  <script>
    // -----------------------------
    // State
    // -----------------------------
    const state = {
      wb: null,
      rows: [],
      sheetName: "",
      filtered: [],
      renderedCount: 0,
      batch: 50,
      // filters
      f: {
        status: new Set(),     // favorite, delisted
        system: new Set(),     // PS3/PS4/PS5/Vita
        source: new Set(),     // Digital, PS Plus, Retail-Disc
        trophy: new Set(),     // unplayed, inprogress, completed, plat, noplatform? (not used)
      },
      q: "",
      sort: "id_asc",
      expanded: new Set(),      // row id -> expanded
      subOpen: new Map(),       // row id -> {desc:true, extras:true, eggs:true}
    };

    const LS_KEY = "spieleliste_ui_v9";
    loadPersist();

    // -----------------------------
    // Utils
    // -----------------------------
    const norm = (s) => String(s ?? "").replace(/\u00A0/g," ").trim();
    const toLower = (s) => norm(s).toLowerCase();

    function parseNumberLoose(s){
      const t = norm(s);
      if(!t) return NaN;
      // handles "79 / 100" or "79/100"
      const m = t.match(/(-?\d+(?:[.,]\d+)?)/);
      if(!m) return NaN;
      return parseFloat(m[1].replace(",", "."));
    }

    function parseLifePercent(s){
      // Lebenszeit % can be "0.0012" or "0,0012"
      const t = norm(s);
      if(!t) return NaN;
      const m = t.match(/(-?\d+(?:[.,]\d+)?)/);
      if(!m) return NaN;
      return parseFloat(m[1].replace(",", "."));
    }

    function parsePlatformsFromSystem(raw){
      const t = norm(raw);
      if(!t) return [];
      const found = [];
      ["PS3","PS4","PS5","Vita"].forEach(p=>{
        if(new RegExp("\\b"+p+"\\b","i").test(t)) found.push(p);
      });
      return found;
    }

    function splitByPlatformBlocks(text){
      // returns array of blocks each containing a platform label and following content
      const t = String(text ?? "").replace(/\r/g,"\n");
      const re = /\b(PS3|PS4|PS5|Vita)\b/ig;
      const idx = [];
      let m;
      while((m = re.exec(t)) !== null){
        idx.push({i:m.index, p:m[1]});
      }
      if(!idx.length) return [];

      const blocks = [];
      for(let k=0;k<idx.length;k++){
        const start = idx[k].i;
        const end = (k+1<idx.length) ? idx[k+1].i : t.length;
        blocks.push(t.slice(start, end).trim());
      }
      return blocks;
    }

    function parseProgressCell(raw, systemPlatforms){
      // returns {PS4:{cur,total}}
      const out = {};
      const text = String(raw ?? "").replace(/\r/g, "\n").trim();
      if(!text) return out;

      const blocks = splitByPlatformBlocks(text);
      if(blocks.length){
        for(const block of blocks){
          const plat = (block.match(/\b(PS3|PS4|PS5|Vita)\b/i) || [])[1];
          const nums = block.match(/(\d+)\s*of\s*(\d+)/i);
          if(plat && nums){
            out[plat] = { cur: parseInt(nums[1],10), total: parseInt(nums[2],10) };
          }
        }
        return out;
      }

      // Singleplatform fallback: "18 of 18" (ohne Plattform)
      if(systemPlatforms && systemPlatforms.length === 1){
        const nums = text.match(/(\d+)\s*of\s*(\d+)/i);
        if(nums){
          out[systemPlatforms[0]] = { cur: parseInt(nums[1],10), total: parseInt(nums[2],10) };
        }
      }
      return out;
    }

    function parseCompletionCell(raw, systemPlatforms){
      // returns {PS4:"Completed"|"In Progress"}
      const out = {};
      const text = String(raw ?? "").replace(/\r/g, "\n").trim();
      if(!text) return out;

      const blocks = splitByPlatformBlocks(text);
      if(blocks.length){
        for(const block of blocks){
          const plat = (block.match(/\b(PS3|PS4|PS5|Vita)\b/i) || [])[1];
          if(!plat) continue;

          if(/\bcompleted\b/i.test(block)) out[plat] = "Completed";
          else if(/\bin\s*progress\b/i.test(block)) out[plat] = "In Progress";
        }
        return out;
      }

      // Singleplatform fallback: "Completed" / "In Progress"
      if(systemPlatforms && systemPlatforms.length === 1){
        if(/\bcompleted\b/i.test(text)) out[systemPlatforms[0]] = "Completed";
        else if(/\bin\s*progress\b/i.test(text)) out[systemPlatforms[0]] = "In Progress";
      }
      return out;
    }

    function parsePlatinumCell(raw, systemPlatforms){
      // returns {PS4:"Platinum"|"No Platinum"|"In Progress"}
      const out = {};
      const text = String(raw ?? "").replace(/\r/g, "\n").trim();
      if(!text) return out;

      const blocks = splitByPlatformBlocks(text);
      const readStatus = (s) => {
        // No Platinum muss vor Platinum kommen
        if(/\bno\b[\s\-]*\bplatinum\b/i.test(s)) return "No Platinum";
        if(/\bkein\b[\s\-]*\bplatin(um)?\b/i.test(s)) return "No Platinum";
        if(/\bplatinum\b/i.test(s)) return "Platinum";
        if(/\bin\s*progress\b/i.test(s)) return "In Progress";
        return null;
      };

      if(blocks.length){
        for(const block of blocks){
          const plat = (block.match(/\b(PS3|PS4|PS5|Vita)\b/i) || [])[1];
          if(!plat) continue;
          const st = readStatus(block);
          if(st) out[plat] = st;
        }
        return out;
      }

      // Singleplatform fallback
      if(systemPlatforms && systemPlatforms.length === 1){
        const st = readStatus(text);
        if(st) out[systemPlatforms[0]] = st;
      }
      return out;
    }

    function buildTrophyModel(row){
      const platforms = parsePlatformsFromSystem(row["System"]);
      const pMap = parseProgressCell(row["TrophÃ¤en Fortschritt"], platforms);
      const cMap = parseCompletionCell(row["100%"], platforms);
      const plMap = parsePlatinumCell(row["Platin"], platforms);

      // "started" pro Plattform: sobald irgendeine der drei Spalten fÃ¼r diese Plattform existiert
      const perPlatform = {};
      for(const p of platforms){
        const hasAny = !!pMap[p] || !!cMap[p] || !!plMap[p];
        perPlatform[p] = {
          started: hasAny,
          progress: pMap[p] || null,
          completion: cMap[p] || null,
          platinum: plMap[p] || null
        };
      }

      // Global summary badges:
      const anyStarted = Object.values(perPlatform).some(x=>x.started);

      const anyCompleted = Object.values(perPlatform).some(x=>x.completion === "Completed");
      const anyInProgress = Object.values(perPlatform).some(x=>x.completion === "In Progress" || x.platinum === "In Progress");
      const anyPlatinum = Object.values(perPlatform).some(x=>x.platinum === "Platinum");
      const anyNoPlatinum = anyStarted && Object.values(perPlatform).some(x=>x.platinum === "No Platinum");

      // "Kein Platin" global: gestartet UND nirgends Platinum UND mindestens ein "No Platinum" UND nirgends "In Progress" fÃ¼r Platin
      const allPlatKnown = anyStarted && Object.values(perPlatform).every(x=> !x.started || x.platinum !== null);
      const globalNoPlatinum = anyStarted && !anyPlatinum && anyNoPlatinum && allPlatKnown && !Object.values(perPlatform).some(x=>x.platinum === "In Progress");

      const completionState =
        !anyStarted ? "Unplayed" :
        anyCompleted ? "Completed" :
        "In Progress";

      const platinumState =
        !anyStarted ? "Unplayed" :
        anyPlatinum ? "Platinum" :
        globalNoPlatinum ? "No Platinum" :
        "In Progress";

      return { platforms, perPlatform, anyStarted, completionState, platinumState };
    }

    function isDelisted(row){
      // Availability column names may vary; you used "VerfÃ¼gbarkeit"
      const v = toLower(row["VerfÃ¼gbarkeit"]);
      return v.includes("delisted") || v.includes("deli");
    }

    function isFavorite(row){
      return toLower(row["Favorit"]) === "x";
    }

    function getTitle(row){
      return norm(row["Spieletitel"]) || norm(row["Spiel"]) || "â€”";
    }

    function getId(row){
      const v = norm(row["ID"]);
      const n = parseInt(v,10);
      return Number.isFinite(n) ? n : v;
    }

    function getSource(row){
      // now: Digital | PS Plus | Retail-Disc
      const s = norm(row["Quelle"]);
      return s || "â€”";
    }

    function storeLink(row){
      const s = norm(row["Store Link"]);
      if(!s || s === "-" ) return "";
      // if it is not a URL, just show text
      if(!/^https?:\/\//i.test(s)) return s;
      return s;
    }

    function formatField(val){
      const t = norm(val);
      return t ? t : "â€”";
    }

    function miniBadge(text, kind){
      const b = document.createElement("span");
      b.className = "badge";
      if(kind === "ok") b.classList.add("ok");
      if(kind === "warn") b.classList.add("warn");
      if(kind === "bad") b.classList.add("del");
      if(kind === "plat") b.classList.add("plat");
      if(kind === "sleep") b.classList.add("sleep");
      b.textContent = text;
      return b;
    }

    function localeTextCompare(a,b){
      // stable german-ish + numeric sorting
      return String(a).localeCompare(String(b), "de", { sensitivity:"base", numeric:true });
    }

    // -----------------------------
    // UI elements
    // -----------------------------
    const elFile = document.getElementById("file");
    const elSheet = document.getElementById("sheet");
    const elQ = document.getElementById("q");
    const elSort = document.getElementById("sort");
    const elCards = document.getElementById("cards");
    const elStats = document.getElementById("stats");
    const sentinel = document.getElementById("sentinel");

    const drawer = document.getElementById("drawer");
    const overlay = document.getElementById("overlay");
    const openFilters = document.getElementById("openFilters");
    const closeDrawer = document.getElementById("closeDrawer");
    const clearFilters = document.getElementById("clearFilters");

    const filterStatus = document.getElementById("filterStatus");
    const filterSystem = document.getElementById("filterSystem");
    const filterSource = document.getElementById("filterSource");
    const filterTrophy = document.getElementById("filterTrophy");

    const fabTop = document.getElementById("fabTop");
    const btnTop = document.getElementById("btnTop");

    // -----------------------------
    // Drawer open/close
    // -----------------------------
    function openDrawer(){
      overlay.classList.add("open");
      drawer.classList.add("open");
    }
    function closeDrawerFn(){
      drawer.classList.remove("open");
      overlay.classList.remove("open");
    }
    openFilters.addEventListener("click", openDrawer);
    closeDrawer.addEventListener("click", closeDrawerFn);
    overlay.addEventListener("click", closeDrawerFn);

    // -----------------------------
    // Top button
    // -----------------------------
    btnTop.addEventListener("click", ()=> window.scrollTo({top:0, behavior:"smooth"}));

    window.addEventListener("scroll", ()=>{
      fabTop.style.display = (window.scrollY > 800) ? "block" : "none";
    }, {passive:true});

    // -----------------------------
    // Infinite scroll
    // -----------------------------
    let io = null;
    function setupIO(){
      if(io) io.disconnect();
      io = new IntersectionObserver((entries)=>{
        for(const e of entries){
          if(e.isIntersecting){
            renderMore();
          }
        }
      }, { root:null, rootMargin:"1200px 0px 1200px 0px", threshold:0 });
      io.observe(sentinel);
    }

    // -----------------------------
    // Filters chips builder
    // -----------------------------
    function mkChip(text, key, set, kind){
      const c = document.createElement("div");
      c.className = "chip";
      if(kind) c.classList.add(kind);
      c.innerHTML = `<span class="dot"></span><span>${text}</span>`;
      const on = set.has(key);
      if(on) c.classList.add("on");
      c.addEventListener("click", ()=>{
        if(set.has(key)) set.delete(key); else set.add(key);
        savePersist();
        applyAll();
        // update chip visual
        rebuildFilterChips();
      });
      return c;
    }

    function rebuildFilterChips(){
      filterStatus.innerHTML = "";
      filterSystem.innerHTML = "";
      filterSource.innerHTML = "";
      filterTrophy.innerHTML = "";

      filterStatus.appendChild(mkChip("â­ Favorit", "favorite", state.f.status, null));
      filterStatus.appendChild(mkChip("Delisted", "delisted", state.f.status, "bad"));

      ["PS5","PS4","PS3","Vita"].forEach(p=>{
        filterSystem.appendChild(mkChip(p, p, state.f.system, null));
      });

      ["Digital","PS Plus","Retail-Disc"].forEach(s=>{
        filterSource.appendChild(mkChip(s, s, state.f.source, null));
      });

      filterTrophy.appendChild(mkChip("ðŸ’¤ Ungespielt", "unplayed", state.f.trophy, "sleep"));
      filterTrophy.appendChild(mkChip("â³ In Arbeit", "inprogress", state.f.trophy, "warn"));
      filterTrophy.appendChild(mkChip("âœ… 100% erreicht", "completed", state.f.trophy, "ok"));
      filterTrophy.appendChild(mkChip("ðŸ’Ž Platin erlangt", "plat", state.f.trophy, "plat"));
      filterTrophy.appendChild(mkChip("â€” Kein Platin", "nopl", state.f.trophy, null));
    }

    clearFilters.addEventListener("click", ()=>{
      state.f.status.clear();
      state.f.system.clear();
      state.f.source.clear();
      state.f.trophy.clear();
      savePersist();
      applyAll();
      rebuildFilterChips();
    });

    // -----------------------------
    // Persist (query/sort/filters)
    // -----------------------------
    function savePersist(){
      try{
        const payload = {
          q: state.q,
          sort: state.sort,
          f: {
            status:[...state.f.status],
            system:[...state.f.system],
            source:[...state.f.source],
            trophy:[...state.f.trophy],
          }
        };
        localStorage.setItem(LS_KEY, JSON.stringify(payload));
      }catch(e){}
    }

    function loadPersist(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return;
        const p = JSON.parse(raw);
        state.q = p.q ?? "";
        state.sort = p.sort ?? "id_asc";
        state.f.status = new Set(p.f?.status ?? []);
        state.f.system = new Set(p.f?.system ?? []);
        state.f.source = new Set(p.f?.source ?? []);
        state.f.trophy = new Set(p.f?.trophy ?? []);
      }catch(e){}
    }

    // -----------------------------
    // XLSX load
    // -----------------------------
    elFile.addEventListener("change", async (ev)=>{
      const f = ev.target.files?.[0];
      if(!f) return;
      const buf = await f.arrayBuffer();
      state.wb = XLSX.read(buf, {type:"array"});
      const names = state.wb.SheetNames || [];
      elSheet.innerHTML = `<option value="">Sheet auswÃ¤hlenâ€¦</option>` + names.map(n=>`<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join("");
      elSheet.disabled = false;

      // auto-select if previous was "Spieleliste Komplett"
      const prefer = names.find(n=> n.toLowerCase().includes("spieleliste komplett")) || names[0];
      elSheet.value = prefer;
      state.sheetName = prefer;
      loadSheet();
    });

    elSheet.addEventListener("change", ()=>{
      state.sheetName = elSheet.value;
      loadSheet();
    });

    function loadSheet(){
      if(!state.wb || !state.sheetName) return;
      const ws = state.wb.Sheets[state.sheetName];
      const json = XLSX.utils.sheet_to_json(ws, {defval:"", raw:false});
      state.rows = json;
      state.expanded.clear();
      state.subOpen.clear();
      applyAll(true);
      setupIO();
    }

    // -----------------------------
    // Search / Sort handlers
    // -----------------------------
    elQ.value = state.q;
    elSort.value = state.sort;

    elQ.addEventListener("input", ()=>{
      state.q = elQ.value;
      savePersist();
      applyAll(true);
    });
    elSort.addEventListener("change", ()=>{
      state.sort = elSort.value;
      savePersist();
      applyAll(true);
    });

    // -----------------------------
    // Filtering core
    // -----------------------------
    function applyAll(resetRender=false){
      if(!state.rows.length){
        elCards.innerHTML = "";
        elStats.textContent = "Keine Daten geladen.";
        return;
      }
      state.filtered = state.rows.filter(row => matchRow(row));
      sortRows(state.filtered);
      if(resetRender){
        state.renderedCount = 0;
        elCards.innerHTML = "";
      }
      renderMore(true);
      updateStats();
    }

    function matchRow(row){
      const title = getTitle(row);
      const id = getId(row);
      const sys = norm(row["System"]);
      const src = getSource(row);
      const del = isDelisted(row);
      const fav = isFavorite(row);

      const tModel = buildTrophyModel(row);

      // query parsing
      const q = norm(state.q);
      if(q){
        const parts = q.split(/\s+/).filter(Boolean);
        let ok = true;
        for(const p of parts){
          const pl = p.toLowerCase();

          if(pl.startsWith("id:")){
            const want = pl.slice(3).trim();
            if(String(id) !== want) ok = false;
          } else if(pl.startsWith("system:")){
            const want = pl.slice(7).trim();
            if(!toLower(sys).includes(want)) ok = false;
          } else if(pl.startsWith("source:")){
            const want = pl.slice(7).trim();
            if(!toLower(src).includes(want)) ok = false;
          } else if(pl === "delisted"){
            if(!del) ok = false;
          } else if(pl === "favorite" || pl === "fav"){
            if(!fav) ok = false;
          } else if(pl === "completed"){
            if(tModel.completionState !== "Completed") ok = false;
          } else if(pl === "inprogress"){
            if(tModel.completionState !== "In Progress" && tModel.platinumState !== "In Progress") ok = false;
          } else if(pl === "unplayed"){
            if(tModel.completionState !== "Unplayed") ok = false;
          } else if(pl === "plat"){
            if(tModel.platinumState !== "Platinum") ok = false;
          } else {
            // free text
            const hay = [
              title,
              norm(row["Genre"]),
              norm(row["Subgenre"]),
              norm(row["Entwickler"]),
              norm(row["Quelle"]),
              norm(row["Kurzbeschreibung"]),
            ].join(" ").toLowerCase();
            if(!hay.includes(pl)) ok = false;
          }

          if(!ok) break;
        }
        if(!ok) return false;
      }

      // chip filters
      if(state.f.status.has("delisted") && !del) return false;
      if(state.f.status.has("favorite") && !fav) return false;

      if(state.f.system.size){
        const plats = parsePlatformsFromSystem(sys);
        const hasAny = [...state.f.system].some(p=> plats.includes(p));
        if(!hasAny) return false;
      }

      if(state.f.source.size){
        if(!state.f.source.has(src)) return false;
      }

      if(state.f.trophy.size){
        // OR semantics among selected trophy filters
        let pass = false;
        for(const f of state.f.trophy){
          if(f === "unplayed" && tModel.completionState === "Unplayed") pass = true;
          if(f === "completed" && tModel.completionState === "Completed") pass = true;
          if(f === "inprogress" && (tModel.completionState === "In Progress" || tModel.platinumState === "In Progress")) pass = true;
          if(f === "plat" && tModel.platinumState === "Platinum") pass = true;
          if(f === "nopl" && tModel.platinumState === "No Platinum") pass = true;
        }
        if(!pass) return false;
      }

      return true;
    }

    function sortRows(arr){
      const s = state.sort;
      const dir = s.endsWith("_desc") ? -1 : 1;
      const key = s.replace(/_(asc|desc)$/,"");

      arr.sort((a,b)=>{
        let A, B;

        if(key === "id"){
          A = parseInt(norm(a["ID"]),10);
          B = parseInt(norm(b["ID"]),10);
          if(!Number.isFinite(A)) A = 1e18;
          if(!Number.isFinite(B)) B = 1e18;
          return (A-B)*dir;
        }

        if(key === "title"){
          A = getTitle(a);
          B = getTitle(b);
          return localeTextCompare(A,B)*dir;
        }

        if(key === "system"){
          A = norm(a["System"]);
          B = norm(b["System"]);
          return localeTextCompare(A,B)*dir;
        }

        if(key === "source"){
          A = getSource(a);
          B = getSource(b);
          return localeTextCompare(A,B)*dir;
        }

        if(key === "genre"){
          A = norm(a["Genre"]);
          B = norm(b["Genre"]);
          return localeTextCompare(A,B)*dir;
        }

        if(key === "dev"){
          A = norm(a["Entwickler"]);
          B = norm(b["Entwickler"]);
          return localeTextCompare(A,B)*dir;
        }

        if(key === "main"){
          A = parseNumberLoose(a["Spielzeit (Main)"]);
          B = parseNumberLoose(b["Spielzeit (Main)"]);
          if(!Number.isFinite(A)) A = (dir>0? 1e18 : -1e18);
          if(!Number.isFinite(B)) B = (dir>0? 1e18 : -1e18);
          return (A-B)*dir;
        }

        if(key === "meta"){
          A = parseNumberLoose(a["Metascore"]);
          B = parseNumberLoose(b["Metascore"]);
          if(!Number.isFinite(A)) A = -1;
          if(!Number.isFinite(B)) B = -1;
          return (A-B)*dir;
        }

        if(key === "user"){
          A = parseNumberLoose(a["Userwertung"]);
          B = parseNumberLoose(b["Userwertung"]);
          if(!Number.isFinite(A)) A = -1;
          if(!Number.isFinite(B)) B = -1;
          return (A-B)*dir;
        }

        if(key === "life"){
          A = parseLifePercent(a["% Lebenszeit"]);
          B = parseLifePercent(b["% Lebenszeit"]);
          if(!Number.isFinite(A)) A = -1;
          if(!Number.isFinite(B)) B = -1;
          return (A-B)*dir;
        }

        return 0;
      });
    }

    // -----------------------------
    // Rendering
    // -----------------------------
    function renderMore(force=false){
      if(!state.filtered.length) {
        if(force) elCards.innerHTML = "";
        updateStats();
        return;
      }
      const next = Math.min(state.filtered.length, state.renderedCount + state.batch);
      if(next <= state.renderedCount && !force) return;

      const frag = document.createDocumentFragment();
      for(let i=state.renderedCount;i<next;i++){
        frag.appendChild(cardEl(state.filtered[i]));
      }
      elCards.appendChild(frag);
      state.renderedCount = next;
      updateStats();
    }

    function updateStats(){
      const total = state.rows.length;
      const hits = state.filtered.length;
      const shown = state.renderedCount;

      if(!state.rows.length){
        elStats.textContent = "Datei wÃ¤hlen â†’ Sheet wÃ¤hlen â†’ los";
        return;
      }
      elStats.textContent = `Treffer: ${hits} Â· angezeigt: ${shown}/${hits} Â· Gesamt: ${total}`;
    }

    function cardEl(row){
      const id = getId(row);
      const title = getTitle(row);
      const sys = norm(row["System"]);
      const plats = parsePlatformsFromSystem(sys);
      const src = getSource(row);
      const del = isDelisted(row);
      const fav = isFavorite(row);

      const trophy = buildTrophyModel(row);

      const card = document.createElement("div");
      card.className = "card";

      const head = document.createElement("div");
      head.className = "cardHead";

      const left = document.createElement("div");
      const t = document.createElement("div");
      t.className = "title";
      t.textContent = title;
      left.appendChild(t);

      head.appendChild(left);

      const badgeCol = document.createElement("div");
      badgeCol.className = "badgeCol";

      if(fav) badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge fav", textContent:"â­ Favorit"}));

      // BONUS: Platin/Completion als saubere ZustÃ¤nde
      // Completion badge
      if(trophy.completionState === "Completed"){
        badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge ok", textContent:"âœ… 100% erreicht"}));
      } else if(trophy.completionState === "In Progress"){
        badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge warn", textContent:"â³ In Arbeit"}));
      } else {
        // unplayed: nicht im Header nÃ¶tig (du wolltest ungespielt eher im Detail) â€“ aber ok wenn du willst:
        // badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge sleep", textContent:"ðŸ’¤ Ungespielt"}));
      }

      // Platinum badge (inkl. Kein Platin)
      if(trophy.platinumState === "Platinum"){
        badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge plat", textContent:"ðŸ’Ž Platin erlangt"}));
      } else if(trophy.platinumState === "No Platinum"){
        badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge", textContent:"â€” Kein Platin"}));
      } else if(trophy.platinumState === "In Progress" && trophy.anyStarted){
        badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge warn", textContent:"â³ Platin in Arbeit"}));
      }

      if(del) badgeCol.appendChild(Object.assign(document.createElement("span"), {className:"badge del", textContent:"Delisted"}));

      head.appendChild(badgeCol);
      card.appendChild(head);

      // ID + System badges row
      const subBadges = document.createElement("div");
      subBadges.className = "subBadges";

      const idPill = document.createElement("span");
      idPill.className = "idPill";
      idPill.textContent = `ID ${id}`;
      subBadges.appendChild(idPill);

      // system badges
      plats.forEach(p=>{
        const s = document.createElement("span");
        s.className = "tag sys";
        s.textContent = p;
        subBadges.appendChild(s);
      });

      // availability
      const avail = formatField(row["VerfÃ¼gbarkeit"]);
      const av = document.createElement("span");
      av.className = "tag avail";
      av.textContent = avail;
      subBadges.appendChild(av);

      card.appendChild(subBadges);

      // Reduced view fields
      const kv = document.createElement("div");
      kv.className = "kv";

      // show exactly: Genre, Entwickler, Spielzeit, Metascore, Userwertung
      addKV(kv, "Genre", formatField(row["Genre"]));
      addKV(kv, "Entwickler", formatField(row["Entwickler"]));

      // Spielzeit compact: "Main / 100%"
      const main = formatField(row["Spielzeit (Main)"]);
      const h100 = formatField(row["Spielzeit (100%)"]);
      addKV(kv, "Spielzeit", `${main} / ${h100}`.replace("â€” / â€”","â€”"));

      addKV(kv, "Metascore", formatField(row["Metascore"]), true);
      addKV(kv, "Userwertung", formatField(row["Userwertung"]), true);

      card.appendChild(kv);

      // Details toggle
      const toggle = document.createElement("div");
      toggle.className = "detailsToggle";
      const isOpen = state.expanded.has(String(id));
      toggle.textContent = isOpen ? "â–¼ Weniger Details" : "â–¶ Mehr Details";
      toggle.addEventListener("click", ()=>{
        if(state.expanded.has(String(id))) state.expanded.delete(String(id));
        else state.expanded.add(String(id));
        // rerender full list slice for simplicity (still fast with 1200)
        rerenderAllVisible();
      });
      card.appendChild(toggle);

      if(isOpen){
        // DESCRIPTION
        card.appendChild(sectionCollapsible(
          String(id), "BESCHREIBUNG", "Kurzbeschreibung anzeigen",
          formatField(row["Kurzbeschreibung"]),
          "desc"
        ));

        // STORE
        const storeSec = document.createElement("div");
        storeSec.className = "section";
        storeSec.appendChild(secTitle("STORE"));

        const kv2 = document.createElement("div");
        kv2.className = "kv";
        addKV(kv2, "Quelle", formatField(row["Quelle"]));
        addKV(kv2, "Store", renderStoreLink(row));
        addKV(kv2, "VerfÃ¼gbarkeit", formatField(row["VerfÃ¼gbarkeit"]));
        storeSec.appendChild(kv2);
        card.appendChild(storeSec);

        // EXTRAS
        const extras = document.createElement("div");
        extras.className = "section";
        extras.appendChild(secTitle("EXTRAS"));
        extras.appendChild(subCollapsible(String(id), "Besonderheiten anzeigen", formatField(row["Besonderheiten"]), "extras"));
        extras.appendChild(subCollapsible(String(id), "Eastereggs anzeigen", formatField(row["Eastereggs"]), "eggs"));
        card.appendChild(extras);

        // TROPHÃ„EN
        const tro = document.createElement("div");
        tro.className = "section";
        tro.appendChild(secTitle("TROPHÃ„EN"));

        const tg = document.createElement("div");
        tg.className = "trophyGrid";

        // Per platform: always show system platforms and fill missing as Ungespielt
        for(const p of trophy.platforms){
          const platChip = document.createElement("div");
          platChip.className = "platChip";
          platChip.textContent = p;

          const info = trophy.perPlatform[p] || {started:false, progress:null, completion:null, platinum:null};

          const right = document.createElement("div");
          right.className = "tLines";

          // Line builder
          const linesWrap = document.createElement("div");
          linesWrap.className = "tLines";

          // Fortschritt line + optional bar
          linesWrap.appendChild(tLine("Fortschritt", (()=> {
            if(!info.started) return miniBadge("ðŸ’¤ Ungespielt","sleep");
            if(info.progress && Number.isFinite(info.progress.cur) && Number.isFinite(info.progress.total) && info.progress.total>0){
              return miniBadge(`${String(info.progress.cur).padStart(2,"0")} of ${info.progress.total}`,"");
            }
            return miniBadge("â€”","");
          })()));

          // completion line
          linesWrap.appendChild(tLine("Komplettion", (()=> {
            if(!info.started) return miniBadge("ðŸ’¤ Ungespielt","sleep");
            if(info.completion === "Completed") return miniBadge("âœ… 100% erreicht","ok");
            if(info.completion === "In Progress") return miniBadge("â³ In Arbeit","warn");
            return miniBadge("â³ In Arbeit","warn");
          })()));

          // platinum line
          linesWrap.appendChild(tLine("Platin", (()=> {
            if(!info.started) return miniBadge("ðŸ’¤ Ungespielt","sleep");
            if(info.platinum === "Platinum") return miniBadge("ðŸ’Ž Platin erlangt","plat");
            if(info.platinum === "No Platinum") return miniBadge("â€” Kein Platin","");
            if(info.platinum === "In Progress") return miniBadge("â³ In Arbeit","warn");
            return miniBadge("â³ In Arbeit","warn");
          })()));

          right.appendChild(linesWrap);

          // progress bar only if numbers exist
          if(info.started && info.progress && Number.isFinite(info.progress.cur) && Number.isFinite(info.progress.total) && info.progress.total>0){
            const pct = Math.max(0, Math.min(100, (info.progress.cur/info.progress.total)*100));
            const bar = document.createElement("div");
            bar.className = "bar";
            const fill = document.createElement("i");
            fill.style.width = pct.toFixed(1) + "%";
            bar.appendChild(fill);

            const note = document.createElement("div");
            note.className = "barNote";
            note.textContent = `${pct.toFixed(0)}% (${info.progress.cur}/${info.progress.total})`;

            right.appendChild(bar);
            right.appendChild(note);
          }

          tg.appendChild(platChip);
          tg.appendChild(right);
        }

        tro.appendChild(tg);
        card.appendChild(tro);

        // HUMORSTATISTIK
        const hu = document.createElement("div");
        hu.className = "section";
        hu.appendChild(secTitle("HUMORSTATISTIK"));

        const kv3 = document.createElement("div");
        kv3.className = "kv";
        addKV(kv3, "Gesamtstunden", formatField(row["Gesamtstunden (Humorstatistik)"]), true);
        addKV(kv3, "% Lebenszeit", formatField(row["% Lebenszeit (Humorstatistik)"]), true);
        addKV(kv3, "Jahre", formatField(row["Jahre (Humorstatistik)"]), true);

        hu.appendChild(kv3);
        card.appendChild(hu);
      }

      return card;
    }

    function addKV(kv, k, v, mono=false){
      const kk = document.createElement("div");
      kk.className = "k";
      kk.textContent = k;

      const vv = document.createElement("div");
      vv.className = "v" + (mono ? " mono" : "");
      if(v instanceof Node){
        vv.appendChild(v);
      } else {
        vv.textContent = String(v);
      }
      kv.appendChild(kk);
      kv.appendChild(vv);
    }

    function secTitle(s){
      const d = document.createElement("div");
      d.className = "secTitle";
      d.textContent = s;
      return d;
    }

    function tLine(label, contentEl){
      const wrap = document.createElement("div");
      wrap.className = "tLine";
      const l = document.createElement("div");
      l.className = "mutedSmall";
      l.textContent = label;
      wrap.appendChild(l);
      wrap.appendChild(contentEl);
      return wrap;
    }

    function renderStoreLink(row){
      const url = storeLink(row);
      if(!url || url === "â€”"){
        const span = document.createElement("span");
        span.textContent = "â€”";
        return span;
      }
      if(/^https?:\/\//i.test(url)){
        const a = document.createElement("a");
        a.href = url;
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = "Store Link";
        a.title = url;
        return a;
      }
      // plain text
      const span = document.createElement("span");
      span.textContent = url;
      return span;
    }

    function sectionCollapsible(rowId, secName, toggleText, bodyText, key){
      const sec = document.createElement("div");
      sec.className = "section";
      sec.appendChild(secTitle(secName));
      sec.appendChild(subCollapsible(rowId, toggleText, bodyText, key, true));
      return sec;
    }

    function subCollapsible(rowId, label, body, key, withGap=false){
      const box = document.createElement("div");
      const open = !!(state.subOpen.get(rowId)?.[key]);

      const t = document.createElement("div");
      t.className = "subToggle";
      t.innerHTML = `<span>${open ? "â–¼" : "â–¶"} ${escapeHtml(label)}</span><span class="mutedSmall">${open ? " " : ""}</span>`;
      t.addEventListener("click", ()=>{
        const cur = state.subOpen.get(rowId) || {};
        cur[key] = !cur[key];
        state.subOpen.set(rowId, cur);
        rerenderAllVisible();
      });

      const b = document.createElement("div");
      b.className = "subBody";
      b.style.display = open ? "block" : "none";
      if(withGap && open){
        b.style.marginTop = "6px";
      }
      b.textContent = body;

      box.appendChild(t);
      box.appendChild(b);
      return box;
    }

    function rerenderAllVisible(){
      // Rebuild currently shown list (keeps infinite feel, still lightweight at 1200)
      const keep = state.renderedCount;
      elCards.innerHTML = "";
      state.renderedCount = 0;
      const next = Math.min(state.filtered.length, keep);
      const frag = document.createDocumentFragment();
      for(let i=0;i<next;i++){
        frag.appendChild(cardEl(state.filtered[i]));
      }
      elCards.appendChild(frag);
      state.renderedCount = next;
      updateStats();
    }

    function escapeHtml(s){
      return String(s ?? "").replace(/[&<>"']/g, c=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // -----------------------------
    // Init chips + IO
    // -----------------------------
    rebuildFilterChips();
    setupIO();

    // apply persisted controls
    elQ.value = state.q || "";
    elSort.value = state.sort || "id_asc";
  </script>
</body>
</html>