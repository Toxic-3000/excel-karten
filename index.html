<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spieleliste</title>

  <!-- SheetJS (xlsx) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#101828;
      --muted:#667085;
      --line:#eaecf0;
      --chip:#f2f4f7;

      --blue:#1d4ed8;
      --blueBg:#eff6ff;
      --blueBd:#bfdbfe;

      --green:#166534;
      --greenBg:#ecfdf5;
      --greenBd:#bbf7d0;

      --orange:#9a3412;       /* dezenter als knallrot */
      --orangeBg:#fff7ed;
      --orangeBd:#fed7aa;

      --gray:#344054;
      --grayBg:#f2f4f7;
      --grayBd:#e4e7ec;

      --danger:#b42318;
      --dangerBg:#fef3f2;
      --dangerBd:#fecdca;

      --shadow: 0 8px 30px rgba(16,24,40,.08);
      --radius: 18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:var(--bg);
    }
    a{color:var(--blue); text-decoration:none}
    a:hover{text-decoration:underline}

    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 18px 14px 80px;
    }

    h1{
      margin: 6px 0 14px;
      font-size: 42px;
      letter-spacing: -0.02em;
    }

    /* Header / Controls */
    .controlsCard{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      position: sticky;
      top: 0;
      z-index: 20;
      transition: transform .22s ease;
    }
    .controlsCard.isHidden{
      transform: translateY(-92px);
    }

    .row{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:8px;
      flex: 1 1 260px;
      min-width: 240px;
    }
    .label{
      font-size: 13px;
      color: var(--muted);
    }
    .input, select{
      width:100%;
      padding: 12px 12px;
      border: 1px solid var(--line);
      border-radius: 14px;
      font-size: 16px;
      background: #fff;
      outline: none;
    }
    .input:focus, select:focus{
      border-color:#c7d2fe;
      box-shadow: 0 0 0 4px rgba(99,102,241,.12);
    }

    .miniRow{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
    }
    .miniRow .field{flex: 1 1 260px}

    .menuBtn{
      width: 52px;
      height: 48px;
      border-radius: 14px;
      border:1px solid var(--line);
      background: #eef2ff;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 22px;
      cursor:pointer;
      user-select:none;
      flex: 0 0 auto;
    }

    .stats{
      margin-top: 10px;
      color: var(--muted);
      font-size: 15px;
    }

    /* Cards */
    .list{
      margin-top: 14px;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      position: relative;
      overflow: hidden;
    }

    .cardHeader{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
    }

    .title{
      font-size: 30px;
      line-height: 1.08;
      font-weight: 800;
      margin:0;
      letter-spacing: -0.01em;
    }

    .badges{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap: 8px;
      flex: 0 0 auto;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      min-width: min(170px, 54vw);
      padding: 9px 12px;
      border-radius: 999px;
      font-weight: 700;
      line-height:1;
      white-space: nowrap;
      border: 1px solid transparent;
      user-select:none;
    }
    .badge--fav{ background:#fff7ed; border-color:#fed7aa; color:#9a3412; }
    .badge--delisted{ background: var(--dangerBg); border-color: var(--dangerBd); color: var(--danger); }

    .badge--progress{ background: var(--orangeBg); border-color: var(--orangeBd); color: var(--orange); }
    .badge--unplayed{ background: var(--grayBg); border-color: var(--grayBd); color: var(--gray); }

    .badge--done{ background: var(--greenBg); border-color: var(--greenBd); color: var(--green); }
    .badge--plat{ background: var(--blueBg); border-color: var(--blueBd); color: var(--blue); }
    .badge--nopl{ background: #ffffff; border-color: var(--line); color: var(--gray); }

    .chipRow{
      display:flex;
      gap:10px;
      margin-top: 12px;
      align-items:center;
      flex-wrap:wrap;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--line);
    }

    .chip{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 12px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--line);
      color: var(--text);
      font-weight: 700;
      user-select:none;
    }
    .chip.id{
      background: #1e3a8a;
      color:#fff;
      border-color: rgba(255,255,255,.18);
    }

    .grid{
      display:grid;
      grid-template-columns: 180px 1fr;
      gap: 10px 14px;
      margin-top: 14px;
      align-items:start;
    }
    .k{ color: var(--muted); font-weight: 600; }
    .v{ color: var(--text); font-weight: 650; }

    .toggle{
      margin-top: 14px;
      display:flex;
      align-items:center;
      gap: 10px;
      color:#1f2a37;
      font-weight: 800;
      font-size: 18px;
      cursor:pointer;
      user-select:none;
    }
    .toggle .arrow{ color:#1f2a37; }

    .details{
      margin-top: 14px;
      border-top: 1px solid var(--line);
      padding-top: 14px;
      display:none;
    }
    .card.isOpen .details{ display:block; }

    .section{
      padding: 12px 0;
      border-bottom: 1px solid var(--line);
    }
    .section:last-child{ border-bottom:none; }
    .sectionTitle{
      color: var(--muted);
      font-weight: 900;
      letter-spacing: .12em;
      font-size: 12px;
      margin: 0 0 10px;
    }

    .subToggle{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 0;
      cursor:pointer;
      user-select:none;
      font-weight: 900;
      font-size: 20px;
    }
    .subBody{
      display:none;
      padding-top: 8px;
      color: var(--text);
      font-weight: 600;
      line-height: 1.5;
      white-space: pre-wrap;
    }
    .subWrap.isOpen .subBody{ display:block; }

    /* Trophy layout */
    .tRow{
      display:grid;
      grid-template-columns: 74px 1fr;
      gap: 10px 12px;
      align-items:center;
      margin: 10px 0;
    }
    .platTag{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 7px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--line);
      font-weight: 900;
      width: 74px;
      color:#111827;
    }
    .barWrap{
      display:flex;
      flex-direction:column;
      gap: 7px;
    }
    .barTop{
      display:flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      font-weight: 900;
    }
    .barTop .pct{ color: var(--muted); font-weight: 800; }
    .bar{
      height: 12px;
      border-radius: 999px;
      background: #e5e7eb;
      overflow:hidden;
      border: 1px solid #d1d5db;
    }
    .bar > div{
      height: 100%;
      width: 0%;
      background: #1e40af;
      border-radius: 999px;
    }
    .tBadges{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      margin-top: 8px;
    }
    .tiny{
      font-size: 13px;
      font-weight: 800;
      padding: 7px 10px;
      min-width: unset;
    }

    /* Floating Top button */
    .floatTop{
      position: fixed;
      right: 14px;
      bottom: 16px;
      z-index: 30;
      display:none;
      align-items:center;
      justify-content:center;
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 999px;
      padding: 12px 14px;
      box-shadow: var(--shadow);
      font-weight: 900;
      cursor:pointer;
      user-select:none;
    }
    .floatTop.show{ display:flex; }

    /* Modal */
    .modalBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(16,24,40,.45);
      display:none;
      z-index: 50;
      padding: 18px 14px;
      overflow:auto;
    }
    .modalBackdrop.show{ display:block; }
    .modal{
      max-width: 860px;
      margin: 0 auto;
      background: #fff;
      border-radius: 22px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }
    .modalHead h2{
      margin:0;
      font-size: 26px;
      letter-spacing: -0.01em;
    }
    .closeBtn{
      border: 1px solid var(--line);
      background:#fff;
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 900;
      cursor:pointer;
    }

    .help{
      background:#f2f4f7;
      border: 1px dashed #d0d5dd;
      border-radius: 14px;
      padding: 12px;
      color:#344054;
      font-weight: 700;
      line-height: 1.35;
      margin: 10px 0 14px;
      white-space: pre-wrap;
    }
    .fGroup{
      margin: 14px 0;
    }
    .fTitle{
      color: var(--muted);
      font-weight: 900;
      margin-bottom: 8px;
    }
    .pillGrid{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #fff;
      font-weight: 900;
      cursor:pointer;
      user-select:none;
    }
    .dot{
      width: 10px; height:10px; border-radius:999px;
      background:#9ca3af;
    }
    .pill.on{ background: #eef2ff; border-color:#c7d2fe; }
    .pill.on .dot{ background:#1d4ed8; }

    .pill.gray.on{ background: #f2f4f7; border-color:#d0d5dd; }
    .pill.gray.on .dot{ background:#475467; }

    .pill.green.on{ background: var(--greenBg); border-color: var(--greenBd); }
    .pill.green.on .dot{ background: #16a34a; }

    .pill.blue.on{ background: var(--blueBg); border-color: var(--blueBd); }
    .pill.blue.on .dot{ background: #2563eb; }

    .pill.orange.on{ background: var(--orangeBg); border-color: var(--orangeBd); }
    .pill.orange.on .dot{ background: #d97706; }

    .pill.red.on{ background: var(--dangerBg); border-color: var(--dangerBd); }
    .pill.red.on .dot{ background: #ef4444; }

    .actionsRow{
      margin-top: 16px;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
    }
    .btn{
      border: 1px solid var(--line);
      background:#fff;
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 900;
      cursor:pointer;
    }
    .btn.primary{
      background:#111827;
      color:#fff;
      border-color:#111827;
    }

    @media (max-width: 640px){
      h1{ font-size: 36px; }
      .grid{ grid-template-columns: 150px 1fr; }
      .title{ font-size: 28px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>Spieleliste</h1>

    <div id="controls" class="controlsCard">
      <div class="row">
        <div class="field">
          <div class="label">Datei ausw√§hlen (XLSX)</div>
          <input id="file" class="input" type="file" accept=".xlsx,.xls" />
        </div>
        <div class="field">
          <div class="label">Sheet</div>
          <select id="sheet" disabled>
            <option value="">Bitte zuerst eine Datei laden‚Ä¶</option>
          </select>
        </div>
      </div>

      <div class="miniRow" style="margin-top:12px">
        <div class="field">
          <input id="search" class="input" placeholder="Suche‚Ä¶ (z.B. id:643 delisted favorite plat completed inprogress unplayed source:digital system:ps5)" />
        </div>

        <div class="field" style="flex: 0 0 290px; min-width: 240px;">
          <select id="sort">
            <!-- wird per JS gef√ºllt -->
          </select>
        </div>

        <div class="menuBtn" id="openMenu" title="Sortieren & Filtern">‚â°</div>
      </div>

      <div id="stats" class="stats">Noch keine Datei geladen.</div>
    </div>

    <div id="list" class="list"></div>
    <div id="sentinel" style="height: 1px;"></div>

    <div id="topBtn" class="floatTop">‚Üë Top</div>
  </div>

  <!-- Modal -->
  <div id="backdrop" class="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Sortieren und Filtern">
      <div class="modalHead">
        <h2>Sortieren & Filtern</h2>
        <button class="closeBtn" id="closeMenu">Schlie√üen</button>
      </div>

      <div class="help">
Suche: normaler Text durchsucht Titel/Genre/Subgenre/Entwickler/Quelle.
Query:
- id:12
- system:ps5
- source:digital | source:psplus | source:retail
- delisted, favorite
- plat, completed, inprogress, unplayed, nopl
(auch kombinierbar)
      </div>

      <div class="fGroup">
        <div class="fTitle">Status</div>
        <div class="pillGrid" id="fgStatus"></div>
      </div>

      <div class="fGroup">
        <div class="fTitle">System</div>
        <div class="pillGrid" id="fgSystem"></div>
      </div>

      <div class="fGroup">
        <div class="fTitle">Quelle</div>
        <div class="pillGrid" id="fgSource"></div>
      </div>

      <div class="fGroup">
        <div class="fTitle">Troph√§en</div>
        <div class="pillGrid" id="fgTrophy"></div>
      </div>

      <div class="actionsRow">
        <button class="btn" id="clearFilters">Filter l√∂schen</button>
        <button class="btn primary" id="applyMenu">√úbernehmen</button>
      </div>
    </div>
  </div>

<script>
(() => {
  /***********************
   * Robust state (versioned)
   ***********************/
  const LS_KEY = "spieleliste_ui_state_v4";
  const STATE_VERSION = 4;

  const defaultState = () => ({
    v: STATE_VERSION,
    sheetName: "",
    search: "",
    sortKey: "id",
    sortDir: "asc",
    filters: {
      favorite: false,
      delisted: false,
      system: new Set(),      // PS3/PS4/PS5/Vita
      source: new Set(),      // Digital/PS Plus/Retail-Disc
      trophy: new Set(),      // unplayed/inprogress/completed/plat/nopl
    }
  });

  let state = defaultState();

  function saveState(){
    const safe = {
      v: state.v,
      sheetName: state.sheetName,
      search: state.search,
      sortKey: state.sortKey,
      sortDir: state.sortDir,
      filters: {
        favorite: state.filters.favorite,
        delisted: state.filters.delisted,
        system: Array.from(state.filters.system),
        source: Array.from(state.filters.source),
        trophy: Array.from(state.filters.trophy),
      }
    };
    localStorage.setItem(LS_KEY, JSON.stringify(safe));
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(!parsed || parsed.v !== STATE_VERSION) return; // version mismatch => ignore old broken state
      state.sheetName = parsed.sheetName || "";
      state.search = parsed.search || "";
      state.sortKey = parsed.sortKey || "id";
      state.sortDir = parsed.sortDir || "asc";
      state.filters.favorite = !!parsed.filters?.favorite;
      state.filters.delisted = !!parsed.filters?.delisted;
      state.filters.system = new Set(parsed.filters?.system || []);
      state.filters.source = new Set(parsed.filters?.source || []);
      state.filters.trophy = new Set(parsed.filters?.trophy || []);
    }catch(e){
      // ignore broken storage
    }
  }

  loadState();

  /***********************
   * Helpers
   ***********************/
  const $ = (id) => document.getElementById(id);
  const norm = (v) => String(v ?? "").replace(/\u00A0/g," ").trim();
  const lower = (v) => norm(v).toLowerCase();

  function splitSystems(sys){
    // "PS4, PS5" / "PS3, Vita" / "PS4" ...
    const s = norm(sys);
    if(!s) return [];
    return s.split(",").map(x => x.trim()).filter(Boolean);
  }

  function parsePairsByPlatform(cell){
    // cell like: "PS4\n18 of 18  PS5\n17 of 18" or "PS4 Completed\nPS5 In Progress"
    // We normalize newlines/spaces and then parse platform blocks.
    const txt = norm(cell);
    if(!txt) return [];

    const cleaned = txt
      .replace(/\r/g, "\n")
      .replace(/\t/g, " ")
      .replace(/[ ]{2,}/g, " ")
      .replace(/\n{2,}/g, "\n")
      .trim();

    // Split into tokens but preserve platform + value
    // Strategy: find occurrences of (PS3|PS4|PS5|Vita) and take following text until next platform.
    const re = /(PS3|PS4|PS5|Vita)\s*\n?\s*/gi;
    const parts = [];
    let m, idxs = [];
    while((m = re.exec(cleaned)) !== null){
      idxs.push({ i: m.index, plat: m[1].toUpperCase() });
    }
    if(idxs.length === 0) return [];

    for(let i=0;i<idxs.length;i++){
      const start = idxs[i].i;
      const end = (i+1<idxs.length) ? idxs[i+1].i : cleaned.length;
      const plat = idxs[i].plat;
      const chunk = cleaned.slice(start, end);

      // remove platform label
      const value = chunk.replace(new RegExp("^" + plat + "\\s*\\n?\\s*", "i"), "").trim();
      if(value) parts.push({ plat, value });
    }
    return parts;
  }

  function parseProgressValue(value){
    // "18 of 18"
    const v = norm(value);
    const m = v.match(/(\d+)\s*of\s*(\d+)/i);
    if(!m) return null;
    const a = parseInt(m[1],10), b = parseInt(m[2],10);
    if(!Number.isFinite(a) || !Number.isFinite(b) || b<=0) return null;
    return { cur:a, total:b, pct: Math.max(0, Math.min(100, Math.round((a/b)*100))) };
  }

  function parse100Token(value){
    // "Completed" / "In Progress"
    const t = lower(value);
    if(!t) return "";
    if(t.includes("completed")) return "COMPLETED";
    if(t.includes("in progress")) return "IN_PROGRESS";
    return "";
  }

  function parsePlatinumToken(value){
    // IMPORTANT: No-Platinum-Title FIRST
    const t = lower(value);
    if(!t) return "";
    if(t.includes("no-platinum-title") || /no[\s-]*platinum/.test(t)) return "NO_PLAT";
    if(t.includes("platinum")) return "PLAT";
    if(t.includes("in progress")) return "IN_PROGRESS";
    return "";
  }

  function parseMetascore(v){
    const s = norm(v);
    const m = s.match(/(\d+(?:[.,]\d+)?)\s*\/\s*100/);
    if(m) return parseFloat(m[1].replace(",", "."));
    const n = parseFloat(s.replace(",", "."));
    return Number.isFinite(n) ? n : null;
  }

  function parseLifePct(v){
    const n = parseFloat(norm(v).replace(",", "."));
    return Number.isFinite(n) ? n : null;
  }

  function textForSortTitle(title){
    // stable alpha sort: ignore leading articles, normalize whitespace
    let t = norm(title);
    t = t.replace(/^(the|a|an)\s+/i, ""); // optional
    return t;
  }

  function stableCompare(a, b, mode){
    // mode: "text" uses localeCompare; fallback by id
    if(mode === "text"){
      const A = textForSortTitle(a).toLocaleLowerCase("de-DE");
      const B = textForSortTitle(b).toLocaleLowerCase("de-DE");
      const c = A.localeCompare(B, "de-DE", { sensitivity:"base", numeric:true });
      return c;
    }
    if(mode === "num"){
      const A = (a==null ? Number.NEGATIVE_INFINITY : a);
      const B = (b==null ? Number.NEGATIVE_INFINITY : b);
      if(A < B) return -1;
      if(A > B) return 1;
      return 0;
    }
    // default
    return String(a).localeCompare(String(b), "de-DE", { sensitivity:"base", numeric:true });
  }

  /***********************
   * Column mapping (your sheet)
   ***********************/
  const COL = {
    id: "ID",
    title: "Spieletitel",
    system: "System",
    source: "Quelle",
    genre: "Genre",
    dev: "Entwickler",
    subgenre: "Subgenre",
    desc: "Kurzbeschreibung",
    store: "Store Link",
    avail: "Verf√ºgbarkeit",
    meta: "Metascore",
    user: "Userwertung",
    main: "Spielzeit (Main)",
    hundred: "Spielzeit (100%)",
    fav: "Favorit",
    special: "Besonderheiten",
    eggs: "Eastereggs",
    trophiesProgress: "Troph√§en Fortschritt",
    trophies100: "100%",
    trophiesPlat: "Platin",
    humorHours: "Gesamtstunden (Humorstatistik)",
    humorLife: "% Lebenszeit (Humorstatistik)",
    humorYears: "Jahre (Humorstatistik)",
  };

  /***********************
   * Data
   ***********************/
  let workbook = null;
  let rows = [];
  let filtered = [];
  let renderCount = 0;
  const PAGE_SIZE = 40;

  function setStats(){
    const shown = Math.min(renderCount, filtered.length);
    $("stats").textContent = `Treffer: ${filtered.length} ¬∑ angezeigt: ${shown}/${filtered.length} ¬∑ Gesamt: ${rows.length}`;
  }

  /***********************
   * Sort options (limited, in your order)
   ***********************/
  const SORTS = [
    { key:"id",        label:"Sort: ID", mode:"num"  },
    { key:"title",     label:"Sort: Spieletitel (Text)", mode:"text" },
    { key:"system",    label:"Sort: System", mode:"text" },
    { key:"source",    label:"Sort: Quelle", mode:"text" },
    { key:"genre",     label:"Sort: Genre", mode:"text" },
    { key:"dev",       label:"Sort: Entwickler", mode:"text" },
    { key:"main",      label:"Sort: Spielzeit (Main)", mode:"num" },
    { key:"meta",      label:"Sort: Metascore", mode:"num" },
    { key:"user",      label:"Sort: Userwertung", mode:"num" },
    { key:"life",      label:"Sort: Lebenszeit %", mode:"num" },
  ];

  function fillSortSelect(){
    const sel = $("sort");
    sel.innerHTML = "";
    for(const s of SORTS){
      const o1 = document.createElement("option");
      o1.value = `${s.key}:asc`;
      o1.textContent = `${s.label} ‚Üë`;
      sel.appendChild(o1);

      const o2 = document.createElement("option");
      o2.value = `${s.key}:desc`;
      o2.textContent = `${s.label} ‚Üì`;
      sel.appendChild(o2);
    }
    sel.value = `${state.sortKey}:${state.sortDir}`;
  }

  fillSortSelect();

  /***********************
   * Query parse
   ***********************/
  function parseQuery(q){
    const txt = norm(q);
    const out = {
      text: "",
      id: null,
      system: null,
      source: null,
      delisted: null,
      favorite: null,
      plat: null,
      completed: null,
      inprogress: null,
      unplayed: null,
      nopl: null,
    };

    if(!txt) return out;

    const tokens = txt.split(/\s+/).filter(Boolean);
    const free = [];

    for(const tok of tokens){
      const t = tok.trim();
      const m = t.match(/^([a-z]+):(.*)$/i);
      if(m){
        const k = m[1].toLowerCase();
        const v = m[2].toLowerCase();
        if(k === "id") out.id = v;
        else if(k === "system") out.system = v;
        else if(k === "source") out.source = v;
        else free.push(t);
      }else{
        const tt = t.toLowerCase();
        if(tt === "delisted") out.delisted = true;
        else if(tt === "favorite") out.favorite = true;
        else if(tt === "plat") out.plat = true;
        else if(tt === "completed") out.completed = true;
        else if(tt === "inprogress") out.inprogress = true;
        else if(tt === "unplayed") out.unplayed = true;
        else if(tt === "nopl") out.nopl = true;
        else free.push(t);
      }
    }

    out.text = free.join(" ").trim().toLowerCase();
    return out;
  }

  /***********************
   * Trophy derivation (from your new schema)
   ***********************/
  function buildTrophyModel(r){
    const systems = splitSystems(r[COL.system]);

    const progPairs = parsePairsByPlatform(r[COL.trophiesProgress]);
    const c100Pairs = parsePairsByPlatform(r[COL.trophies100]);
    const platPairs = parsePairsByPlatform(r[COL.trophiesPlat]);

    const progMap = new Map();
    for(const p of progPairs){
      const pv = parseProgressValue(p.value);
      if(pv) progMap.set(p.plat, pv);
    }

    const c100Map = new Map();
    for(const p of c100Pairs){
      const tok = parse100Token(p.value);
      if(tok) c100Map.set(p.plat, tok);
    }

    const platMap = new Map();
    for(const p of platPairs){
      const tok = parsePlatinumToken(p.value);
      if(tok) platMap.set(p.plat, tok);
    }

    // Determine per-system status
    const per = systems.map(plat => {
      const progress = progMap.get(plat) || null;
      const c100 = c100Map.get(plat) || "";
      const platTok = platMap.get(plat) || "";

      const played = !!(progress || c100 || platTok);
      const unplayed = !played;

      return { plat, progress, c100, platTok, unplayed };
    });

    // Global tags for filtering/badges:
    const anyUnplayed = per.some(x => x.unplayed);
    const anyInProgress = per.some(x => x.c100 === "IN_PROGRESS" || x.platTok === "IN_PROGRESS" || (x.progress && x.progress.pct < 100));
    const anyCompleted = per.some(x => x.c100 === "COMPLETED" || (x.progress && x.progress.pct === 100));
    const anyPlat = per.some(x => x.platTok === "PLAT");
    const anyNoPlat = per.some(x => x.platTok === "NO_PLAT");

    // Game-level unplayed = ALL unplayed (i.e. trophy cells empty)
    const allUnplayed = per.length ? per.every(x => x.unplayed) : true;

    return { systems, per, anyUnplayed, allUnplayed, anyInProgress, anyCompleted, anyPlat, anyNoPlat };
  }

  /***********************
   * Normalize row into view-model fields
   ***********************/
  function toVM(r){
    const id = Number(norm(r[COL.id]));
    const title = norm(r[COL.title]) || "‚Äî";
    const system = norm(r[COL.system]);
    const source = norm(r[COL.source]);
    const genre = norm(r[COL.genre]);
    const dev = norm(r[COL.dev]);
    const sub = norm(r[COL.subgenre]);
    const main = norm(r[COL.main]);
    const hundred = norm(r[COL.hundred]);

    const metaNum = parseMetascore(r[COL.meta]);
    const userNum = parseMetascore(r[COL.user]);
    const lifeNum = parseLifePct(r[COL.humorLife]);

    const fav = lower(r[COL.fav]) === "x";
    const delisted = lower(r[COL.avail]).includes("entfernt") || lower(r[COL.avail]).includes("delisted");

    const trophies = buildTrophyModel(r);

    return {
      r,
      id,
      title,
      system,
      source,
      genre,
      dev,
      sub,
      main,
      hundred,
      metaNum,
      userNum,
      lifeNum,
      fav,
      delisted,
      trophies,
    };
  }

  /***********************
   * Filtering
   ***********************/
  function passesFilters(vm, q){
    // Query id
    if(q.id){
      if(String(vm.id) !== String(q.id)) return false;
    }

    // Modal filters
    if(state.filters.favorite && !vm.fav) return false;
    if(state.filters.delisted && !vm.delisted) return false;

    if(state.filters.system.size){
      const sysSet = new Set(splitSystems(vm.system));
      let ok = false;
      for(const s of state.filters.system){
        if(sysSet.has(s)) { ok = true; break; }
      }
      if(!ok) return false;
    }

    if(state.filters.source.size){
      if(!state.filters.source.has(vm.source)) return false;
    }

    if(state.filters.trophy.size){
      const t = vm.trophies;

      const want = state.filters.trophy;
      const ok =
        (!want.has("unplayed") || t.allUnplayed) &&
        (!want.has("inprogress") || t.anyInProgress) &&
        (!want.has("completed") || t.anyCompleted) &&
        (!want.has("plat") || t.anyPlat) &&
        (!want.has("nopl") || t.anyNoPlat);

      if(!ok) return false;
    }

    // Query tokens
    if(q.system){
      if(!lower(vm.system).includes(q.system)) return false;
    }
    if(q.source){
      if(!lower(vm.source).includes(q.source)) return false;
    }
    if(q.delisted){
      if(!vm.delisted) return false;
    }
    if(q.favorite){
      if(!vm.fav) return false;
    }
    if(q.plat){
      if(!vm.trophies.anyPlat) return false;
    }
    if(q.completed){
      if(!vm.trophies.anyCompleted) return false;
    }
    if(q.inprogress){
      if(!vm.trophies.anyInProgress) return false;
    }
    if(q.unplayed){
      if(!vm.trophies.allUnplayed) return false;
    }
    if(q.nopl){
      if(!vm.trophies.anyNoPlat) return false;
    }

    // Free text search
    if(q.text){
      const hay = [
        vm.title, vm.genre, vm.sub, vm.dev, vm.source
      ].map(lower).join(" | ");
      if(!hay.includes(q.text)) return false;
    }

    return true;
  }

  /***********************
   * Sorting
   ***********************/
  function sortVM(a, b){
    const spec = SORTS.find(s => s.key === state.sortKey) || SORTS[0];
    const dir = state.sortDir === "desc" ? -1 : 1;

    const get = (vm) => {
      switch(spec.key){
        case "id": return vm.id;
        case "title": return vm.title;
        case "system": return vm.system;
        case "source": return vm.source;
        case "genre": return vm.genre;
        case "dev": return vm.dev;
        case "main": {
          const n = parseFloat(norm(vm.main).replace(",", "."));
          return Number.isFinite(n) ? n : null;
        }
        case "meta": return vm.metaNum;
        case "user": return vm.userNum;
        case "life": return vm.lifeNum;
        default: return vm[spec.key];
      }
    };

    const A = get(a), B = get(b);
    let c = stableCompare(A, B, spec.mode);
    if(c === 0) c = stableCompare(a.id, b.id, "num"); // stable fallback
    return c * dir;
  }

  /***********************
   * Rendering
   ***********************/
  function makeBadge(text, cls){
    const s = document.createElement("span");
    s.className = `badge ${cls || ""}`.trim();
    s.textContent = text;
    return s;
  }

  function makeTinyBadge(text, cls){
    const s = makeBadge(text, cls);
    s.classList.add("tiny");
    return s;
  }

  function renderTrophies(vm){
    const t = vm.trophies;

    const wrap = document.createElement("div");

    // Fortschritt (with bars)
    const sec = document.createElement("div");
    sec.className = "section";
    sec.innerHTML = `<div class="sectionTitle">TROPH√ÑEN</div>`;

    // Fortschritt title
    const fTitle = document.createElement("div");
    fTitle.className = "k";
    fTitle.textContent = "Fortschritt";
    sec.appendChild(fTitle);

    for(const p of t.per){
      const row = document.createElement("div");
      row.className = "tRow";

      const tag = document.createElement("div");
      tag.className = "platTag";
      tag.textContent = p.plat;

      const barWrap = document.createElement("div");
      barWrap.className = "barWrap";

      if(p.unplayed){
        const badges = document.createElement("div");
        badges.className = "tBadges";
        badges.appendChild(makeTinyBadge("üí§ Ungespielt", "badge--unplayed"));
        barWrap.appendChild(badges);
      }else{
        // if progress missing but played: show placeholder
        const pr = p.progress;
        if(pr){
          const top = document.createElement("div");
          top.className = "barTop";
          top.innerHTML = `<div>${pr.cur} of ${pr.total}</div><div class="pct">${pr.pct}%</div>`;
          const bar = document.createElement("div");
          bar.className = "bar";
          const fill = document.createElement("div");
          fill.style.width = pr.pct + "%";
          bar.appendChild(fill);

          barWrap.appendChild(top);
          barWrap.appendChild(bar);
        }else{
          const top = document.createElement("div");
          top.className = "barTop";
          top.innerHTML = `<div>‚Äî</div><div class="pct">‚Äî</div>`;
          barWrap.appendChild(top);

          const badges = document.createElement("div");
          badges.className = "tBadges";
          badges.appendChild(makeTinyBadge("‚è≥ In Arbeit", "badge--progress"));
          barWrap.appendChild(badges);
        }
      }

      row.appendChild(tag);
      row.appendChild(barWrap);
      sec.appendChild(row);

      // Completion / Platinum badges for this platform
      const sub = document.createElement("div");
      sub.style.margin = "6px 0 10px 86px";
      const bWrap = document.createElement("div");
      bWrap.className = "tBadges";

      // Completion badge
      if(p.unplayed){
        bWrap.appendChild(makeTinyBadge("üí§ Ungespielt", "badge--unplayed"));
      }else if(p.c100 === "COMPLETED" || (p.progress && p.progress.pct === 100)){
        bWrap.appendChild(makeTinyBadge("‚úÖ 100% erreicht", "badge--done"));
      }else{
        bWrap.appendChild(makeTinyBadge("‚è≥ In Arbeit", "badge--progress"));
      }

      // Platinum badge
      if(p.unplayed){
        // show unplayed in platinum row too (your wish)
        bWrap.appendChild(makeTinyBadge("üí§ Ungespielt", "badge--unplayed"));
      }else if(p.platTok === "NO_PLAT"){
        bWrap.appendChild(makeTinyBadge("‚Äî Kein Platin", "badge--nopl"));
      }else if(p.platTok === "PLAT"){
        bWrap.appendChild(makeTinyBadge("üíé Platin erlangt", "badge--plat"));
      }else{
        bWrap.appendChild(makeTinyBadge("‚è≥ In Arbeit", "badge--progress"));
      }

      sub.appendChild(bWrap);
      sec.appendChild(sub);
    }

    wrap.appendChild(sec);
    return wrap;
  }

  function renderCard(vm){
    const r = vm.r;

    const card = document.createElement("div");
    card.className = "card";

    const header = document.createElement("div");
    header.className = "cardHeader";

    const hLeft = document.createElement("div");
    const title = document.createElement("h3");
    title.className = "title";
    title.textContent = vm.title;
    hLeft.appendChild(title);

    const hRight = document.createElement("div");
    hRight.className = "badges";

    if(vm.fav) hRight.appendChild(makeBadge("‚≠ê Favorit", "badge--fav"));

    // Top-right trophy summary (game-level)
    if(vm.trophies.anyPlat) hRight.appendChild(makeBadge("üíé Platin erlangt", "badge--plat"));
    if(vm.trophies.anyCompleted) hRight.appendChild(makeBadge("‚úÖ 100% erreicht", "badge--done"));
    if(!vm.trophies.anyCompleted && vm.trophies.anyInProgress) hRight.appendChild(makeBadge("‚è≥ In Arbeit", "badge--progress"));
    if(vm.trophies.anyNoPlat) hRight.appendChild(makeBadge("‚Äî Kein Platin", "badge--nopl"));

    header.appendChild(hLeft);
    header.appendChild(hRight);

    const chipRow = document.createElement("div");
    chipRow.className = "chipRow";
    chipRow.appendChild(Object.assign(document.createElement("span"), { className:"chip id", textContent:`ID ${vm.id}` }));

    // System chips
    for(const s of splitSystems(vm.system)){
      chipRow.appendChild(Object.assign(document.createElement("span"), { className:"chip", textContent:s }));
    }

    // Availability chip
    const avail = norm(r[COL.avail]) || "‚Äî";
    chipRow.appendChild(Object.assign(document.createElement("span"), { className:"chip", textContent:avail }));

    const grid = document.createElement("div");
    grid.className = "grid";

    const compactPairs = [
      ["Genre", vm.genre || "‚Äî"],
      ["Entwickler", vm.dev || "‚Äî"],
      ["Spielzeit", (vm.main || "‚Äî") + (vm.hundred ? `h / ${vm.hundred}h` : "")].replace(/hh/g,"h"),
      ["Metascore", norm(r[COL.meta]) || "‚Äî"],
      ["Userwertung", norm(r[COL.user]) || "‚Äî"],
    ];

    for(const [k,v] of compactPairs){
      const kk = document.createElement("div");
      kk.className = "k";
      kk.textContent = k;
      const vv = document.createElement("div");
      vv.className = "v";
      vv.textContent = v;
      grid.appendChild(kk);
      grid.appendChild(vv);
    }

    const toggle = document.createElement("div");
    toggle.className = "toggle";
    toggle.innerHTML = `<span class="arrow">‚ñ∂</span><span class="txt">Mehr Details</span>`;

    toggle.addEventListener("click", () => {
      const open = card.classList.toggle("isOpen");
      toggle.querySelector(".arrow").textContent = open ? "‚ñº" : "‚ñ∂";
      toggle.querySelector(".txt").textContent = open ? "Weniger Details" : "Mehr Details";
    });

    const details = document.createElement("div");
    details.className = "details";

    // Beschreibung (collapsible)
    const secDesc = document.createElement("div");
    secDesc.className = "section";
    secDesc.innerHTML = `<div class="sectionTitle">BESCHREIBUNG</div>`;
    const descWrap = document.createElement("div");
    descWrap.className = "subWrap";
    const st = document.createElement("div");
    st.className = "subToggle";
    st.innerHTML = `<span>Kurzbeschreibung anzeigen</span><span>‚ñ∏</span>`;
    const sb = document.createElement("div");
    sb.className = "subBody";
    sb.textContent = norm(r[COL.desc]) || "‚Äî";
    st.addEventListener("click", () => {
      const open = descWrap.classList.toggle("isOpen");
      st.lastChild.textContent = open ? "‚ñæ" : "‚ñ∏";
    });
    descWrap.appendChild(st);
    descWrap.appendChild(sb);
    secDesc.appendChild(descWrap);

    // STORE section
    const secStore = document.createElement("div");
    secStore.className = "section";
    secStore.innerHTML = `<div class="sectionTitle">STORE</div>`;
    const storeGrid = document.createElement("div");
    storeGrid.className = "grid";
    const storePairs = [
      ["Quelle", norm(r[COL.source]) || "‚Äî"],
      ["Store", (norm(r[COL.store]) ? "Store Link" : "‚Äî")],
      ["Verf√ºgbarkeit", norm(r[COL.avail]) || "‚Äî"],
    ];
    for(const [k,v] of storePairs){
      const kk = document.createElement("div"); kk.className="k"; kk.textContent=k;
      const vv = document.createElement("div"); vv.className="v";
      if(k === "Store" && norm(r[COL.store])){
        const a = document.createElement("a");
        a.href = norm(r[COL.store]);
        a.target = "_blank";
        a.rel = "noopener noreferrer";
        a.textContent = "Store Link";
        vv.appendChild(a);
      }else{
        vv.textContent = v;
      }
      storeGrid.appendChild(kk); storeGrid.appendChild(vv);
    }
    secStore.appendChild(storeGrid);

    // EXTRAS section (Besonderheiten + Eastereggs collapsible)
    const secExtras = document.createElement("div");
    secExtras.className = "section";
    secExtras.innerHTML = `<div class="sectionTitle">EXTRAS</div>`;

    function makeExtrasToggle(label, text){
      const w = document.createElement("div");
      w.className = "subWrap";
      const t = document.createElement("div");
      t.className = "subToggle";
      t.innerHTML = `<span>${label} anzeigen</span><span>‚ñ∏</span>`;
      const b = document.createElement("div");
      b.className = "subBody";
      b.textContent = norm(text) || "‚Äî";
      t.addEventListener("click", () => {
        const open = w.classList.toggle("isOpen");
        t.lastChild.textContent = open ? "‚ñæ" : "‚ñ∏";
      });
      w.appendChild(t);
      w.appendChild(b);
      return w;
    }

    secExtras.appendChild(makeExtrasToggle("Besonderheiten", r[COL.special]));
    secExtras.appendChild(makeExtrasToggle("Eastereggs", r[COL.eggs]));

    // TROPH√ÑEN section (your new logic)
    const secT = renderTrophies(vm);

    // HUMORSTATISTIK section
    const secHum = document.createElement("div");
    secHum.className = "section";
    secHum.innerHTML = `<div class="sectionTitle">HUMORSTATISTIK</div>`;
    const humGrid = document.createElement("div");
    humGrid.className = "grid";
    const humPairs = [
      ["Gesamtstunden", norm(r[COL.humorHours]) || "‚Äî"],
      ["% Lebenszeit", norm(r[COL.humorLife]) || "‚Äî"],
      ["Jahre", norm(r[COL.humorYears]) || "‚Äî"],
    ];
    for(const [k,v] of humPairs){
      const kk = document.createElement("div"); kk.className="k"; kk.textContent=k;
      const vv = document.createElement("div"); vv.className="v"; vv.textContent=v;
      humGrid.appendChild(kk); humGrid.appendChild(vv);
    }
    secHum.appendChild(humGrid);

    details.appendChild(secDesc);
    details.appendChild(secStore);
    details.appendChild(secExtras);
    details.appendChild(secT);
    details.appendChild(secHum);

    card.appendChild(header);
    card.appendChild(chipRow);
    card.appendChild(grid);
    card.appendChild(toggle);
    card.appendChild(details);

    return card;
  }

  function rerender(reset=true){
    if(reset){
      $("list").innerHTML = "";
      renderCount = 0;
    }
    const frag = document.createDocumentFragment();
    const slice = filtered.slice(renderCount, renderCount + PAGE_SIZE);
    for(const vm of slice){
      frag.appendChild(renderCard(vm));
    }
    $("list").appendChild(frag);
    renderCount += slice.length;
    setStats();
  }

  function applyAll(){
    const q = parseQuery(state.search);

    // Build VM list
    const vms = rows.map(toVM);

    filtered = vms.filter(vm => passesFilters(vm, q));
    filtered.sort(sortVM);

    rerender(true);
    saveState();
  }

  /***********************
   * Modal (filters UI)
   ***********************/
  const backdrop = $("backdrop");

  function openMenu(){
    // sync UI
    syncPills();
    backdrop.classList.add("show");
    backdrop.setAttribute("aria-hidden","false");
    document.body.style.overflow = "hidden";
  }
  function closeMenu(){
    backdrop.classList.remove("show");
    backdrop.setAttribute("aria-hidden","true");
    document.body.style.overflow = "";
  }

  $("openMenu").addEventListener("click", openMenu);
  $("closeMenu").addEventListener("click", closeMenu);
  $("applyMenu").addEventListener("click", () => { closeMenu(); applyAll(); });
  backdrop.addEventListener("click", (e) => {
    if(e.target === backdrop) closeMenu();
  });
  window.addEventListener("keydown", (e) => {
    if(e.key === "Escape" && backdrop.classList.contains("show")) closeMenu();
  });

  function pill(label, on, cls, onToggle){
    const p = document.createElement("div");
    p.className = `pill ${cls || ""} ${on ? "on" : ""}`.trim();
    p.innerHTML = `<span class="dot"></span><span>${label}</span>`;
    p.addEventListener("click", () => onToggle(p));
    return p;
  }

  function syncPills(){
    const fgStatus = $("fgStatus");
    const fgSystem = $("fgSystem");
    const fgSource = $("fgSource");
    const fgTrophy = $("fgTrophy");
    fgStatus.innerHTML = fgSystem.innerHTML = fgSource.innerHTML = fgTrophy.innerHTML = "";

    // Status
    fgStatus.appendChild(pill("‚≠ê Favorit", state.filters.favorite, "gray", (el)=>{
      state.filters.favorite = !state.filters.favorite;
      el.classList.toggle("on", state.filters.favorite);
    }));
    fgStatus.appendChild(pill("üî¥ Delisted", state.filters.delisted, "red", (el)=>{
      state.filters.delisted = !state.filters.delisted;
      el.classList.toggle("on", state.filters.delisted);
    }));

    // System
    for(const s of ["PS5","PS4","PS3","Vita"]){
      fgSystem.appendChild(pill(s, state.filters.system.has(s), "", (el)=>{
        if(state.filters.system.has(s)) state.filters.system.delete(s);
        else state.filters.system.add(s);
        el.classList.toggle("on", state.filters.system.has(s));
      }));
    }

    // Source
    for(const s of ["Digital","PS Plus","Retail-Disc"]){
      fgSource.appendChild(pill(s, state.filters.source.has(s), "", (el)=>{
        if(state.filters.source.has(s)) state.filters.source.delete(s);
        else state.filters.source.add(s);
        el.classList.toggle("on", state.filters.source.has(s));
      }));
    }

    // Trophy
    fgTrophy.appendChild(pill("üí§ Ungespielt", state.filters.trophy.has("unplayed"), "gray", (el)=>{
      toggleSet(state.filters.trophy, "unplayed", el);
    }));
    fgTrophy.appendChild(pill("‚è≥ In Arbeit", state.filters.trophy.has("inprogress"), "orange", (el)=>{
      toggleSet(state.filters.trophy, "inprogress", el);
    }));
    fgTrophy.appendChild(pill("‚úÖ 100% erreicht", state.filters.trophy.has("completed"), "green", (el)=>{
      toggleSet(state.filters.trophy, "completed", el);
    }));
    fgTrophy.appendChild(pill("üíé Platin erlangt", state.filters.trophy.has("plat"), "blue", (el)=>{
      toggleSet(state.filters.trophy, "plat", el);
    }));
    fgTrophy.appendChild(pill("‚Äî Kein Platin", state.filters.trophy.has("nopl"), "gray", (el)=>{
      toggleSet(state.filters.trophy, "nopl", el);
    }));
  }

  function toggleSet(set, key, el){
    if(set.has(key)) set.delete(key);
    else set.add(key);
    el.classList.toggle("on", set.has(key));
  }

  $("clearFilters").addEventListener("click", () => {
    state.filters.favorite = false;
    state.filters.delisted = false;
    state.filters.system.clear();
    state.filters.source.clear();
    state.filters.trophy.clear();
    syncPills();
  });

  /***********************
   * Controls events
   ***********************/
  $("search").value = state.search;
  $("search").addEventListener("input", (e) => {
    state.search = e.target.value;
    applyAll();
  });

  $("sort").addEventListener("change", (e) => {
    const [k,d] = e.target.value.split(":");
    state.sortKey = k;
    state.sortDir = d;
    applyAll();
  });

  /***********************
   * File load
   ***********************/
  $("file").addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if(!f) return;

    const buf = await f.arrayBuffer();
    workbook = XLSX.read(buf, { type:"array" });

    // fill sheets
    const sel = $("sheet");
    sel.innerHTML = "";
    for(const name of workbook.SheetNames){
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      sel.appendChild(opt);
    }
    sel.disabled = false;

    // restore last sheet if exists, else first
    if(state.sheetName && workbook.SheetNames.includes(state.sheetName)){
      sel.value = state.sheetName;
    }else{
      sel.value = workbook.SheetNames[0];
      state.sheetName = sel.value;
    }

    loadSheet(sel.value);
  });

  $("sheet").addEventListener("change", (e) => {
    state.sheetName = e.target.value;
    loadSheet(state.sheetName);
  });

  function loadSheet(name){
    if(!workbook) return;
    const ws = workbook.Sheets[name];
    const json = XLSX.utils.sheet_to_json(ws, { defval:"" });
    rows = json;

    // ensure sort select matches persisted state
    fillSortSelect();

    applyAll();
  }

  /***********************
   * Infinite scroll
   ***********************/
  const observer = new IntersectionObserver((entries)=>{
    for(const ent of entries){
      if(ent.isIntersecting){
        if(renderCount < filtered.length){
          rerender(false);
        }
      }
    }
  }, { root:null, rootMargin:"800px 0px", threshold:0.01 });

  observer.observe($("sentinel"));

  /***********************
   * Floating Top button
   ***********************/
  const topBtn = $("topBtn");
  topBtn.addEventListener("click", ()=> window.scrollTo({ top:0, behavior:"smooth" }));

  window.addEventListener("scroll", ()=>{
    if(window.scrollY > 700) topBtn.classList.add("show");
    else topBtn.classList.remove("show");
  }, { passive:true });

  /***********************
   * Hide header on scroll (no flicker)
   ***********************/
  const controls = $("controls");
  let lastY = window.scrollY;
  let ticking = false;
  let hidden = false;

  window.addEventListener("scroll", ()=>{
    if(ticking) return;
    ticking = true;
    requestAnimationFrame(()=>{
      const y = window.scrollY;
      const dy = y - lastY;

      // do not hide if modal open
      if(backdrop.classList.contains("show")){
        controls.classList.remove("isHidden");
        hidden = false;
        lastY = y;
        ticking = false;
        return;
      }

      if(y < 60){
        controls.classList.remove("isHidden");
        hidden = false;
      }else if(dy > 14 && !hidden){
        controls.classList.add("isHidden");
        hidden = true;
      }else if(dy < -14 && hidden){
        controls.classList.remove("isHidden");
        hidden = false;
      }

      lastY = y;
      ticking = false;
    });
  }, { passive:true });

  /***********************
   * Boot: if user already had file loaded -> can't auto reload file (browser limitation)
   ***********************/
  setStats();
})();
</script>

</body>
</html>