<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Excel → Karten</title>
<style>
:root{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  --bg:#f6f7f9;
  --card:#fff;
  --text:#111;
  --muted:#6b7280;
  --line:#e9e9e9;
  --accent:#2536a4;
  --danger:#b00020;
  --dangerBg:#ffe7ea;
  --chipBg:#eef2ff;
}
body{margin:0;background:var(--bg);color:var(--text)}
header{
  position:sticky;top:0;z-index:10;
  background:#fff;border-bottom:1px solid #e7e7e7;
  padding:12px 14px;display:grid;gap:10px
}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
input,select,button{
  flex:1;min-width:170px;
  padding:10px 12px;border:1px solid #ddd;border-radius:12px;
  background:#fff;font-size:14px
}
button{cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}
main{padding:14px}
.hint{color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(310px,1fr));gap:12px}

.card{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  box-shadow:0 1px 2px rgba(0,0,0,.04);
  display:grid;gap:10px
}
.cardTop{display:grid;gap:6px}
.titleRow{display:flex;gap:10px;align-items:flex-start;justify-content:space-between}
.title{font-weight:800;font-size:16px;line-height:1.15}
.title.delisted{ text-decoration:line-through; color:var(--danger); }
.badges{display:flex;gap:8px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
.badge{
  font-size:12px;font-weight:650;
  padding:4px 8px;border-radius:999px;
  background:var(--chipBg);color:var(--accent);
  white-space:nowrap
}
.badge.delisted{background:var(--dangerBg);color:var(--danger)}
.metaRow{display:flex;gap:8px;flex-wrap:wrap}
.chip{
  font-size:12px;color:#374151;
  background:#f3f4f6;border:1px solid #ececec;
  padding:4px 8px;border-radius:999px;
  white-space:nowrap
}

.keyFacts{
  display:grid;gap:8px;
  border-top:1px solid var(--line);
  padding-top:10px
}
.kvLine{
  display:grid;
  grid-template-columns:120px 1fr;
  gap:10px;align-items:start
}
.k{color:var(--muted);font-size:12px}
.v{font-size:13px;word-break:break-word}

.detailsWrap{border-top:1px solid var(--line);padding-top:10px}
details{border:0}
summary{
  cursor:pointer;color:var(--accent);
  font-size:13px;user-select:none
}
summary::-webkit-details-marker{display:none}
.summaryBtn{display:inline-flex;align-items:center;gap:8px}
.summaryBtn::after{content:"▾";font-size:12px;transform:translateY(-1px)}
details[open] .summaryBtn::after{content:"▴"}

.section{
  border-top:1px solid var(--line);
  padding-top:10px;
  margin-top:10px;
  display:grid;gap:8px
}
.sectionTitle{
  font-size:11px;
  letter-spacing:.08em;
  color:var(--muted);
  text-transform:uppercase;
}

.subdetails summary{color:#374151;font-size:13px}
.subdetails .summaryBtn{color:#374151}
.subdetails .summaryBtn::after{color:#6b7280}
.subdetails .descText{ margin-top: 8px; }

/* Trophy Pfiff */
.trophyList{display:grid;gap:6px}
.trophyRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.platformChip{
  font-size:11px;font-weight:700;
  padding:2px 8px;border-radius:999px;
  background:#f3f4f6;border:1px solid #ececec;color:#374151;
}
.trophyText{font-size:13px;color:#111}

/* Mehrzeilige Fallback-Darstellung */
.preline{ white-space: pre-line; }

a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
.footer{padding:0 14px 14px;color:var(--muted);font-size:12px}
.counter{font-size:12px;color:#555}
</style>
</head>
<body>

<header>
  <div class="row">
    <strong>Excel → Karten</strong>
    <span class="hint">Clean Cards · 1200+ ready · Trophy polish</span>
  </div>
  <div class="row">
    <input id="file" type="file" accept=".xlsx,.xls" />
    <select id="sheetSelect" disabled><option>Sheet auswählen…</option></select>
  </div>
  <div class="row">
    <input id="search" type="search" placeholder="Suche…" disabled />
    <button id="moreBtn" disabled>Mehr laden</button>
    <button id="topBtn" disabled>↑ Top</button>
  </div>
  <div class="row">
    <span id="status" class="hint">Datei wählen → Sheet wählen → suchen</span>
    <span id="count" class="counter"></span>
  </div>
</header>

<main><div id="grid" class="grid"></div></main>
<div class="footer" id="footer"></div>

<script src="xlsx.full.min.js"></script>
<script>
/* ================== Einstellungen ================== */
const PAGE_SIZE = 60;
const PLACEHOLDER = "—";

// leere Felder anzeigen
const SHOW_EMPTY_IN_KEYFACTS = true;
const SHOW_EMPTY_IN_DETAILS  = true;

/* ================== Spalten-Aliases ================== */
const COL_ALIASES = {
  id: ["ID"],
  title: ["Spieletitel","Spiel","Titel","Name"],
  fav: ["Favorit","Favorite"],
  system: ["System","Plattform","Platform"],
  availability: ["Verfügbarkeit","Verfuegbarkeit","Availability"],
  store: ["Store Link","Store-Link","StoreLink","Store"],
  source: ["Quelle","Source"],
  genre: ["Genre"],
  subgenre: ["Subgenre","Subgenre / Stimmung","Subgenre/Stimmung"],
  dev: ["Entwickler","Developer","Studio"],
  desc: ["Kurzbeschreibung","Beschreibung","Description"],
  easter: ["Eastereggs","Easter Eggs"],
  special: ["Besonderheiten","Highlights"],
  main: ["Spielzeit (Main)","Spielzeit Main","Main Story (Std.)","Main Story"],
  hundred: ["Spielzeit (100%)","Spielzeit 100%","100 % (Std.)","100% (Std.)","100%"],
  meta: ["Metascore","Pressemeinung (Ø)"],
  user: ["Userwertung","Userwertung (Ø)"],
  trophies: ["Trophäen Fortschritt","Trophäen-Fortschritt","Trophäenfortschritt","Trophies Progress"],
  platinum: ["Platin","Platinum"],
  hours: ["Gesamtstunden (Humorstatistik)","Humorstatistik – Gesamtstunden"],
  life: ["% Lebenszeit (Humorstatistik)","Humorstatistik – % Lebenszeit"],
  years: ["Jahre (Humorstatistik)","Humorstatistik – Jahre"],
};
let COL = {};

/* ================== State ================== */
const els = {
  file: document.getElementById("file"),
  sheet: document.getElementById("sheetSelect"),
  search: document.getElementById("search"),
  more: document.getElementById("moreBtn"),
  top: document.getElementById("topBtn"),
  status: document.getElementById("status"),
  count: document.getElementById("count"),
  grid: document.getElementById("grid"),
  footer: document.getElementById("footer"),
};

let workbook = null;
let allRows = [];
let matches = [];
let shown = 0;
let columns = [];
let linkMap = new Map();     // `${row1based}:${colName}` -> href
let headerRowIndex = 1;      // 1-basiert

const s = v => (v == null ? "" : String(v).trim());

/* ================== Resolver ================== */
function normHeader(x){
  return String(x ?? "")
    .replace(/\u00A0/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();
}
function resolveColumns(columns){
  const byNorm = new Map(columns.map(c => [normHeader(c), c]));
  const resolved = {};
  for (const [key, aliases] of Object.entries(COL_ALIASES)) {
    let found = "";
    for (const a of aliases) {
      const hit = byNorm.get(normHeader(a));
      if (hit) { found = hit; break; }
    }
    resolved[key] = found;
  }
  return resolved;
}
function val(row, colName){
  if (!colName) return "";
  const v = row[colName];
  return v == null ? "" : String(v).trim();
}

/* ================== Hyperlinks & Delisted ================== */
function buildLinks(ws){
  linkMap.clear();
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  headerRowIndex = headerR + 1;

  const headerByCol = new Map();
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    headerByCol.set(c, cell && cell.v != null ? String(cell.v).trim() : "");
  }

  for (let rr = headerR + 1; rr <= r.e.r; rr++){
    const row1 = rr + 1;
    for (let c = r.s.c; c <= r.e.c; c++){
      const cell = ws[XLSX.utils.encode_cell({ r: rr, c })];
      if (cell && cell.l && cell.l.Target){
        const colName = headerByCol.get(c);
        if (colName) linkMap.set(`${row1}:${colName}`, String(cell.l.Target));
      }
    }
  }
}
function applyDelistedFromStyles(ws){
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const titleCol = COL.title;
  if (!titleCol) return;

  const headerR = r.s.r;
  let titleC = null;
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    const h = cell && cell.v != null ? String(cell.v).trim() : "";
    if (h === titleCol) { titleC = c; break; }
  }
  if (titleC == null) return;

  for (let i = 0; i < allRows.length; i++){
    const rr = headerR + 1 + i;
    const cell = ws[XLSX.utils.encode_cell({ r: rr, c: titleC })];
    const strike = !!(cell && cell.s && cell.s.font && (cell.s.font.strike || cell.s.font.strikethrough));
    if (strike) allRows[i].__delisted = true;
  }
}
function isDelistedRow(row){
  if (row.__delisted) return true;
  const v = val(row, COL.availability).toLowerCase();
  return v === "delisted" || v === "removed" || v.includes("store entfernt");
}
function getValueWithLink(row, colName, rowIndex1Based){
  const text = val(row, colName);
  const href = linkMap.get(`${rowIndex1Based}:${colName}`);
  if (href) return { text: text || "Store Link", href };
  return text;
}

/* ================== Rendering helpers ================== */
function nodeText(t){ return document.createTextNode(t); }

function renderValue(value){
  if (value && typeof value === "object" && value.href) {
    const a = document.createElement("a");
    a.href = value.href;
    a.textContent = value.text || "Link";
    a.title = value.href;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    return a;
  }
  const t = s(value);
  return nodeText(t || PLACEHOLDER);
}
function kvLine(label, valueNode){
  const line = document.createElement("div");
  line.className = "kvLine";

  const k = document.createElement("div");
  k.className = "k";
  k.textContent = label;

  const v = document.createElement("div");
  v.className = "v";
  v.appendChild(valueNode);

  line.append(k, v);
  return line;
}
function makeChip(text){
  const c = document.createElement("span");
  c.className = "chip";
  c.textContent = text;
  return c;
}
function makeBadge(text, cls=""){
  const b = document.createElement("span");
  b.className = "badge" + (cls ? " " + cls : "");
  b.textContent = text;
  return b;
}

function formatFavorite(row){
  const f = val(row, COL.fav).toLowerCase();
  if (!f) return "";
  return (f === "x" || f === "1" || f === "true" || f === "yes" || f === "y" || f.includes("⭐")) ? "⭐ Favorit" : "";
}
function formatPlaytime(row){
  const m = val(row, COL.main);
  const h = val(row, COL.hundred);
  if (!m && !h) return "";
  if (m && h) return `${m}h / ${h}h`;
  return m ? `${m}h` : `${h}h`;
}

/* ================== Trophy polish ==================
   Wir versuchen "PS4 ..." "PS5 ..." als Paare zu extrahieren.
   Fällt er durch, zeigen wir als preline-Fallback. */
function parsePlatformPairs(text){
  const t = String(text ?? "").trim();
  if (!t) return [];
  const platforms = ["PS5","PS4","PS3","PS2","PS1","PSVita","Vita","PC","Switch","Xbox","Series","One"];

  // Tokenisiere: finde jede Plattformposition und schneide bis zur nächsten Plattform
  const hits = [];
  for (const p of platforms) {
    const re = new RegExp(`\\b${p}\\b`, "g");
    let m;
    while ((m = re.exec(t)) !== null) hits.push({ p, i: m.index });
  }
  hits.sort((a,b)=>a.i-b.i);
  if (!hits.length) return [];

  const out = [];
  for (let j=0;j<hits.length;j++){
    const start = hits[j].i;
    const end = (j+1<hits.length) ? hits[j+1].i : t.length;
    const p = hits[j].p;
    let seg = t.slice(start, end).trim();
    seg = seg.replace(new RegExp(`^${p}\\s*`), "").trim();
    if (!seg) seg = PLACEHOLDER;
    out.push({ platform: p, text: seg });
  }
  return out;
}

function trophyNodeFromText(text){
  const pairs = parsePlatformPairs(text);
  if (pairs.length) {
    const wrap = document.createElement("div");
    wrap.className = "trophyList";
    for (const it of pairs) {
      const row = document.createElement("div");
      row.className = "trophyRow";
      const chip = document.createElement("span");
      chip.className = "platformChip";
      chip.textContent = it.platform;
      const tt = document.createElement("span");
      tt.className = "trophyText";
      tt.textContent = it.text;
      row.append(chip, tt);
      wrap.appendChild(row);
    }
    return wrap;
  }
  // Fallback: mehrzeilig brechen an Plattformen
  const fallback = document.createElement("div");
  fallback.className = "v preline";
  fallback.textContent = String(text ?? "").replace(/\s+(PS5|PS4|PS3|PS2|PS1|PSVita|Vita|PC|Switch|Xbox|Series|One)\b/g, "\n$1").trim() || PLACEHOLDER;
  return fallback;
}

/* ================== Card ================== */
function createCard(row, rowIndex1Based){
  const card = document.createElement("div");
  card.className = "card";

  // Top
  const top = document.createElement("div");
  top.className = "cardTop";

  const titleRow = document.createElement("div");
  titleRow.className = "titleRow";

  const title = document.createElement("div");
  title.className = "title";
  title.textContent = val(row, COL.title) || "(ohne Titel)";
  if (isDelistedRow(row)) title.classList.add("delisted");

  const badges = document.createElement("div");
  badges.className = "badges";
  if (isDelistedRow(row)) badges.appendChild(makeBadge("Delisted", "delisted"));
  const favLabel = formatFavorite(row);
  if (favLabel) badges.appendChild(makeBadge(favLabel));

  titleRow.append(title, badges);

  const metaRow = document.createElement("div");
  metaRow.className = "metaRow";
  metaRow.appendChild(makeChip(`ID ${val(row, COL.id) || PLACEHOLDER}`));
  metaRow.appendChild(makeChip(val(row, COL.system) || PLACEHOLDER));
  metaRow.appendChild(makeChip(val(row, COL.availability) || PLACEHOLDER));

  top.append(titleRow, metaRow);

  // Key facts
  const key = document.createElement("div");
  key.className = "keyFacts";

  const genre = val(row, COL.genre);
  const subg  = val(row, COL.subgenre);
  const pt    = formatPlaytime(row);
  const metaScore = val(row, COL.meta);
  const userScore = val(row, COL.user);

  if (genre || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Genre", renderValue(genre)));
  if (subg  || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Subgenre / Stimmung", renderValue(subg)));
  if (pt    || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Spielzeit", renderValue(pt)));
  if (metaScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Metascore", renderValue(metaScore)));
  if (userScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Userwertung", renderValue(userScore)));

  // Details
  const detailsWrap = document.createElement("div");
  detailsWrap.className = "detailsWrap";

  const details = document.createElement("details");
  const summary = document.createElement("summary");
  const sumSpan = document.createElement("span");
  sumSpan.className = "summaryBtn";
  sumSpan.textContent = "Mehr Details";
  summary.appendChild(sumSpan);
  details.appendChild(summary);

  function addSection(titleText, lines){
    const exists = lines.some(x => x != null);
    if (!exists) return;

    const sec = document.createElement("div");
    sec.className = "section";

    const st = document.createElement("div");
    st.className = "sectionTitle";
    st.textContent = titleText;

    sec.appendChild(st);
    for (const line of lines) if (line) sec.appendChild(line);
    details.appendChild(sec);
  }

  // Beschreibung: ausklappbar
  const descText = val(row, COL.desc);
  {
    const d = document.createElement("details");
    d.className = "subdetails";
    const ssum = document.createElement("summary");
    const sbtn = document.createElement("span");
    sbtn.className = "summaryBtn";
    sbtn.textContent = "Kurzbeschreibung anzeigen";
    ssum.appendChild(sbtn);
    d.appendChild(ssum);

    const p = document.createElement("div");
    p.className = "v descText";
    p.textContent = descText || PLACEHOLDER;
    d.appendChild(p);

    addSection("Beschreibung", [d]);
  }

  // Store
  const storeVal = getValueWithLink(row, COL.store, rowIndex1Based);
  const source = val(row, COL.source);
  const availability = val(row, COL.availability);

  addSection("Store", [
    (storeVal || SHOW_EMPTY_IN_DETAILS) ? kvLine("Store", renderValue(storeVal)) : null,
    (source   || SHOW_EMPTY_IN_DETAILS) ? kvLine("Quelle", renderValue(source)) : null,
    (availability || SHOW_EMPTY_IN_DETAILS) ? kvLine("Verfügbarkeit", renderValue(availability)) : null,
  ]);

  // Entwickler
  const dev = val(row, COL.dev);
  addSection("Entwickler", [
    (dev || SHOW_EMPTY_IN_DETAILS) ? kvLine("Entwickler", renderValue(dev)) : null
  ]);

  // Extras
  const special = val(row, COL.special);
  const easter  = val(row, COL.easter);
  addSection("Extras", [
    (special || SHOW_EMPTY_IN_DETAILS) ? kvLine("Besonderheiten", renderValue(special)) : null,
    (easter  || SHOW_EMPTY_IN_DETAILS) ? kvLine("Eastereggs", renderValue(easter)) : null,
  ]);

  // Trophäen (polished)
  const trophies = val(row, COL.trophies);
  const platinum = val(row, COL.platinum);
  addSection("Trophäen", [
    kvLine("Fortschritt", trophyNodeFromText(trophies)),
    kvLine("Platin", trophyNodeFromText(platinum)),
  ]);

  // Humorstatistik
  const hours = val(row, COL.hours);
  const life  = val(row, COL.life);
  const years = val(row, COL.years);
  addSection("Humorstatistik", [
    (hours || SHOW_EMPTY_IN_DETAILS) ? kvLine("Gesamtstunden", renderValue(hours)) : null,
    (life  || SHOW_EMPTY_IN_DETAILS) ? kvLine("% Lebenszeit", renderValue(life)) : null,
    (years || SHOW_EMPTY_IN_DETAILS) ? kvLine("Jahre", renderValue(years)) : null,
  ]);

  detailsWrap.appendChild(details);

  card.append(top, key, detailsWrap);
  return card;
}

/* ================== Paging / Search (kein 600-Limit mehr) ================== */
function updateCounters(){
  const total = matches.length;
  els.count.textContent = total ? `Treffer: ${total} · angezeigt: ${shown}/${total}` : "";
  els.more.disabled = shown >= total;
  els.more.textContent = els.more.disabled ? "Mehr laden" : `Mehr laden (+${Math.min(PAGE_SIZE, total - shown)})`;
}

function renderMore(){
  const total = matches.length;
  if (shown >= total) return;

  const end = Math.min(shown + PAGE_SIZE, total);
  const frag = document.createDocumentFragment();

  for (let i = shown; i < end; i++){
    const { row, idx } = matches[i];
    frag.appendChild(createCard(row, idx));
  }

  els.grid.appendChild(frag);
  shown = end;

  els.status.textContent = total
    ? (shown < total ? "Mehr laden zeigt weitere Karten…" : "Alle Karten angezeigt.")
    : "Keine Treffer.";

  updateCounters();
}

function startSearch(q){
  els.grid.innerHTML = "";
  shown = 0;

  const term = (q || "").toLowerCase().trim();

  matches = allRows
    .map((row, i) => ({ row, idx: headerRowIndex + 1 + i }))
    .filter(o => {
      if (!term) return true;
      const fast =
        val(o.row, COL.id) + " " +
        val(o.row, COL.title) + " " +
        val(o.row, COL.dev) + " " +
        val(o.row, COL.genre) + " " +
        val(o.row, COL.subgenre);
      if (fast.toLowerCase().includes(term)) return true;
      return Object.values(o.row).some(v => s(v).toLowerCase().includes(term));
    });

  renderMore();
}

/* ================== Events ================== */
els.top.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));
els.more.addEventListener("click", () => renderMore());

els.file.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  els.status.textContent = "Lese Datei…";

  const buf = await f.arrayBuffer();
  workbook = XLSX.read(buf, { type: "array", cellStyles: true });

  els.sheet.innerHTML = "<option>Sheet auswählen…</option>";
  workbook.SheetNames.forEach(n => {
    const o = document.createElement("option");
    o.value = n; o.textContent = n;
    els.sheet.appendChild(o);
  });

  els.sheet.disabled = false;
  els.search.disabled = true;
  els.more.disabled = true;
  els.grid.innerHTML = "";
  els.count.textContent = "";
  els.status.textContent = "Sheet wählen…";
});

els.sheet.addEventListener("change", () => {
  const name = els.sheet.value;
  if (!name || name === "Sheet auswählen…") return;

  const ws = workbook.Sheets[name];

  const json = XLSX.utils.sheet_to_json(ws, { defval: "" });
  allRows = json;
  columns = json.length ? Object.keys(json[0]) : [];

  COL = resolveColumns(columns);

  buildLinks(ws);
  applyDelistedFromStyles(ws);

  els.search.disabled = false;
  els.status.textContent = `Geladen: ${allRows.length} Zeilen`;
  startSearch(els.search.value || "");
});

els.search.addEventListener("input", (e) => startSearch(e.target.value));
</script>
</body>
</html>