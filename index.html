<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Spieleliste</title>

  <!-- XLSX Library (lokal im selben Ordner) -->
  <script src="./xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb;
      --card:#ffffff;
      --text:#12151a;
      --muted:#6b7280;
      --line:#e6e8ef;
      --shadow:0 10px 30px rgba(10, 20, 40, .08);
      --radius:18px;

      --chip:#eef1f6;
      --chipText:#2a3446;

      --blue:#2f5bff;
      --blueBg:#e9efff;

      --green:#156a3a;
      --greenBg:#e7f7ee;

      --red:#a11b1b;
      --redBg:#fdecec;

      --gold:#7a5a00;
      --goldBg:#fff7dd;

      --violet:#4b2aa6;
      --violetBg:#efeaff;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }

    .wrap{
      max-width:860px;
      margin:0 auto;
      padding:14px 12px 80px;
    }

    /* Header / Men√º */
    .header{
      position:sticky;
      top:0;
      z-index:50;
      background:linear-gradient(to bottom, rgba(246,247,251,.98), rgba(246,247,251,.92));
      backdrop-filter: blur(10px);
      padding:10px 0 12px;
      transition: padding .2s ease;
    }
    .header.collapsed{
      padding:6px 0 6px;
    }

    .titleRow{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      padding:0 2px 10px;
      transition: padding .2s ease, opacity .2s ease;
    }
    .header.collapsed .titleRow{
      padding:0 2px 6px;
    }

    h1{
      font-size:26px;
      line-height:1.05;
      margin:0;
      letter-spacing:-.02em;
    }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-items:stretch;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:stretch;
    }

    .box{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow:0 2px 10px rgba(0,0,0,.03);
      overflow:hidden;
    }

    .box.pad{ padding:10px; }

    label.small{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:0 0 6px;
    }

    input[type="file"]{
      width:100%;
      padding:10px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
    }

    select, input[type="text"]{
      width:100%;
      padding:12px 12px;
      border:1px solid var(--line);
      border-radius:16px;
      background:#fff;
      font-size:15px;
      outline:none;
    }
    select:disabled{opacity:.5}

    .searchRow{
      display:grid;
      grid-template-columns: 1fr 56px;
      gap:10px;
      align-items:stretch;
    }

    .hamburger{
      display:flex;
      align-items:center;
      justify-content:center;
      width:56px;
      border-radius:16px;
      border:1px solid var(--line);
      background:var(--blueBg);
      color:#0f2dbb;
      font-size:24px;
      user-select:none;
      cursor:pointer;
    }

    .metaLine{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding:10px 2px 0;
      color:var(--muted);
      font-size:14px;
      min-height:24px;
    }

    /* Drawer */
    .drawerBackdrop{
      position:fixed; inset:0;
      background:rgba(0,0,0,.25);
      z-index:80;
      display:none;
    }
    .drawerBackdrop.show{display:block}
    .drawer{
      position:fixed;
      top:0; right:0;
      height:100%;
      width:min(420px, 92vw);
      background:var(--card);
      border-left:1px solid var(--line);
      box-shadow: -10px 0 40px rgba(0,0,0,.12);
      z-index:90;
      transform:translateX(100%);
      transition: transform .22s ease;
      display:flex;
      flex-direction:column;
    }
    .drawer.show{ transform:translateX(0) }
    .drawerHead{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .drawerHead b{font-size:16px}
    .closeBtn{
      border:1px solid var(--line);
      background:#fff;
      border-radius:12px;
      padding:8px 10px;
      cursor:pointer;
    }
    .drawerBody{
      padding:12px 14px 16px;
      overflow:auto;
    }

    .chipRow{ display:flex; flex-wrap:wrap; gap:8px; }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:var(--chip);
      color:var(--chipText);
      font-size:14px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .chip.on{
      border-color:transparent;
      background:var(--blueBg);
      color:#0f2dbb;
    }

    .chip.green.on{ background:var(--greenBg); color:var(--green); }
    .chip.red.on{ background:var(--redBg); color:var(--red); }
    .chip.violet.on{ background:var(--violetBg); color:var(--violet); }

    .divider{
      height:1px;
      background:var(--line);
      margin:14px 0;
    }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .help{
      font-size:14px;
      color:var(--muted);
      line-height:1.35;
      background:#fbfbfe;
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
    }

    /* Cards */
    .list{
      display:grid;
      gap:14px;
      padding-top:14px;
    }

    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding:14px 14px 12px;
      overflow:hidden;
    }

    .card.delisted{
      opacity:.95;
    }
    .card.delisted .gameTitle{
      color:var(--red);
      text-decoration: line-through;
      text-decoration-thickness: 2px;
    }

    .cardTop{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
    }

    .gameTitle{
      font-size:20px;
      line-height:1.15;
      margin:0;
      letter-spacing:-.01em;
    }

    .badges{
      display:flex;
      flex-direction:column; /* immer untereinander */
      gap:6px;
      align-items:flex-end;
      min-width:120px;
      flex:0 0 auto;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      font-size:13px;
      border:1px solid var(--line);
      background:#fff;
      color:#1f2a37;
      white-space:nowrap;
    }
    .badge.fav{ background:var(--goldBg); color:var(--gold); border-color:transparent; }
    .badge.plat{ background:var(--blueBg); color:#0f2dbb; border-color:transparent; }
    .badge.c100{ background:var(--greenBg); color:var(--green); border-color:transparent; }
    .badge.work{ background:var(--redBg); color:var(--red); border-color:transparent; }
    .badge.sleep{ background:#eef2f7; color:#3b455a; border-color:transparent; }

    .subBadges{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
      padding-bottom:10px;
      border-bottom:1px solid var(--line);
    }

    .pill{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      font-size:13px;
      background:var(--chip);
      border:1px solid var(--line);
      color:#111827;
      min-height:30px;
    }
    .pill.id{
      background:#223a9a;
      color:#fff;
      border-color:transparent;
      font-weight:700;
      letter-spacing:.02em;
    }
    .pill.status{
      background:#f3f4f6;
      color:#111827;
    }

    .kv{
      display:grid;
      grid-template-columns: 160px 1fr;
      gap:8px 14px;
      padding:10px 0;
      border-bottom:1px solid rgba(230,232,239,.7);
    }
    .kv:last-child{ border-bottom:none; padding-bottom:0; }

    .k{
      color:var(--muted);
      font-size:14px;
      line-height:1.3;
    }
    .v{
      font-size:15px;
      line-height:1.35;
      word-break:break-word;
    }
    .v.mono{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum";
    }

    .detailsToggle{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
      color:#1f3aa7;
      font-weight:600;
      padding:10px 0 0;
    }
    .detailsToggle span{ font-size:14px; }

    .details{
      display:none;
      margin-top:10px;
      padding-top:12px;
      border-top:1px solid var(--line);
    }
    .details.open{ display:block; }

    .sectionTitle{
      color:var(--muted);
      letter-spacing:.10em;
      font-size:12px;
      margin:14px 0 8px;
    }

    .fold{
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      background:#fff;
    }
    .foldHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      cursor:pointer;
      user-select:none;
      font-weight:650;
      color:#1f3aa7;
    }
    .foldBody{
      display:none;
      margin-top:10px;
      border-top:1px dashed rgba(230,232,239,.9);
      padding-top:10px;
      color:#111827;
      white-space:pre-wrap;
      line-height:1.4;
      font-size:15px;
    }
    .fold.open .foldBody{ display:block; }
    .foldSubGap{ height:8px; }

    /* Trophy layout */
    .trophyList{
      display:grid;
      gap:10px;
    }
    .trophyRow{
      display:grid;
      grid-template-columns: 54px 1fr;
      gap:10px;
      align-items:center;
    }
    .tPlatform{
      justify-self:start;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      background:#f3f4f6;
      border:1px solid var(--line);
      font-size:13px;
      color:#111827;
      min-width:54px;
    }
    .tMain{
      display:grid;
      gap:6px;
    }
    .tLine{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .tText{
      font-size:14px;
      color:#111827;
    }
    .bar{
      height:10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#f2f4f8;
      overflow:hidden;
    }
    .bar > i{
      display:block;
      height:100%;
      width:0%;
      background:#2f5bff;
    }
    .barMeta{
      font-size:12px;
      color:var(--muted);
    }

    /* Sentinel + Top button */
    .sentinel{
      height:1px;
    }
    .fabTop{
      position:fixed;
      right:14px;
      bottom:14px;
      z-index:60;
      display:none;
      align-items:center;
      justify-content:center;
      padding:12px 14px;
      border-radius:999px;
      border:1px solid var(--line);
      background:#fff;
      box-shadow:0 12px 30px rgba(0,0,0,.10);
      cursor:pointer;
      user-select:none;
      font-weight:700;
    }
    .fabTop.show{ display:flex; }

    /* Responsive */
    @media (max-width:560px){
      .controls{ grid-template-columns: 1fr; }
      .kv{ grid-template-columns: 140px 1fr; }
      .badges{ min-width:108px; }
    }
  </style>
</head>

<body>
  <div class="header" id="header">
    <div class="wrap">
      <div class="titleRow" id="titleRow">
        <h1>Spieleliste</h1>
      </div>

      <div class="controls">
        <div class="box pad">
          <label class="small">Datei</label>
          <input id="file" type="file" accept=".xlsx,.xls,.csv,text/csv" />
        </div>

        <div class="box pad">
          <label class="small">Sheet</label>
          <select id="sheet" disabled>
            <option value="">Sheet ausw√§hlen‚Ä¶</option>
          </select>
        </div>

        <div class="box pad" style="grid-column:1/-1;">
          <div class="searchRow">
            <input id="q" type="text" placeholder="Suche‚Ä¶ (z.B. id:643 delisted ps5 dev:capcom)" />
            <div class="hamburger" id="openMenu" title="Sort & Filter">‚ò∞</div>
          </div>
        </div>
      </div>

      <div class="metaLine" id="metaLine">Datei w√§hlen ‚Üí Sheet w√§hlen ‚Üí suchen</div>
    </div>
  </div>

  <div class="wrap">
    <div class="list" id="list"></div>
    <div class="sentinel" id="sentinel"></div>
  </div>

  <div class="fabTop" id="fabTop">‚Üë Top</div>

  <!-- Drawer -->
  <div class="drawerBackdrop" id="backdrop"></div>
  <div class="drawer" id="drawer">
    <div class="drawerHead">
      <b>Sortieren & Filtern</b>
      <button class="closeBtn" id="closeMenu">Schlie√üen</button>
    </div>
    <div class="drawerBody">
      <div class="twoCol">
        <div class="box pad">
          <label class="small">Sortieren nach</label>
          <select id="sortKey">
            <!-- wird dynamisch gef√ºllt -->
          </select>
        </div>
        <div class="box pad">
          <label class="small">Richtung</label>
          <select id="sortDir">
            <option value="asc">Aufsteigend</option>
            <option value="desc">Absteigend</option>
          </select>
        </div>
      </div>

      <div class="divider"></div>

      <div class="help">
        <b>Mini-Hilfe</b><br/>
        - <b>id:643</b> sucht nach ID<br/>
        - <b>delisted</b>, <b>ps5</b>, <b>ps4</b>, <b>vita</b>, <b>ps3</b><br/>
        - <b>dev:capcom</b> Entwickler enth√§lt ‚Äûcapcom‚Äú<br/>
        - Rest ist normale Volltextsuche
      </div>

      <div class="divider"></div>

      <label class="small">Filter</label>
      <div class="chipRow" style="margin-bottom:10px;">
        <div class="chip on" id="fAll">Alle</div>
        <div class="chip" id="fFav">‚≠ê Favorit</div>
        <div class="chip violet" id="fPlat">üíé Platin</div>
        <div class="chip green" id="f100">‚úÖ 100%</div>
        <div class="chip red" id="fDel">Delisted</div>
      </div>

      <label class="small">Plattform</label>
      <div class="chipRow" style="margin-bottom:10px;">
        <div class="chip" data-plat="PS5">PS5</div>
        <div class="chip" data-plat="PS4">PS4</div>
        <div class="chip" data-plat="PS3">PS3</div>
        <div class="chip" data-plat="Vita">Vita</div>
      </div>

      <label class="small">Quelle</label>
      <div class="chipRow">
        <div class="chip" data-src="digital">Digital</div>
        <div class="chip" data-src="psplus">PS Plus</div>
        <div class="chip" data-src="disc">Disc</div>
      </div>

      <div class="divider"></div>

      <button class="closeBtn" id="clearFilters" style="width:100%; padding:12px; border-radius:14px;">
        Filter l√∂schen
      </button>
    </div>
  </div>

<script>
(() => {
  const PLACEHOLDER = "‚Äî";

  // ---- Column mapping (deine Datei)
  const COL = {
    id: ["ID","Id","id"],
    title: ["Spieletitel","Spiel","Titel","Title"],
    system: ["System","Plattform","Platform"],
    source: ["Quelle","Source"],
    availability: ["Verf√ºgbarkeit","Availability"],
    store: ["Store Link","Store","StoreLink","Link"],
    genre: ["Genre"],
    subgenre: ["Subgenre","Subgenre / Stimmung","Subgenre/Stimmung"],
    dev: ["Entwickler","Developer"],
    desc: ["Kurzbeschreibung","Beschreibung"],
    easter: ["Eastereggs","Easter Eggs"],
    special: ["Besonderheiten"],
    main: ["Spielzeit (Main)","Main Story (Std.)","Main"],
    hundred: ["Spielzeit (100%)","100 % (Std.)","100%"],
    meta: ["Metascore","Pressemeinung (√ò)"],
    user: ["Userwertung","Userwertung (√ò)"],
    life: ["Lebenszeit %","% Lebenszeit (Humorstatistik)","% Lebenszeit"],
    hours: ["Gesamtstunden","Gesamtstunden (Humorstatistik)"],
    years: ["Jahre","Jahre (Humorstatistik)"],
    trophies: ["Troph√§en Fortschritt","Fortschritt","Troph√§en","Troph√§en-Fortschritt"],
    completedCol: ["100%","100 %","100% Completed","Completed"], // in deiner Excel gibt‚Äôs eine "100%"-Spalte
    platinumCol: ["Platin","Platinum"],
    fav: ["Favorit","Favorite"],
  };

  // Sort keys (nur die sinnvollen + Reihenfolge wie von dir gew√ºnscht)
  const SORT_KEYS = [
    { key:"ID", label:"ID" },
    { key:"Spieletitel", label:"Spieletitel (Text, stabil)" },
    { key:"System", label:"System" },
    { key:"Quelle", label:"Quelle" },
    { key:"Genre", label:"Genre" },
    { key:"Entwickler", label:"Entwickler" },
    { key:"SpielzeitMain", label:"Spielzeit (Main)" },
    { key:"Metascore", label:"Metascore" },
    { key:"Userwertung", label:"Userwertung" },
    { key:"Lebenszeit", label:"Lebenszeit %" },
  ];

  const els = {
    file: document.getElementById("file"),
    sheet: document.getElementById("sheet"),
    q: document.getElementById("q"),
    list: document.getElementById("list"),
    metaLine: document.getElementById("metaLine"),
    sentinel: document.getElementById("sentinel"),
    fabTop: document.getElementById("fabTop"),
    header: document.getElementById("header"),

    openMenu: document.getElementById("openMenu"),
    closeMenu: document.getElementById("closeMenu"),
    drawer: document.getElementById("drawer"),
    backdrop: document.getElementById("backdrop"),

    sortKey: document.getElementById("sortKey"),
    sortDir: document.getElementById("sortDir"),

    fAll: document.getElementById("fAll"),
    fFav: document.getElementById("fFav"),
    fPlat: document.getElementById("fPlat"),
    f100: document.getElementById("f100"),
    fDel: document.getElementById("fDel"),
    clearFilters: document.getElementById("clearFilters"),
  };

  // drawer chips
  const platChips = Array.from(document.querySelectorAll(".chip[data-plat]"));
  const srcChips  = Array.from(document.querySelectorAll(".chip[data-src]"));

  let workbook = null;
  let rawRows = [];
  let rows = []; // normalized objects
  let visible = [];
  let renderedCount = 0;
  const PAGE = 60;

  // Filters state
  const state = {
    sheetName: "",
    query: "",
    sortKey: "ID",
    sortDir: "asc",
    filterFav: false,
    filterPlat: false,
    filter100: false,
    filterDel: false,
    plats: new Set(), // PS5/PS4/PS3/Vita
    sources: new Set(), // digital/psplus/disc
  };

  // Persistence
  const LS_KEY = "spieleliste_ui_v1";
  function loadState(){
    try{
      const s = JSON.parse(localStorage.getItem(LS_KEY) || "{}");
      if (typeof s.sheetName === "string") state.sheetName = s.sheetName;
      if (typeof s.query === "string") state.query = s.query;
      if (typeof s.sortKey === "string") state.sortKey = s.sortKey;
      if (typeof s.sortDir === "string") state.sortDir = s.sortDir;
      state.filterFav = !!s.filterFav;
      state.filterPlat = !!s.filterPlat;
      state.filter100 = !!s.filter100;
      state.filterDel = !!s.filterDel;
      state.plats = new Set(Array.isArray(s.plats) ? s.plats : []);
      state.sources = new Set(Array.isArray(s.sources) ? s.sources : []);
    }catch{}
  }
  function saveState(){
    const s = {
      sheetName: state.sheetName,
      query: state.query,
      sortKey: state.sortKey,
      sortDir: state.sortDir,
      filterFav: state.filterFav,
      filterPlat: state.filterPlat,
      filter100: state.filter100,
      filterDel: state.filterDel,
      plats: [...state.plats],
      sources: [...state.sources],
    };
    localStorage.setItem(LS_KEY, JSON.stringify(s));
  }

  // ---- Utilities
  const norm = (v) => String(v ?? "").replace(/\s+/g," ").trim();
  const lower = (v) => norm(v).toLowerCase();

  function findHeaderKey(headers, wantedList){
    const map = new Map(headers.map(h => [lower(h), h]));
    for (const w of wantedList){
      const hit = map.get(lower(w));
      if (hit) return hit;
    }
    // fuzzy: ignore punctuation
    const clean = (s)=> lower(s).replace(/[^a-z0-9%√§√∂√º√ü]+/g,"");
    const map2 = new Map(headers.map(h => [clean(h), h]));
    for (const w of wantedList){
      const hit = map2.get(clean(w));
      if (hit) return hit;
    }
    return null;
  }

  function val(row, key){
    const v = row?.[key];
    const s = norm(v);
    return s ? s : "";
  }

  function parseScore(s){
    const t = norm(s);
    if(!t) return NaN;
    const m = t.match(/(\d+(?:[.,]\d+)?)/);
    if(!m) return NaN;
    return parseFloat(m[1].replace(",", "."));
  }
  function parseNumber(s){
    const t = norm(s);
    if(!t) return NaN;
    const m = t.match(/-?\d+(?:[.,]\d+)?/);
    if(!m) return NaN;
    return parseFloat(m[0].replace(",", "."));
  }
  function parseHoursPair(main, hundred){
    const a = parseNumber(main);
    const b = parseNumber(hundred);
    const mainOk = Number.isFinite(a) ? String(a).replace(/\.0+$/,"") : "";
    const hundOk = Number.isFinite(b) ? String(b).replace(/\.0+$/,"") : "";
    if(mainOk || hundOk) return `${mainOk || PLACEHOLDER}h / ${hundOk || PLACEHOLDER}h`;
    return PLACEHOLDER;
  }

  function parseSystems(systemText){
    const t = norm(systemText);
    if(!t) return [];
    // Accept "PS3, PS4, Vita" etc
    const parts = t.split(/[,/|]+/).map(p=>norm(p)).filter(Boolean);
    const normed = [];
    for(const p of parts){
      if(/^ps5$/i.test(p)) normed.push("PS5");
      else if(/^ps4$/i.test(p)) normed.push("PS4");
      else if(/^ps3$/i.test(p)) normed.push("PS3");
      else if(/^vita$/i.test(p) || /^psvita$/i.test(p)) normed.push("Vita");
      else normed.push(p);
    }
    // unique preserve
    return [...new Set(normed)];
  }

  // Source classification
  function sourceClass(sourceText){
    const t = lower(sourceText);
    if(!t) return "";
    if(t.includes("ps plus")) return "psplus";
    if(t.includes("disc")) return "disc";
    if(t.includes("gekauft")) return "digital"; // du willst gekauft als Digital
    return "";
  }

  // Delisted detection
  function isDelisted(row){
    const q = lower(val(row, keyMap.source) + " " + val(row, keyMap.availability));
    return q.includes("aus store entfernt") || q.includes("delisted");
  }

  // Favorit detection
  function isFav(row){
    const f = lower(val(row, keyMap.fav));
    return f === "x" || f === "1" || f === "true" || f === "yes";
  }

  // Parse platform pairs from a trophy cell: "PS4 16 of 20 PS5 10 of 30"
  function parsePlatformPairs(text){
    const t = norm(text);
    if(!t) return [];
    const re = /(PS5|PS4|PS3|Vita)\s*([^PS]*)/gi;
    const out = [];
    let m;
    while((m=re.exec(t))){
      const platform = m[1].toUpperCase()==="VITA" ? "Vita" : m[1].toUpperCase();
      const chunk = norm(m[2]);
      if(chunk) out.push({ platform, text: chunk });
    }
    // If regex fails but contains explicit tokens, do another pass:
    if(out.length===0){
      const tokens = ["PS5","PS4","PS3","Vita"];
      for(const tok of tokens){
        const idx = t.toLowerCase().indexOf(tok.toLowerCase());
        if(idx>=0){
          // naive split: keep as is
        }
      }
    }
    // clean: remove empties
    return out.map(x=>({platform:x.platform, text:norm(x.text)})).filter(x=>x.text);
  }

  function parseFraction(s){
    const t = norm(s);
    const m = t.match(/(\d+)\s*of\s*(\d+)/i);
    if(!m) return null;
    const a = parseInt(m[1],10), b=parseInt(m[2],10);
    if(!b || !Number.isFinite(a) || !Number.isFinite(b)) return null;
    return { a, b, pct: Math.max(0, Math.min(1, a/b)) };
  }

  function progressNode(fr){
    const wrap = document.createElement("div");
    const bar = document.createElement("div");
    bar.className="bar";
    const fill = document.createElement("i");
    fill.style.width = (fr.pct*100).toFixed(0) + "%";
    bar.appendChild(fill);

    const meta = document.createElement("div");
    meta.className="barMeta";
    meta.textContent = `${(fr.pct*100).toFixed(0)}% (${fr.a}/${fr.b})`;

    wrap.appendChild(bar);
    wrap.appendChild(meta);
    return wrap;
  }

  function trophyList(pairs){
    const outer = document.createElement("div");
    outer.className = "trophyList";
    for(const p of pairs){
      const row = document.createElement("div");
      row.className="trophyRow";

      const plat = document.createElement("div");
      plat.className="tPlatform";
      plat.textContent = p.platform;

      const main = document.createElement("div");
      main.className="tMain";

      const line = document.createElement("div");
      line.className="tLine";

      const t = document.createElement("div");
      t.className="tText";
      t.textContent = p.text;

      line.appendChild(t);
      main.appendChild(line);

      const fr = parseFraction(p.text);
      if(fr) main.appendChild(progressNode(fr));

      row.appendChild(plat);
      row.appendChild(main);
      outer.appendChild(row);
    }
    return outer;
  }

  function trophyPlatforms(row){
    // primary: System field
    const sys = parseSystems(val(row, keyMap.system));
    if(sys.length) return sys;

    // fallback: sniff from trophy text if present
    const t = val(row, keyMap.trophies);
    const pairs = parsePlatformPairs(t);
    const p = pairs.map(x=>x.platform);
    return [...new Set(p)];
  }

  // ‚úÖ Singleplatform: show platform even when progress is "16 of 20"
  function trophyNodeFromText(text, row){
    const raw = String(text ?? "").trim();
    if (!raw) return document.createTextNode(PLACEHOLDER);

    const pairs = parsePlatformPairs(raw);
    if (pairs.length) return trophyList(pairs);

    const plats = trophyPlatforms(row);
    if (plats.length === 1){
      return trophyList([{ platform: plats[0], text: raw }]);
    }

    // Multi-platform but no markers -> show as global text + bar if possible
    const outer = document.createElement("div");
    outer.style.display="grid";
    outer.style.gap="8px";

    const txt = document.createElement("div");
    txt.className="tText";
    txt.textContent = raw;
    outer.appendChild(txt);

    const fr = parseFraction(raw);
    if(fr) outer.appendChild(progressNode(fr));
    return outer;
  }

  function computeKompletion(row){
    // rules from you:
    // - if in 100% column: "completed"
    // - OR if Fortschritt has "x of x" anywhere (single or per platform)
    const c = lower(val(row, keyMap.completedCol));
    if(c.includes("completed")) return "done";

    const t = val(row, keyMap.trophies);
    if(!t) return ""; // unknown
    const pairs = parsePlatformPairs(t);
    if(pairs.length){
      for(const p of pairs){
        const fr = parseFraction(p.text);
        if(fr && fr.a===fr.b) return "done";
      }
      // if any progress exists but none complete -> in work
      for(const p of pairs){
        const fr = parseFraction(p.text);
        if(fr && fr.a>0) return "work";
      }
      return "sleep";
    }else{
      const fr = parseFraction(t);
      if(fr && fr.a===fr.b) return "done";
      if(fr && fr.a>0) return "work";
      // if explicitly "---" or empty handled earlier
      return "sleep";
    }
  }

  function computePlatin(row){
    // if Platin column contains "Platinum" / "Platin" or per platform,
    // else if empty but progress exists => in work, else sleep
    const p = lower(val(row, keyMap.platinumCol));
    const sys = trophyPlatforms(row);

    if(p.includes("platinum") || p.includes("platin")){
      return { state:"done", plats: sys.length?sys:[] };
    }
    if(p){
      // might be "PS4 Platinum PS5 ---" etc
      if(p.includes("ps4") || p.includes("ps5") || p.includes("ps3") || p.includes("vita")){
        const pairs = parsePlatformPairs(val(row, keyMap.platinumCol));
        const anyDone = pairs.some(x => lower(x.text).includes("platinum") || lower(x.text).includes("platin"));
        const anyWork = pairs.some(x => x.text && x.text!==PLACEHOLDER && x.text!=="---" && !lower(x.text).includes("‚Äî"));
        if(anyDone) return { state:"done", plats: pairs.filter(x=>lower(x.text).includes("platinum")||lower(x.text).includes("platin")).map(x=>x.platform) };
        if(anyWork) return { state:"work", plats: sys.length?sys:[] };
      }
      // unknown text -> assume work
      return { state:"work", plats: sys.length?sys:[] };
    }

    // no platin text: infer from trophies progress
    const t = val(row, keyMap.trophies);
    const fr = parseFraction(t);
    if(fr && fr.a>0) return { state:"work", plats: sys.length?sys:[] };
    const pairs = parsePlatformPairs(t);
    if(pairs.some(x => (parseFraction(x.text)||{a:0}).a>0)) return { state:"work", plats: sys.length?sys:[] };

    return { state:"sleep", plats: sys.length?sys:[] };
  }

  // ---- UI helpers
  function el(tag, cls, txt){
    const e = document.createElement(tag);
    if(cls) e.className=cls;
    if(txt!=null) e.textContent=txt;
    return e;
  }

  function linkNode(storeText, storeUrl){
    const url = norm(storeUrl);
    if(!url) return document.createTextNode(PLACEHOLDER);

    // store text might be "Store Link" in the cell. We'll always show "Store Link" clickable.
    const a = document.createElement("a");
    a.href = url;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    a.textContent = "Store Link";
    a.style.color = "#1f3aa7";
    a.style.fontWeight = "650";
    return a;
  }

  function kvLine(k, vNodeOrText, mono=false){
    const wrap = el("div","kv");
    const kk = el("div","k",k);
    const vv = el("div","v" + (mono ? " mono":""), "");
    if(vNodeOrText instanceof Node) vv.appendChild(vNodeOrText);
    else vv.textContent = vNodeOrText || PLACEHOLDER;

    wrap.appendChild(kk);
    wrap.appendChild(vv);
    return wrap;
  }

  function foldBlock(label, content){
    const box = el("div","fold");
    const head = el("div","foldHead");
    const left = el("div","", `‚ñ∂ ${label} anzeigen`);
    const right = el("div","", "‚ñæ");
    right.style.color = "#6b7280";
    head.appendChild(left);
    head.appendChild(right);

    const body = el("div","foldBody", content || PLACEHOLDER);

    head.addEventListener("click", ()=>{
      const open = box.classList.toggle("open");
      left.textContent = (open ? "‚ñº " : "‚ñ∂ ") + `${label} anzeigen`;
      right.textContent = open ? "‚ñ¥" : "‚ñæ";
    });

    box.appendChild(head);
    box.appendChild(body);
    return box;
  }

  // ---- XLSX / CSV reading
  let keyMap = {}; // resolved header keys

  async function readFile(file){
    const name = (file?.name || "").toLowerCase();
    if(name.endsWith(".csv")){
      const text = await file.text();
      // Try UTF-8 (browser already), fallback not needed typically on GitHub Pages.
      const rows = parseCSV(text);
      return { type:"csv", sheets: {"CSV": rows} };
    }
    // XLSX
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type:"array", cellText:true, cellDates:true });
    return { type:"xlsx", wb };
  }

  function sheetToRows(wb, sheetName){
    const ws = wb.Sheets[sheetName];
    const json = XLSX.utils.sheet_to_json(ws, { defval:"", raw:false });
    return json;
  }

  function parseCSV(text){
    // lightweight CSV parser (comma or semicolon)
    const lines = text.replace(/\r/g,"").split("\n").filter(l=>l.length>0);
    if(!lines.length) return [];
    const sep = (lines[0].includes(";") && !lines[0].includes(",")) ? ";" : ",";
    const headers = splitCSVLine(lines[0], sep).map(h=>h.trim());
    const out = [];
    for(let i=1;i<lines.length;i++){
      const cols = splitCSVLine(lines[i], sep);
      const obj = {};
      headers.forEach((h,idx)=> obj[h] = cols[idx] ?? "");
      out.push(obj);
    }
    return out;
  }

  function splitCSVLine(line, sep){
    const out=[]; let cur=""; let q=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(ch === '"'){
        if(q && line[i+1]==='"'){ cur+='"'; i++; }
        else q=!q;
      }else if(!q && ch===sep){
        out.push(cur); cur="";
      }else{
        cur+=ch;
      }
    }
    out.push(cur);
    return out;
  }

  function resolveKeyMap(headers){
    const map = {};
    for(const [k, list] of Object.entries(COL)){
      map[k] = findHeaderKey(headers, list);
    }
    return map;
  }

  function normalizeRows(rowsIn){
    const headers = rowsIn.length ? Object.keys(rowsIn[0]) : [];
    keyMap = resolveKeyMap(headers);

    // if required keys missing, we still proceed, but some values empty.
    return rowsIn.map(r => ({
      _raw: r,
      id: val(r, keyMap.id),
      title: val(r, keyMap.title),
      system: val(r, keyMap.system),
      source: val(r, keyMap.source),
      availability: val(r, keyMap.availability),
      storeUrl: val(r, keyMap.store),
      genre: val(r, keyMap.genre),
      subgenre: val(r, keyMap.subgenre),
      dev: val(r, keyMap.dev),
      desc: val(r, keyMap.desc),
      special: val(r, keyMap.special),
      easter: val(r, keyMap.easter),
      main: val(r, keyMap.main),
      hundred: val(r, keyMap.hundred),
      meta: val(r, keyMap.meta),
      user: val(r, keyMap.user),
      life: val(r, keyMap.life),
      hours: val(r, keyMap.hours),
      years: val(r, keyMap.years),
      trophies: val(r, keyMap.trophies),
      completedCol: val(r, keyMap.completedCol),
      platinumCol: val(r, keyMap.platinumCol),
      fav: val(r, keyMap.fav),
    })).filter(x => x.title || x.id); // ignore empty rows
  }

  // ---- Query parsing
  function parseQuery(q){
    const t = norm(q);
    const tokens = t.split(/\s+/).filter(Boolean);
    const spec = { id:null, dev:null, wantsDelisted:false, plats:new Set(), text:[] };
    for(const tok of tokens){
      const low = tok.toLowerCase();
      if(low.startsWith("id:")) spec.id = low.slice(3);
      else if(low.startsWith("dev:")) spec.dev = low.slice(4);
      else if(low === "delisted") spec.wantsDelisted = true;
      else if(["ps5","ps4","ps3","vita"].includes(low)) spec.plats.add(low.toUpperCase()==="VITA"?"Vita":low.toUpperCase());
      else spec.text.push(tok);
    }
    spec.text = spec.text.join(" ").toLowerCase();
    return spec;
  }

  // ---- Filtering + Sorting
  function applyAll(){
    if(!rows.length){
      els.list.innerHTML = "";
      els.metaLine.textContent = "Datei w√§hlen ‚Üí Sheet w√§hlen ‚Üí suchen";
      return;
    }

    const q = parseQuery(state.query);
    let filtered = rows;

    // query filters
    if(q.id){
      filtered = filtered.filter(r => String(r.id).toLowerCase().includes(q.id));
    }
    if(q.dev){
      filtered = filtered.filter(r => lower(r.dev).includes(q.dev));
    }
    if(q.wantsDelisted){
      filtered = filtered.filter(r => r._isDelisted);
    }
    if(q.plats.size){
      filtered = filtered.filter(r => r._plats.some(p=>q.plats.has(p)));
    }
    if(q.text){
      filtered = filtered.filter(r => r._hay.includes(q.text));
    }

    // drawer filters
    if(state.filterFav) filtered = filtered.filter(r => r._fav);
    if(state.filterDel) filtered = filtered.filter(r => r._isDelisted);

    if(state.filter100) filtered = filtered.filter(r => r._kompl === "done");
    if(state.filterPlat) filtered = filtered.filter(r => r._platin.state === "done");

    if(state.plats.size){
      filtered = filtered.filter(r => r._plats.some(p=>state.plats.has(p)));
    }
    if(state.sources.size){
      filtered = filtered.filter(r => state.sources.has(r._srcClass));
    }

    // sort
    filtered = stableSort(filtered, state.sortKey, state.sortDir);

    visible = filtered;
    renderedCount = 0;
    els.list.innerHTML = "";
    renderMore(true);
    updateMeta();
    saveState();
  }

  function stableSort(arr, key, dir){
    const sign = dir === "desc" ? -1 : 1;
    const coll = new Intl.Collator("de", { sensitivity:"base", numeric:true });

    // stable: decorate with index
    const deco = arr.map((v,i)=>({v,i}));

    function getSortVal(r){
      switch(key){
        case "ID": return parseNumber(r.id);
        case "Spieletitel": return r.title || "";
        case "System": return (r.system || "");
        case "Quelle": return (r.source || "");
        case "Genre": return (r.genre || "");
        case "Entwickler": return (r.dev || "");
        case "SpielzeitMain": return parseNumber(r.main);
        case "Metascore": return parseScore(r.meta);
        case "Userwertung": return parseScore(r.user);
        case "Lebenszeit": return parseNumber(r.life);
        default: return r.title || "";
      }
    }

    deco.sort((a,b)=>{
      const ra=a.v, rb=b.v;
      const va=getSortVal(ra), vb=getSortVal(rb);

      // numbers
      const na = typeof va === "number" && Number.isFinite(va);
      const nb = typeof vb === "number" && Number.isFinite(vb);
      if(na || nb){
        if(!na && !nb) return a.i - b.i;
        if(!na) return 1;
        if(!nb) return -1;
        if(va<vb) return -1*sign;
        if(va>vb) return 1*sign;
        return a.i - b.i;
      }

      // strings
      const sa = String(va ?? "");
      const sb = String(vb ?? "");
      const c = coll.compare(sa, sb);
      if(c!==0) return c*sign;
      return a.i - b.i;
    });

    return deco.map(x=>x.v);
  }

  function updateMeta(){
    const total = visible.length;
    const shown = Math.min(renderedCount, total);
    els.metaLine.textContent = `Treffer: ${total} ¬∑ angezeigt: ${shown}/${total}`;
  }

  // ---- Rendering
  function renderMore(reset=false){
    if(reset) renderedCount = 0;

    const target = Math.min(renderedCount + PAGE, visible.length);
    for(let i=renderedCount;i<target;i++){
      els.list.appendChild(renderCard(visible[i]));
    }
    renderedCount = target;
    updateMeta();
  }

  function renderCard(r){
    const card = el("div","card" + (r._isDelisted ? " delisted": ""));
    const top = el("div","cardTop");

    const left = el("div","");
    const h = el("h2","gameTitle", r.title || PLACEHOLDER);
    left.appendChild(h);

    const badges = el("div","badges");
    if(r._fav) badges.appendChild(badge("‚≠ê Favorit","fav"));

    // Platin badge state
    if(r._platin.state === "done") badges.appendChild(badge("üíé Platin erlangt","plat"));
    else if(r._platin.state === "work") badges.appendChild(badge("‚è≥ In Arbeit","work"));
    // sleep not shown as badge in header

    // Kompletion badge state (100%)
    if(r._kompl === "done") badges.appendChild(badge("‚úÖ 100% erreicht","c100"));
    else if(r._kompl === "work") badges.appendChild(badge("‚è≥ In Arbeit","work"));
    else if(r._kompl === "sleep") badges.appendChild(badge("üí§ Ungespielt","sleep"));

    top.appendChild(left);
    top.appendChild(badges);
    card.appendChild(top);

    // Pills row: ID + platforms + availability
    const pills = el("div","subBadges");
    pills.appendChild(el("div","pill id", `ID ${r.id || "?"}`));

    for(const p of r._plats){
      pills.appendChild(el("div","pill", p));
    }
    pills.appendChild(el("div","pill status", r.availability || PLACEHOLDER));
    card.appendChild(pills);

    // Reduced view (only these fields)
    card.appendChild(kvLine("Genre", r.genre || PLACEHOLDER));
    card.appendChild(kvLine("Entwickler", r.dev || PLACEHOLDER));
    card.appendChild(kvLine("Spielzeit", parseHoursPair(r.main, r.hundred), true));
    card.appendChild(kvLine("Metascore", r.meta || PLACEHOLDER, true));
    card.appendChild(kvLine("Userwertung", r.user || PLACEHOLDER, true));

    // Details toggle (state text)
    const toggle = el("div","detailsToggle");
    const icon = el("span","", "‚ñ∂");
    const txt = el("span","", "Mehr Details");
    const caret = el("span","", "‚ñæ");
    caret.style.color = "#6b7280";
    toggle.appendChild(icon);
    toggle.appendChild(txt);
    toggle.appendChild(caret);

    const details = el("div","details");

    toggle.addEventListener("click", ()=>{
      const open = details.classList.toggle("open");
      icon.textContent = open ? "‚ñº" : "‚ñ∂";
      txt.textContent = open ? "Weniger Details" : "Mehr Details";
      caret.textContent = open ? "‚ñ¥" : "‚ñæ";
    });

    card.appendChild(toggle);

    // ---- DETAILS CONTENT
    // BESCHREIBUNG
    details.appendChild(el("div","sectionTitle","BESCHREIBUNG"));
    details.appendChild(foldBlock("Kurzbeschreibung", r.desc || PLACEHOLDER));
    details.appendChild(el("div","foldSubGap",""));

    // STORE (Quelle wieder hier oben!)
    details.appendChild(el("div","sectionTitle","STORE"));
    details.appendChild(kvLine("Quelle", (r._srcLabel || r.source) || PLACEHOLDER));
    details.appendChild(kvLine("Store", linkNode("Store Link", r.storeUrl)));
    details.appendChild(kvLine("Verf√ºgbarkeit", r.availability || PLACEHOLDER));

    // Subgenre / Stimmung & System optional im Detailbereich:
    details.appendChild(el("div","sectionTitle","DETAILS"));
    details.appendChild(kvLine("System", r.system || PLACEHOLDER));
    details.appendChild(kvLine("Subgenre / Stimmung", r.subgenre || PLACEHOLDER));

    // EXTRAS
    details.appendChild(el("div","sectionTitle","EXTRAS"));
    details.appendChild(foldBlock("Besonderheiten", r.special || PLACEHOLDER));
    details.appendChild(el("div","foldSubGap",""));
    details.appendChild(foldBlock("Eastereggs", r.easter || PLACEHOLDER));

    // TROPH√ÑEN
    details.appendChild(el("div","sectionTitle","TROPH√ÑEN"));
    details.appendChild(kvLine("Fortschritt", trophyNodeFromText(r.trophies, r._raw)));

    // Kompletion + Platin lines (badges inside)
    details.appendChild(kvLine("Kompletion", kompletionBadge(r._kompl)));
    details.appendChild(kvLine("Platin", platinBadge(r._platin.state)));

    // HUMORSTATISTIK
    details.appendChild(el("div","sectionTitle","HUMORSTATISTIK"));
    details.appendChild(kvLine("Gesamtstunden", r.hours || PLACEHOLDER, true));
    details.appendChild(kvLine("Lebenszeit %", r.life || PLACEHOLDER, true));
    details.appendChild(kvLine("Jahre", r.years || PLACEHOLDER, true));

    card.appendChild(details);
    return card;
  }

  function badge(text, kind){
    const b = el("div","badge " + kind, text);
    return b;
  }
  function kompletionBadge(state){
    if(state==="done") return badge("‚úÖ 100% erreicht","c100");
    if(state==="work") return badge("‚è≥ In Arbeit","work");
    if(state==="sleep") return badge("üí§ Ungespielt","sleep");
    return document.createTextNode(PLACEHOLDER);
  }
  function platinBadge(state){
    if(state==="done") return badge("üíé Platin erlangt","plat");
    if(state==="work") return badge("‚è≥ In Arbeit","work");
    if(state==="sleep") return badge("üí§ Ungespielt","sleep");
    return document.createTextNode(PLACEHOLDER);
  }

  // ---- Infinite scroll
  const io = new IntersectionObserver((entries)=>{
    const e = entries[0];
    if(e.isIntersecting){
      if(renderedCount < visible.length){
        renderMore();
      }
    }
  }, { root:null, threshold:0.1 });
  io.observe(els.sentinel);

  // ---- Top button
  els.fabTop.addEventListener("click", ()=> window.scrollTo({ top:0, behavior:"smooth" }));
  window.addEventListener("scroll", ()=>{
    els.fabTop.classList.toggle("show", window.scrollY > 700);
  }, { passive:true });

  // ---- Header collapse (ohne Flackern)
  let lastY = 0;
  let ticking = false;
  window.addEventListener("scroll", ()=>{
    if(ticking) return;
    ticking = true;
    requestAnimationFrame(()=>{
      const y = window.scrollY || 0;
      // collapse when scrolling down past 120
      if(y > 120 && y > lastY) els.header.classList.add("collapsed");
      if(y < 80) els.header.classList.remove("collapsed");
      lastY = y;
      ticking = false;
    });
  }, { passive:true });

  // ---- Drawer open/close
  function openDrawer(){
    els.drawer.classList.add("show");
    els.backdrop.classList.add("show");
  }
  function closeDrawer(){
    els.drawer.classList.remove("show");
    els.backdrop.classList.remove("show");
  }
  els.openMenu.addEventListener("click", openDrawer);
  els.closeMenu.addEventListener("click", closeDrawer);
  els.backdrop.addEventListener("click", closeDrawer);

  // ---- Build sort dropdown
  function fillSortDropdown(){
    els.sortKey.innerHTML = "";
    for(const s of SORT_KEYS){
      const opt = document.createElement("option");
      opt.value = s.key;
      opt.textContent = s.label;
      els.sortKey.appendChild(opt);
    }
    els.sortKey.value = state.sortKey;
    els.sortDir.value = state.sortDir;
  }

  // ---- Filter chips behavior
  function syncChips(){
    els.fFav.classList.toggle("on", state.filterFav);
    els.fPlat.classList.toggle("on", state.filterPlat);
    els.f100.classList.toggle("on", state.filter100);
    els.fDel.classList.toggle("on", state.filterDel);

    // plats
    for(const c of platChips){
      const p = c.getAttribute("data-plat");
      c.classList.toggle("on", state.plats.has(p));
    }
    // sources
    for(const c of srcChips){
      const s = c.getAttribute("data-src");
      c.classList.toggle("on", state.sources.has(s));
    }

    // "Alle" on when no filter selected (except query)
    const any =
      state.filterFav || state.filterPlat || state.filter100 || state.filterDel ||
      state.plats.size || state.sources.size;
    els.fAll.classList.toggle("on", !any);
  }

  els.fAll.addEventListener("click", ()=>{
    state.filterFav=false; state.filterPlat=false; state.filter100=false; state.filterDel=false;
    state.plats.clear(); state.sources.clear();
    syncChips(); applyAll();
  });
  els.fFav.addEventListener("click", ()=>{ state.filterFav=!state.filterFav; syncChips(); applyAll(); });
  els.fPlat.addEventListener("click", ()=>{ state.filterPlat=!state.filterPlat; syncChips(); applyAll(); });
  els.f100.addEventListener("click", ()=>{ state.filter100=!state.filter100; syncChips(); applyAll(); });
  els.fDel.addEventListener("click", ()=>{ state.filterDel=!state.filterDel; syncChips(); applyAll(); });

  for(const c of platChips){
    c.addEventListener("click", ()=>{
      const p = c.getAttribute("data-plat");
      if(state.plats.has(p)) state.plats.delete(p); else state.plats.add(p);
      syncChips(); applyAll();
    });
  }
  for(const c of srcChips){
    c.addEventListener("click", ()=>{
      const s = c.getAttribute("data-src");
      if(state.sources.has(s)) state.sources.delete(s); else state.sources.add(s);
      syncChips(); applyAll();
    });
  }

  els.clearFilters.addEventListener("click", ()=>{
    state.filterFav=false; state.filterPlat=false; state.filter100=false; state.filterDel=false;
    state.plats.clear(); state.sources.clear();
    syncChips(); applyAll();
  });

  els.sortKey.addEventListener("change", ()=>{
    state.sortKey = els.sortKey.value;
    applyAll();
  });
  els.sortDir.addEventListener("change", ()=>{
    state.sortDir = els.sortDir.value;
    applyAll();
  });

  // ---- Search
  let qTimer = null;
  els.q.addEventListener("input", ()=>{
    clearTimeout(qTimer);
    qTimer = setTimeout(()=>{
      state.query = els.q.value;
      applyAll();
    }, 120);
  });

  // ---- File load
  els.file.addEventListener("change", async ()=>{
    const f = els.file.files?.[0];
    if(!f) return;

    els.metaLine.textContent = "Lese Datei‚Ä¶";
    els.sheet.disabled = true;
    els.sheet.innerHTML = `<option value="">Sheet ausw√§hlen‚Ä¶</option>`;
    els.list.innerHTML = "";
    rows = []; rawRows = []; visible = []; renderedCount = 0;
    workbook = null;

    try{
      const res = await readFile(f);

      if(res.type === "csv"){
        // CSV: one pseudo sheet
        workbook = { type:"csv", sheets: res.sheets };
        const names = Object.keys(res.sheets);
        els.sheet.disabled = false;
        els.sheet.innerHTML = names.map(n=>`<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join("");
        const wanted = state.sheetName && names.includes(state.sheetName) ? state.sheetName : names[0];
        els.sheet.value = wanted;
        state.sheetName = wanted;
        rawRows = res.sheets[wanted];
      }else{
        workbook = res.wb;
        const names = workbook.SheetNames || [];
        els.sheet.disabled = false;
        els.sheet.innerHTML = names.map(n=>`<option value="${escapeHtml(n)}">${escapeHtml(n)}</option>`).join("");
        const wanted = state.sheetName && names.includes(state.sheetName) ? state.sheetName : (names.includes("Spieleliste Komplett") ? "Spieleliste Komplett" : names[0]);
        els.sheet.value = wanted;
        state.sheetName = wanted;
        rawRows = sheetToRows(workbook, wanted);
      }

      rows = normalizeRows(rawRows);

      // precompute searchable + computed flags
      for(const r of rows){
        const sys = parseSystems(r.system);
        r._plats = sys;
        r._srcClass = sourceClass(r.source);
        r._srcLabel = r._srcClass==="digital" ? "Digital" : (r._srcClass==="psplus" ? "PS Plus" : (r._srcClass==="disc" ? "Disc" : r.source));
        r._fav = isFav(r._raw);
        r._isDelisted = isDelisted(r._raw);

        r._kompl = computeKompletion(r._raw); // done/work/sleep
        r._platin = computePlatin(r._raw); // {state, plats}

        // haystack
        r._hay = lower([
          r.id, r.title, r.system, r.source, r.availability, r.genre,
          r.subgenre, r.dev, r.desc, r.special, r.easter,
          r.main, r.hundred, r.meta, r.user, r.life, r.trophies
        ].join(" "));
      }

      // apply persisted UI
      els.q.value = state.query || "";
      fillSortDropdown();
      syncChips();

      applyAll();
    }catch(err){
      els.metaLine.textContent = "Fehler beim Einlesen: " + (err?.message || err);
      console.error(err);
    }
  });

  // ---- Sheet change
  els.sheet.addEventListener("change", ()=>{
    const name = els.sheet.value;
    if(!name) return;
    state.sheetName = name;

    try{
      if(workbook && workbook.type === "csv"){
        rawRows = workbook.sheets[name] || [];
      }else if(workbook){
        rawRows = sheetToRows(workbook, name);
      }else{
        rawRows = [];
      }
      rows = normalizeRows(rawRows);

      for(const r of rows){
        const sys = parseSystems(r.system);
        r._plats = sys;
        r._srcClass = sourceClass(r.source);
        r._srcLabel = r._srcClass==="digital" ? "Digital" : (r._srcClass==="psplus" ? "PS Plus" : (r._srcClass==="disc" ? "Disc" : r.source));
        r._fav = isFav(r._raw);
        r._isDelisted = isDelisted(r._raw);
        r._kompl = computeKompletion(r._raw);
        r._platin = computePlatin(r._raw);

        r._hay = lower([
          r.id, r.title, r.system, r.source, r.availability, r.genre,
          r.subgenre, r.dev, r.desc, r.special, r.easter,
          r.main, r.hundred, r.meta, r.user, r.life, r.trophies
        ].join(" "));
      }
      applyAll();
    }catch(err){
      els.metaLine.textContent = "Fehler beim Sheet: " + (err?.message || err);
    }
  });

  // ---- Init
  loadState();
  fillSortDropdown();
  syncChips();
  els.q.value = state.query || "";

  // helper
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

})();
</script>

</body>
</html>