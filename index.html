<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spieleliste</title>
<style>
:root{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  --bg:#f6f7f9;
  --card:#fff;
  --text:#111;
  --muted:#6b7280;
  --line:#e9e9e9;
  --accent:#2536a4;
  --danger:#b00020;
  --dangerBg:#ffe7ea;
  --chipBg:#eef2ff;
}
body{margin:0;background:var(--bg);color:var(--text)}
header{
  position:sticky;top:0;z-index:10;
  background:#fff;border-bottom:1px solid #e7e7e7;
  padding:12px 14px;display:grid;gap:10px;
  transition: padding .18s ease, gap .18s ease;
}
header.compact{
  padding:10px 14px;
  gap:8px;
}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.row.tight{gap:8px}
input,select,button{
  flex:1;min-width:150px;
  padding:10px 12px;border:1px solid #ddd;border-radius:12px;
  background:#fff;font-size:14px
}
button{cursor:pointer}
button:disabled{opacity:.6;cursor:not-allowed}

main{padding:14px}
.hint{color:var(--muted);font-size:13px}
.counter{font-size:12px;color:#555}
.grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(310px,1fr));gap:12px}

.card{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:16px;
  padding:12px;
  box-shadow:0 1px 2px rgba(0,0,0,.04);
  display:grid;gap:10px
}
.cardTop{display:grid;gap:6px}
.titleRow{
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:start;
}
.title{font-weight:800;font-size:16px;line-height:1.15}
.title.delisted{ text-decoration:line-through; color:var(--danger); }

.badges{
  display:flex;
  flex-direction:column;
  gap:8px;
  align-items:flex-end;
  justify-content:flex-start;
  min-width:120px;
}
.badge{
  width:fit-content;
  font-size:12px;font-weight:650;
  padding:4px 8px;border-radius:999px;
  background:var(--chipBg);color:var(--accent);
  white-space:nowrap
}
.badge.delisted{background:var(--dangerBg);color:var(--danger)}
.badge.platin{background:#eef2ff;color:#1f2a8a}

.metaRow{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.chip{
  font-size:12px;color:#374151;
  background:#f3f4f6;border:1px solid #ececec;
  padding:4px 8px;border-radius:999px;
  white-space:nowrap
}
.chip.on{background:var(--chipBg);border-color:#d7ddff;color:var(--accent)}
.chip.btn{cursor:pointer; user-select:none}
.chip.btn:active{transform:translateY(1px)}

.idBadge{
  font-size:12px;
  font-weight:900;
  letter-spacing:.02em;
  padding:4px 10px;
  border-radius:999px;
  background:var(--accent);
  color:#fff;
}

.keyFacts{
  display:grid;gap:8px;
  border-top:1px solid var(--line);
  padding-top:10px
}
.kvLine{
  display:grid;
  grid-template-columns:120px 1fr;
  gap:10px;align-items:start
}
.k{color:var(--muted);font-size:12px}
.v{font-size:13px;word-break:break-word}

.detailsWrap{border-top:1px solid var(--line);padding-top:10px}
details{border:0}
summary{
  cursor:pointer;color:var(--accent);
  font-size:13px;user-select:none
}
summary::-webkit-details-marker{display:none}
.summaryBtn{display:inline-flex;align-items:center;gap:8px}
.summaryBtn::after{content:"‚ñæ";font-size:12px;transform:translateY(-1px)}
details[open] .summaryBtn::after{content:"‚ñ¥"}

.section{
  border-top:1px solid var(--line);
  padding-top:10px;
  margin-top:10px;
  display:grid;gap:8px
}
.sectionTitle{
  font-size:11px;
  letter-spacing:.08em;
  color:var(--muted);
  text-transform:uppercase;
}

.subdetails summary{color:#374151;font-size:13px}
.subdetails .summaryBtn{color:#374151}
.subdetails .summaryBtn::after{color:#6b7280}
.subdetails .content{ margin-top: 8px; }
.subdetails .contentText{ line-height:1.35; white-space:pre-line }

a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}

/* Trophy */
.trophyList{display:grid;gap:8px}
.trophyRow{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:start}
.platformChip{
  font-size:11px;font-weight:800;
  padding:2px 8px;border-radius:999px;
  background:#f3f4f6;border:1px solid #ececec;color:#374151;
  height:fit-content
}
.trophyRight{display:grid;gap:6px}
.trophyText{font-size:13px;color:#111;line-height:1.2}
.progressWrap{display:grid;gap:4px}
.progressBar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
.progressFill{height:100%;background:var(--accent);width:0%}
.progressLabel{font-size:12px;color:var(--muted)}

/* Floating Top Button */
#fabTop{
  position:fixed;right:14px;bottom:16px;z-index:50;
  display:none;border-radius:999px;
  padding:12px 14px;border:1px solid #ddd;background:#fff;
  box-shadow:0 10px 24px rgba(0,0,0,.12);
  font-weight:700;
}
#fabTop.show{display:inline-flex}

/* Mini Trefferhilfe */
#helpBox{
  border:1px solid #eee;border-radius:12px;
  padding:8px 10px;background:#fafafa;color:#374151;
  font-size:12px;line-height:1.35;
}
#helpBox summary{color:#374151}
#helpBox .examples{color:#6b7280}
header.compact #helpBox{display:none} /* im kompakten Modus ausblenden */

/* Header sections hide/show in compact mode */
#rowTitle{display:flex}
header.compact #rowTitle{display:none}
header.compact #rowFile{display:none}
header.compact #filtersRow{display:none}

/* Sentinel */
#sentinel{height:1px}
</style>
</head>
<body>

<header id="hdr">
  <div class="row" id="rowTitle">
    <strong>Spieleliste</strong>
    <span class="hint">Sort (alle Spalten) ¬∑ Infinite Scroll ¬∑ Query-Suche ¬∑ Persistenz ¬∑ CSV</span>
  </div>

  <div class="row" id="rowFile">
    <input id="file" type="file" accept=".xlsx,.xls,.csv,text/csv" />
    <select id="sheetSelect" disabled><option>Sheet ausw√§hlen‚Ä¶</option></select>
  </div>

  <div class="row tight" id="rowSearch">
    <input id="search" type="search" placeholder="Suche‚Ä¶ (z.B. id:643 dev:capcom platform:ps5 fav:1)" disabled />
    <select id="sortSelect" disabled>
      <option value="__id">Sort: ID</option>
    </select>
    <button id="sortDirBtn" disabled>‚Üë</button>
  </div>

  <details id="helpBox">
    <summary>‚ìò Suche & Filter kurz erkl√§rt</summary>
    <div class="examples">
      Beispiele: <code>id:622</code> ¬∑ <code>dev:naughty</code> ¬∑ <code>platform:ps5</code> ¬∑ <code>fav:1</code> ¬∑ <code>platin:1</code> ¬∑ <code>delisted:1</code><br/>
      Text ohne Prefix sucht √ºberall: <code>LittleBigPlanet</code>
    </div>
  </details>

  <div class="row" id="filtersRow">
    <span class="chip btn" data-filter="fav">‚≠ê Favorit</span>
    <span class="chip btn" data-filter="platin">üíé Platin</span>
    <span class="chip btn" data-filter="delisted">Delisted</span>
    <span class="chip btn" data-filter="ps5">PS5</span>
    <span class="chip btn" data-filter="ps4">PS4</span>
    <span class="chip btn" data-filter="ps3">PS3</span>
    <span class="chip btn" data-filter="vita">Vita</span>
    <button id="clearFiltersBtn" disabled>Filter l√∂schen</button>
  </div>

  <div class="row">
    <span id="status" class="hint">Datei w√§hlen ‚Üí Sheet w√§hlen ‚Üí suchen</span>
    <span id="count" class="counter"></span>
  </div>
</header>

<main>
  <div id="grid" class="grid"></div>
  <div id="sentinel"></div>
</main>

<button id="fabTop" aria-label="Nach oben">‚Üë Top</button>

<script src="xlsx.full.min.js"></script>
<script>
/* ========== Settings ========== */
const PAGE_SIZE = 40;                    // kleiner = smoother infinite scroll
const PLACEHOLDER = "‚Äî";
const SHOW_EMPTY_IN_KEYFACTS = true;
const SHOW_EMPTY_IN_DETAILS  = true;
const STORAGE_KEY = "spieleliste_view_state_v2";

const COL_ALIASES = {
  id: ["ID"],
  title: ["Spieletitel","Spiel","Titel","Name"],
  fav: ["Favorit","Favorite"],
  system: ["System","Plattform","Platform"],
  availability: ["Verf√ºgbarkeit","Verfuegbarkeit","Availability"],
  store: ["Store Link","Store-Link","StoreLink","Store"],
  source: ["Quelle","Source"],
  genre: ["Genre"],
  subgenre: ["Subgenre","Subgenre / Stimmung","Subgenre/Stimmung"],
  dev: ["Entwickler","Developer","Studio"],
  desc: ["Kurzbeschreibung","Beschreibung","Description"],
  easter: ["Eastereggs","Easter Eggs"],
  special: ["Besonderheiten","Highlights"],
  main: ["Spielzeit (Main)","Spielzeit Main","Main Story (Std.)","Main Story"],
  hundred: ["Spielzeit (100%)","Spielzeit 100%","100 % (Std.)","100% (Std.)","100%"],
  meta: ["Metascore","Pressemeinung (√ò)"],
  user: ["Userwertung","Userwertung (√ò)"],
  trophies: ["Troph√§en Fortschritt","Troph√§en-Fortschritt","Troph√§enfortschritt","Trophies Progress"],
  platinum: ["Platin","Platinum"],
  hours: ["Gesamtstunden (Humorstatistik)","Humorstatistik ‚Äì Gesamtstunden"],
  life: ["% Lebenszeit (Humorstatistik)","Humorstatistik ‚Äì % Lebenszeit"],
  years: ["Jahre (Humorstatistik)","Humorstatistik ‚Äì Jahre"],
};
let COL = {};

const PLATFORM_LIST = ["PS5","PS4","PS3","PS2","PS1","PSVita","Vita","PC","Switch","Xbox","Series","One"];
const PLATFORM_CANON = { "psvita":"vita", "vita":"vita", "ps5":"ps5", "ps4":"ps4", "ps3":"ps3" };

/* ========== DOM ========== */
const els = {
  hdr: document.getElementById("hdr"),
  file: document.getElementById("file"),
  sheet: document.getElementById("sheetSelect"),
  search: document.getElementById("search"),
  sort: document.getElementById("sortSelect"),
  sortDir: document.getElementById("sortDirBtn"),
  filtersRow: document.getElementById("filtersRow"),
  clearFilters: document.getElementById("clearFiltersBtn"),
  status: document.getElementById("status"),
  count: document.getElementById("count"),
  grid: document.getElementById("grid"),
  fabTop: document.getElementById("fabTop"),
  sentinel: document.getElementById("sentinel"),
};

const s = v => (v == null ? "" : String(v).trim());

/* ========== State ========== */
let workbook = null;
let allRows = [];
let matches = [];
let shown = 0;
let columns = [];
let linkMap = new Map();   // XLSX only
let headerRowIndex = 1;    // 1-based header row

const viewState = {
  fileMode: "",            // "xlsx" | "csv"
  sheetName: "",
  search: "",
  sortKey: "__id",         // internal
  sortDir: "asc",
  filters: { fav:false, platin:false, delisted:false, ps5:false, ps4:false, ps3:false, vita:false },
};

/* ========== Persistenz ========== */
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const st = JSON.parse(raw);
    if (st && typeof st === "object"){
      Object.assign(viewState, st);
      if (st.filters) Object.assign(viewState.filters, st.filters);
    }
  }catch(e){}
}
function saveState(){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(viewState)); }catch(e){}
}
loadState();

/* ========== Column resolver ========== */
function normHeader(x){
  return String(x ?? "")
    .replace(/\u00A0/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();
}
function resolveColumns(cols){
  const byNorm = new Map(cols.map(c => [normHeader(c), c]));
  const resolved = {};
  for (const [key, aliases] of Object.entries(COL_ALIASES)) {
    let found = "";
    for (const a of aliases) {
      const hit = byNorm.get(normHeader(a));
      if (hit) { found = hit; break; }
    }
    resolved[key] = found;
  }
  return resolved;
}
function val(row, colName){
  if (!colName) return "";
  const v = row[colName];
  return v == null ? "" : String(v).trim();
}

/* ========== Platform parsing ========== */
function extractPlatformsFromText(text){
  const t = String(text ?? "");
  const found = [];
  const re = /\b(PS5|PS4|PS3|PS2|PS1|PSVita|Vita|PC|Switch|Xbox|Series|One)\b/g;
  let m;
  while ((m = re.exec(t)) !== null) found.push(m[1]);
  return [...new Set(found)];
}
function platformsFromSystem(row){
  return extractPlatformsFromText(val(row, COL.system));
}
function rowHasPlatform(row, key){
  const plats = platformsFromSystem(row).map(p => p.toLowerCase());
  if (!plats.length){
    const fallback = [...extractPlatformsFromText(val(row, COL.trophies)), ...extractPlatformsFromText(val(row, COL.platinum))].map(p=>p.toLowerCase());
    return fallback.some(p => (PLATFORM_CANON[p] || p) === key);
  }
  return plats.some(p => (PLATFORM_CANON[p] || p) === key);
}

/* ========== XLSX Links & Delisted style ========== */
function buildLinks(ws){
  linkMap.clear();
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const headerR = r.s.r;
  headerRowIndex = headerR + 1;

  const headerByCol = new Map();
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    headerByCol.set(c, cell && cell.v != null ? String(cell.v).trim() : "");
  }

  for (let rr = headerR + 1; rr <= r.e.r; rr++){
    const row1 = rr + 1;
    for (let c = r.s.c; c <= r.e.c; c++){
      const cell = ws[XLSX.utils.encode_cell({ r: rr, c })];
      if (cell && cell.l && cell.l.Target){
        const colName = headerByCol.get(c);
        if (colName) linkMap.set(`${row1}:${colName}`, String(cell.l.Target));
      }
    }
  }
}
function applyDelistedFromStyles(ws){
  const ref = ws["!ref"]; if (!ref) return;
  const r = XLSX.utils.decode_range(ref);

  const titleCol = COL.title;
  if (!titleCol) return;

  const headerR = r.s.r;
  let titleC = null;
  for (let c = r.s.c; c <= r.e.c; c++){
    const cell = ws[XLSX.utils.encode_cell({ r: headerR, c })];
    const h = cell && cell.v != null ? String(cell.v).trim() : "";
    if (h === titleCol) { titleC = c; break; }
  }
  if (titleC == null) return;

  for (let i = 0; i < allRows.length; i++){
    const rr = headerR + 1 + i;
    const cell = ws[XLSX.utils.encode_cell({ r: rr, c: titleC })];
    const strike = !!(cell && cell.s && cell.s.font && (cell.s.font.strike || cell.s.font.strikethrough));
    if (strike) allRows[i].__delisted = true;
  }
}
function isDelistedRow(row){
  if (row.__delisted) return true;
  const v = val(row, COL.availability).toLowerCase();
  return v === "delisted" || v === "removed" || v.includes("store entfernt");
}
function getValueWithLink(row, colName, rowIndex1Based){
  const text = val(row, colName);
  const href = linkMap.get(`${rowIndex1Based}:${colName}`);
  if (href) return { text: text || "Store Link", href };
  return text;
}

/* ========== Parsing values for sorting ========== */
function parseAnyNumber(text){
  const t = String(text ?? "").trim();
  if (!t) return NaN;

  // handle "86 / 100"
  const mScore = t.match(/(\d+(?:[.,]\d+)?)/);
  if (mScore) return parseFloat(mScore[1].replace(",", "."));

  return NaN;
}
function parseHoursLike(text){
  const t = String(text ?? "").trim();
  if (!t) return NaN;
  const m = t.match(/(\d+(?:[.,]\d+)?)/);
  if (!m) return NaN;
  return parseFloat(m[1].replace(",", "."));
}
function toSortableValue(v){
  const t = String(v ?? "").trim();
  if (!t) return { type:"empty", v:"" };

  // numbers with comma/point
  const num = parseAnyNumber(t);
  if (Number.isFinite(num)) return { type:"num", v:num };

  // fallback string
  return { type:"str", v:t.toLowerCase() };
}

/* ========== UI helpers ========== */
function renderValue(value){
  if (value && typeof value === "object" && value.href) {
    const a = document.createElement("a");
    a.href = value.href;
    a.textContent = value.text || "Link";
    a.title = value.href;
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    return a;
  }
  const t = s(value);
  return document.createTextNode(t || PLACEHOLDER);
}
function kvLine(label, valueNode){
  const line = document.createElement("div");
  line.className = "kvLine";
  const k = document.createElement("div");
  k.className = "k";
  k.textContent = label;
  const v = document.createElement("div");
  v.className = "v";
  v.appendChild(valueNode);
  line.append(k, v);
  return line;
}
function makeChip(text, cls=""){
  const c = document.createElement("span");
  c.className = "chip" + (cls ? " " + cls : "");
  c.textContent = text;
  return c;
}
function makeIdBadge(idText){
  const b = document.createElement("span");
  b.className = "idBadge";
  b.textContent = `ID ${idText || PLACEHOLDER}`;
  return b;
}
function makeBadge(text, cls=""){
  const b = document.createElement("span");
  b.className = "badge" + (cls ? " " + cls : "");
  b.textContent = text;
  return b;
}
function formatFavorite(row){
  const f = val(row, COL.fav).toLowerCase();
  if (!f) return "";
  return (f === "x" || f === "1" || f === "true" || f === "yes" || f === "y" || f.includes("‚≠ê")) ? "‚≠ê Favorit" : "";
}
function isPlatinum(row){
  const p = val(row, COL.platinum).toLowerCase();
  if (!p) return false;
  return p.includes("platinum") || p === "x" || p === "ja" || p === "yes" || p === "true";
}
function formatPlaytime(row){
  const m = val(row, COL.main);
  const h = val(row, COL.hundred);
  if (!m && !h) return "";
  ifnd;
  if (m && h) return `${m}h / ${h}h`;
  return m ? `${m}h` : `${h}h`;
}
function makeToggleBlock(label, contentText){
  const d = document.createElement("details");
  d.className = "subdetails";
  const ssum = document.createElement("summary");
  const sbtn = document.createElement("span");
  sbtn.className = "summaryBtn";
  sbtn.textContent = `${label} anzeigen`;
  ssum.appendChild(sbtn);
  d.appendChild(ssum);

  const wrap = document.createElement("div");
  wrap.className = "content";
  const txt = document.createElement("div");
  txt.className = "v contentText";
  txt.textContent = contentText || PLACEHOLDER;
  wrap.appendChild(txt);
  d.appendChild(wrap);

  d.addEventListener("toggle", () => {
    sbtn.textContent = d.open ? `${label} ausblenden` : `${label} anzeigen`;
  });
  return d;
}

/* Trophy parsing */
function parsePlatformPairs(text){
  const t = String(text ?? "").trim();
  if (!t) return [];
  const hits = [];
  for (const p of PLATFORM_LIST) {
    const re = new RegExp(`\\b${p}\\b`, "g");
    let m;
    while ((m = re.exec(t)) !== null) hits.push({ p, i: m.index });
  }
  hits.sort((a,b)=>a.i-b.i);
  if (!hits.length) return [];
  const out = [];
  for (let j=0;j<hits.length;j++){
    const start = hits[j].i;
    const end = (j+1<hits.length) ? hits[j+1].i : t.length;
    const p = hits[j].p;
    let seg = t.slice(start, end).trim();
    seg = seg.replace(new RegExp(`^${p}\\s*`), "").trim();
    out.push({ platform: p, text: seg || PLACEHOLDER });
  }
  return out;
}
function parseFraction(text){
  const s = String(text ?? "");
  let m = s.match(/(\d+)\s*(?:of|von|\/)\s*(\d+)/i);
  if (!m) return null;
  const a = parseInt(m[1], 10);
  const b = parseInt(m[2], 10);
  if (!b) return null;
  const pct = Math.max(0, Math.min(1, a / b));
  return { a, b, pct };
}
function progressNode(fr){
  const wrap = document.createElement("div");
  wrap.className = "progressWrap";
  const bar = document.createElement("div");
  bar.className = "progressBar";
  const fill = document.createElement("div");
  fill.className = "progressFill";
  fill.style.width = `${Math.round(fr.pct * 100)}%`;
  bar.appendChild(fill);
  const lab = document.createElement("div");
  lab.className = "progressLabel";
  lab.textContent = `${Math.round(fr.pct * 100)}% (${fr.a}/${fr.b})`;
  wrap.append(bar, lab);
  return wrap;
}
function trophyList(items){
  const wrap = document.createElement("div");
  wrap.className = "trophyList";
  for (const it of items) {
    const rowEl = document.createElement("div");
    rowEl.className = "trophyRow";
    const chip = document.createElement("span");
    chip.className = "platformChip";
    chip.textContent = it.platform || "‚Äî";
    const right = document.createElement("div");
    right.className = "trophyRight";
    const txt = document.createElement("div");
    txt.className = "trophyText";
    txt.textContent = it.text || PLACEHOLDER;
    right.appendChild(txt);
    const fr = parseFraction(it.text);
    if (fr) right.appendChild(progressNode(fr));
    rowEl.append(chip, right);
    wrap.appendChild(rowEl);
  }
  return wrap;
}
function trophyNeutral(text, sysPlatforms){
  const outer = document.createElement("div");
  outer.style.display = "grid";
  outer.style.gap = "8px";
  if (sysPlatforms && sysPlatforms.length) {
    const chipRow = document.createElement("div");
    chipRow.style.display = "flex";
    chipRow.style.gap = "6px";
    chipRow.style.flexWrap = "wrap";
    for (const p of sysPlatforms) chipRow.appendChild(makeChip(p));
    outer.appendChild(chipRow);
  }
  const txt = document.createElement("div");
  txt.className = "trophyText";
  txt.textContent = text || PLACEHOLDER;
  outer.appendChild(txt);
  const fr = parseFraction(text);
  if (fr) outer.appendChild(progressNode(fr));
  return outer;
}
function trophyNodeFromText(text, row){
  const raw = String(text ?? "").trim();
  if (!raw) return document.createTextNode(PLACEHOLDER);
  const pairs = parsePlatformPairs(raw);
  if (pairs.length) return trophyList(pairs);
  const sysPlatforms = platformsFromSystem(row);
  if (sysPlatforms.length === 1) return trophyList([{ platform: sysPlatforms[0], text: raw }]);
  if (sysPlatforms.length > 1) return trophyNeutral(raw, sysPlatforms);
  return trophyNeutral(raw, []);
}

/* ========== Card ========== */
function createCard(row, rowIndex1Based){
  const card = document.createElement("div");
  card.className = "card";

  const top = document.createElement("div");
  top.className = "cardTop";

  const titleRow = document.createElement("div");
  titleRow.className = "titleRow";

  const title = document.createElement("div");
  title.className = "title";
  title.textContent = val(row, COL.title) || "(ohne Titel)";
  if (isDelistedRow(row)) title.classList.add("delisted");

  const badges = document.createElement("div");
  badges.className = "badges";
  if (isDelistedRow(row)) badges.appendChild(makeBadge("Delisted", "delisted"));
  const favLabel = formatFavorite(row);
  if (favLabel) badges.appendChild(makeBadge(favLabel));
  if (isPlatinum(row)) badges.appendChild(makeBadge("üíé Platin", "platin"));

  titleRow.append(title, badges);

  const metaRow = document.createElement("div");
  metaRow.className = "metaRow";
  metaRow.appendChild(makeIdBadge(val(row, COL.id)));

  let plats = platformsFromSystem(row);
  if (!plats.length) {
    const fromT = extractPlatformsFromText(val(row, COL.trophies));
    const fromP = extractPlatformsFromText(val(row, COL.platinum));
    plats = [...new Set([...fromT, ...fromP])];
  }
  if (plats.length) plats.forEach(p => metaRow.appendChild(makeChip(p)));
  else metaRow.appendChild(makeChip(PLACEHOLDER));
  metaRow.appendChild(makeChip(val(row, COL.availability) || PLACEHOLDER));

  top.append(titleRow, metaRow);

  const key = document.createElement("div");
  key.className = "keyFacts";

  const genre = val(row, COL.genre);
  const subg  = val(row, COL.subgenre);
  const pt    = formatPlaytime(row);
  const metaScore = val(row, COL.meta);
  const userScore = val(row, COL.user);

  if (genre || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Genre", renderValue(genre)));
  if (subg  || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Subgenre / Stimmung", renderValue(subg)));
  if (pt    || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Spielzeit", renderValue(pt)));
  if (metaScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Metascore", renderValue(metaScore)));
  if (userScore || SHOW_EMPTY_IN_KEYFACTS) key.appendChild(kvLine("Userwertung", renderValue(userScore)));

  const detailsWrap = document.createElement("div");
  detailsWrap.className = "detailsWrap";

  const details = document.createElement("details");
  const summary = document.createElement("summary");
  const sumSpan = document.createElement("span");
  sumSpan.className = "summaryBtn";
  sumSpan.textContent = "Mehr Details";
  summary.appendChild(sumSpan);
  details.appendChild(summary);

  details.addEventListener("toggle", () => {
    sumSpan.textContent = details.open ? "Weniger Details" : "Mehr Details";
  });

  function addSection(titleText, lines){
    if (!lines.some(x => x != null)) return;
    const sec = document.createElement("div");
    sec.className = "section";
    const st = document.createElement("div");
    st.className = "sectionTitle";
    st.textContent = titleText;
    sec.appendChild(st);
    for (const line of lines) if (line) sec.appendChild(line);
    details.appendChild(sec);
  }

  addSection("Beschreibung", [ makeToggleBlock("Kurzbeschreibung", val(row, COL.desc)) ]);

  const storeVal = (viewState.fileMode === "xlsx")
    ? getValueWithLink(row, COL.store, rowIndex1Based)
    : val(row, COL.store);

  addSection("Store", [
    (storeVal || SHOW_EMPTY_IN_DETAILS) ? kvLine("Store", renderValue(storeVal)) : null,
    (val(row, COL.source) || SHOW_EMPTY_IN_DETAILS) ? kvLine("Quelle", renderValue(val(row, COL.source))) : null,
    (val(row, COL.availability) || SHOW_EMPTY_IN_DETAILS) ? kvLine("Verf√ºgbarkeit", renderValue(val(row, COL.availability))) : null,
  ]);

  addSection("Entwickler", [
    (val(row, COL.dev) || SHOW_EMPTY_IN_DETAILS) ? kvLine("Entwickler", renderValue(val(row, COL.dev))) : null
  ]);

  addSection("Extras", [
    makeToggleBlock("Besonderheiten", val(row, COL.special)),
    makeToggleBlock("Eastereggs", val(row, COL.easter))
  ]);

  addSection("Troph√§en", [
    kvLine("Fortschritt", trophyNodeFromText(val(row, COL.trophies), row)),
    kvLine("Platin", trophyNodeFromText(val(row, COL.platinum), row)),
  ]);

  addSection("Humorstatistik", [
    (val(row, COL.hours) || SHOW_EMPTY_IN_DETAILS) ? kvLine("Gesamtstunden", renderValue(val(row, COL.hours))) : null,
    (val(row, COL.life)  || SHOW_EMPTY_IN_DETAILS) ? kvLine("% Lebenszeit", renderValue(val(row, COL.life))) : null,
    (val(row, COL.years) || SHOW_EMPTY_IN_DETAILS) ? kvLine("Jahre", renderValue(val(row, COL.years))) : null,
  ]);

  detailsWrap.appendChild(details);
  card.append(top, key, detailsWrap);
  return card;
}

/* ========== Query syntax ========== */
function parseQuery(q){
  const raw = (q || "").trim();
  const tokens = raw.length ? raw.split(/\s+/) : [];
  const filters = {
    text: [],
    id: "",
    dev: "",
    platform: "",
    genre: "",
    sub: "",
    fav: null,
    platin: null,
    delisted: null,
  };
  const truthy = v => ["1","true","yes","ja","x"].includes(String(v).toLowerCase());
  const falsy  = v => ["0","false","no","nein"].includes(String(v).toLowerCase());

  for (const t of tokens){
    const m = t.match(/^(\w+)\:(.+)$/);
    if (!m){ filters.text.push(t); continue; }
    const key = m[1].toLowerCase();
    const vv = m[2];
    if (key === "id") filters.id = vv;
    else if (key === "dev") filters.dev = vv;
    else if (key === "platform" || key === "plat") filters.platform = vv.toLowerCase();
    else if (key === "genre") filters.genre = vv;
    else if (key === "sub") filters.sub = vv;
    else if (key === "fav") filters.fav = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "platin") filters.platin = truthy(vv) ? true : (falsy(vv) ? false : null);
    else if (key === "delisted") filters.delisted = truthy(vv) ? true : (falsy(vv) ? false : null);
    else filters.text.push(t);
  }
  return filters;
}
function queryMatchesRow(qf, row){
  const txt = qf.text.join(" ").toLowerCase();
  if (txt){
    const hay = Object.values(row).map(v => s(v).toLowerCase()).join(" ");
    if (!hay.includes(txt)) return false;
  }
  if (qf.id && !val(row, COL.id).toLowerCase().includes(qf.id.toLowerCase())) return false;
  if (qf.dev && !val(row, COL.dev).toLowerCase().includes(qf.dev.toLowerCase())) return false;
  if (qf.genre && !val(row, COL.genre).toLowerCase().includes(qf.genre.toLowerCase())) return false;
  if (qf.sub && !val(row, COL.subgenre).toLowerCase().includes(qf.sub.toLowerCase())) return false;
  if (qf.platform){
    const canon = PLATFORM_CANON[qf.platform] || qf.platform;
    if (!rowHasPlatform(row, canon)) return false;
  }
  if (qf.fav !== null){ if ((!!formatFavorite(row)) !== qf.fav) return false; }
  if (qf.platin !== null){ if (isPlatinum(row) !== qf.platin) return false; }
  if (qf.delisted !== null){ if (isDelistedRow(row) !== qf.delisted) return false; }
  return true;
}

/* ========== Chip filters ========== */
function applyChipUI(){
  for (const el of els.filtersRow.querySelectorAll(".chip[data-filter]")){
    const k = el.getAttribute("data-filter");
    el.classList.toggle("on", !!viewState.filters[k]);
  }
  els.clearFilters.disabled = !(Object.values(viewState.filters).some(Boolean));
}
function rowPassesChipFilters(row){
  const f = viewState.filters;
  if (f.fav && !formatFavorite(row)) return false;
  if (f.platin && !isPlatinum(row)) return false;
  if (f.delisted && !isDelistedRow(row)) return false;

  const platformFilters = ["ps5","ps4","ps3","vita"].filter(k => f[k]);
  if (platformFilters.length){
    const ok = platformFilters.some(k => rowHasPlatform(row, k));
    if (!ok) return false;
  }
  return true;
}

/* ========== Sorting (ALL columns) ========== */
function buildSortOptionsFromColumns(){
  const opts = [];
  // internal: ID always first if present
  opts.push({ value:"__id", label:"ID" });

  // then all actual columns in sheet
  for (const c of columns){
    opts.push({ value:c, label:c });
  }

  // fill select
  els.sort.innerHTML = "";
  for (const o of opts){
    const op = document.createElement("option");
    op.value = o.value;
    op.textContent = "Sort: " + o.label;
    els.sort.appendChild(op);
  }

  // restore selected
  if (opts.some(o=>o.value===viewState.sortKey)) els.sort.value = viewState.sortKey;
  else { viewState.sortKey = "__id"; els.sort.value = "__id"; saveState(); }
}
function getSortValue(row, sortKey){
  if (sortKey === "__id") return toSortableValue(val(row, COL.id));
  // raw column
  return toSortableValue(row[sortKey]);
}
function sortMatches(arr){
  const dir = viewState.sortDir === "asc" ? 1 : -1;
  const key = viewState.sortKey;

  arr.sort((a,b)=>{
    const av = getSortValue(a.row, key);
    const bv = getSortValue(b.row, key);

    // empty last
    if (av.type === "empty" && bv.type !== "empty") return 1;
    if (bv.type === "empty" && av.type !== "empty") return -1;

    // both numbers
    if (av.type === "num" && bv.type === "num"){
      if (av.v === bv.v) return 0;
      return dir * (av.v < bv.v ? -1 : 1);
    }

    // mix or both strings: compare as strings
    const as = String(av.v ?? "");
    const bs = String(bv.v ?? "");
    return dir * as.localeCompare(bs, "de", { sensitivity:"base" });
  });

  return arr;
}

/* ========== Paging / Infinite Scroll ========== */
let io = null;
let isLoading = false;

function updateCounters(){
  const total = matches.length;
  els.count.textContent = total ? `Treffer: ${total} ¬∑ angezeigt: ${shown}/${total}` : "";
}
function renderMore(){
  if (isLoading) return;
  const total = matches.length;
  if (shown >= total) return;

  isLoading = true;
  const end = Math.min(shown + PAGE_SIZE, total);
  const frag = document.createDocumentFragment();

  for (let i = shown; i < end; i++){
    const { row, idx } = matches[i];
    frag.appendChild(createCard(row, idx));
  }
  els.grid.appendChild(frag);
  shown = end;

  els.status.textContent = total
    ? (shown < total ? "Lade weitere Karten‚Ä¶" : "Alle Karten angezeigt.")
    : "Keine Treffer.";

  updateCounters();
  isLoading = false;
}

function rebuildMatches(){
  els.grid.innerHTML = "";
  shown = 0;

  const q = parseQuery(viewState.search);

  matches = allRows
    .map((row, i) => ({ row, idx: headerRowIndex + 1 + i }))
    .filter(o => queryMatchesRow(q, o.row))
    .filter(o => rowPassesChipFilters(o.row));

  sortMatches(matches);
  renderMore();

  els.status.textContent = `Treffer: ${matches.length}`;
  updateCounters();
}
function startSearch(q){
  viewState.search = q || "";
  saveState();
  rebuildMatches();
}

/* ========== CSV fallback ========== */
function detectDelimiter(firstLine){
  const commas = (firstLine.match(/,/g) || []).length;
  const semis  = (firstLine.match(/;/g) || []).length;
  return semis > commas ? ";" : ",";
}
function parseCSV(text){
  const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
  while (lines.length && !lines[0].trim()) lines.shift();
  if (!lines.length) return { rows: [], headers: [] };

  const delim = detectDelimiter(lines[0]);

  function splitLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const ch = line[i];
      if (ch === '"'){
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (ch === delim && !inQ){
        out.push(cur); cur = "";
      } else cur += ch;
    }
    out.push(cur);
    return out.map(v => v.trim());
  }

  const headers = splitLine(lines[0]).map(h => h.replace(/^\uFEFF/, "").trim());
  const rows = [];
  for (let r=1; r<lines.length; r++){
    const line = lines[r];
    if (!line || !line.trim()) continue;
    const cells = splitLine(line);
    const obj = {};
    for (let c=0; c<headers.length; c++) obj[headers[c]] = cells[c] ?? "";
    rows.push(obj);
  }
  return { rows, headers };
}

/* ========== Load file ========== */
function resetUIForNewData(){
  els.grid.innerHTML = "";
  els.count.textContent = "";
  els.search.disabled = true;
  els.sort.disabled = true;
  els.sortDir.disabled = true;
  els.sheet.disabled = true;
  els.sheet.innerHTML = "<option>Sheet ausw√§hlen‚Ä¶</option>";
  linkMap.clear();
  headerRowIndex = 1;
  allRows = [];
  matches = [];
  shown = 0;
  columns = [];
  workbook = null;
}

async function loadXLSX(file){
  if (typeof XLSX === "undefined") {
    els.status.textContent = "Fehler: XLSX Library nicht geladen (xlsx.full.min.js fehlt?)";
    return;
  }
  viewState.fileMode = "xlsx";

  const buf = await file.arrayBuffer();
  workbook = XLSX.read(buf, { type: "array", cellStyles: true });

  els.sheet.innerHTML = "<option>Sheet ausw√§hlen‚Ä¶</option>";
  workbook.SheetNames.forEach(n => {
    const o = document.createElement("option");
    o.value = n; o.textContent = n;
    els.sheet.appendChild(o);
  });

  els.sheet.disabled = false;
  els.status.textContent = "Sheet w√§hlen‚Ä¶";

  if (viewState.sheetName && workbook.SheetNames.includes(viewState.sheetName)){
    els.sheet.value = viewState.sheetName;
    loadSheet(viewState.sheetName);
  }
}

function loadSheet(name){
  const ws = workbook.Sheets[name];
  const json = XLSX.utils.sheet_to_json(ws, { defval: "" });

  allRows = json;
  columns = json.length ? Object.keys(json[0]) : [];
  COL = resolveColumns(columns);

  buildLinks(ws);
  applyDelistedFromStyles(ws);

  buildSortOptionsFromColumns();

  els.search.disabled = false;
  els.sort.disabled = false;
  els.sortDir.disabled = false;

  els.search.value = viewState.search || "";
  els.sort.value = viewState.sortKey || "__id";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";

  viewState.sheetName = name;
  saveState();

  els.status.textContent = `Geladen: ${allRows.length} Zeilen`;
  rebuildMatches();
}

async function loadCSV(file){
  viewState.fileMode = "csv";
  workbook = null;
  linkMap.clear();

  const buf = await file.arrayBuffer();
  const text = new TextDecoder("utf-8").decode(buf);

  const parsed = parseCSV(text);
  allRows = parsed.rows;
  columns = parsed.headers;
  COL = resolveColumns(columns);

  buildSortOptionsFromColumns();

  els.sheet.disabled = true;
  els.sheet.innerHTML = "<option>(CSV: kein Sheet)</option>";
  els.search.disabled = false;
  els.sort.disabled = false;
  els.sortDir.disabled = false;

  els.search.value = viewState.search || "";
  els.sort.value = viewState.sortKey || "__id";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";

  els.status.textContent = `CSV geladen: ${allRows.length} Zeilen`;
  saveState();
  rebuildMatches();
}

/* ========== Events ========== */
els.file.addEventListener("change", async (e) => {
  const f = e.target.files?.[0]; if (!f) return;
  resetUIForNewData();
  els.status.textContent = "Lese Datei‚Ä¶";
  const name = (f.name || "").toLowerCase();
  try{
    if (name.endsWith(".csv")) await loadCSV(f);
    else await loadXLSX(f);
  }catch(err){
    els.status.textContent = "Fehler beim Einlesen: " + (err?.message || String(err));
  }
});

els.sheet.addEventListener("change", () => {
  const name = els.sheet.value;
  if (!name || name === "Sheet ausw√§hlen‚Ä¶") return;
  loadSheet(name);
});

els.search.addEventListener("input", (e) => startSearch(e.target.value));

els.sort.addEventListener("change", (e) => {
  viewState.sortKey = e.target.value;
  saveState();
  rebuildMatches();
});

els.sortDir.addEventListener("click", () => {
  viewState.sortDir = (viewState.sortDir === "asc") ? "desc" : "asc";
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";
  saveState();
  rebuildMatches();
});

els.filtersRow.addEventListener("click", (e) => {
  const t = e.target;
  if (!(t instanceof HTMLElement)) return;

  if (t.id === "clearFiltersBtn"){
    for (const k of Object.keys(viewState.filters)) viewState.filters[k] = false;
    applyChipUI();
    saveState();
    rebuildMatches();
    return;
  }

  if (t.classList.contains("chip") && t.dataset.filter){
    const k = t.dataset.filter;
    viewState.filters[k] = !viewState.filters[k];
    applyChipUI();
    saveState();
    rebuildMatches();
  }
});

els.fabTop.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));

/* Header compact on scroll + FAB show */
let lastY = 0;
window.addEventListener("scroll", () => {
  const y = window.scrollY;
  const goingDown = y > lastY;
  lastY = y;

  els.fabTop.classList.toggle("show", y > 500);

  // compact header when scrolling down, expand when scrolling up a bit
  if (goingDown && y > 120) els.hdr.classList.add("compact");
  if (!goingDown && y < 260) els.hdr.classList.remove("compact");
}, { passive:true });

/* Infinite scroll observer */
function setupObserver(){
  if (io) io.disconnect();
  io = new IntersectionObserver((entries)=>{
    const e = entries[0];
    if (!e) return;
    if (e.isIntersecting){
      // load more when reaching bottom sentinel
      renderMore();
    }
  }, { root:null, threshold:0.1 });
  io.observe(els.sentinel);
}
setupObserver();

/* Restore chips UI */
function bootUI(){
  applyChipUI();
  els.sortDir.textContent = (viewState.sortDir === "asc") ? "‚Üë" : "‚Üì";
  els.search.value = viewState.search || "";
}
bootUI();
</script>
</body>
</html>